# 1 "main.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "main.c"


# 1 "./include/qtypes.h" 1
# 84 "./include/qtypes.h"
typedef unsigned int uint32;
# 104 "./include/qtypes.h"
typedef unsigned long long U64;
typedef unsigned long U32;
typedef unsigned short U16;
typedef unsigned char U8;
# 4 "main.c" 2


# 1 "./include/hardware.h" 1
# 7 "main.c" 2
# 1 "sp.h" 1




# 1 "./include/ql_structs.h" 1
# 62 "./include/ql_structs.h"
typedef struct {
 unsigned long addr_lo;
 unsigned long addr_hi;
 unsigned long length;
} dseg_struct;




typedef struct {
 unsigned long ref_tag;
 union {
  unsigned long rep_ref_tag;
  unsigned long ref_mask;
 };
 union {
  unsigned short rep_app_tag;
  unsigned short app_mask;
 };
 unsigned short app_tag;
} skp_msk_tag_struct;


typedef struct {
 skp_msk_tag_struct tag;
 dseg_struct dsd;
} skp_msk_dsd_struct;



typedef struct {
 union {
  unsigned long full_adr;
  struct {
   unsigned long blk_id: 20,
     mem_rgn: 6,
     flags: 6;
  };
 };
} mim_adr_struct;
enum { ql_struct_assert_line_102 = (!(sizeof(mim_adr_struct) != 4)) };
# 113 "./include/ql_structs.h"
typedef struct {
 mim_adr_struct nxt_crp_adr;
 unsigned short nxt_crp_ofst;
 unsigned char nxt_dsd_rel_idx;
 unsigned char rsvd0;
 dseg_struct cur_dsd;
 unsigned short rem_dsd_cnt;
 unsigned short rsvd1;
 unsigned long cur_dsd_rist;
 unsigned long tot_ofst;
} alcb_struct;
enum { ql_struct_assert_line_124 = (!(sizeof(alcb_struct) != 32)) };
# 6 "sp.h" 2
# 1 "./include/ql_drp.h" 1



# 1 "./include/ql_structs.h" 1
# 5 "./include/ql_drp.h" 2
# 1 "./include/fc_iocb.h" 1
# 156 "./include/fc_iocb.h"
typedef struct fc_iocb_hdr_s {
 union {
  struct {
   unsigned char iocb_type;
   unsigned char iocb_count;
  };
  unsigned short iocb_cnt_typ;
 };
 unsigned char iocb_sysdef_1;
 unsigned char iocb_status;
} fc_iocb_hdr_struct;
enum { fciocb_assert_line_167 = (!(sizeof(fc_iocb_hdr_struct) != (4/4))) };





typedef struct cont1_s {
 dseg_struct cont_dataseg[5];
} cont1_struct;
enum { fciocb_assert_line_176 = (!(sizeof(cont1_struct) != ((64/4)-(4/4)))) };


typedef struct cont_crc1_s {
 unsigned short guard_seed;
 unsigned short prot_opts;
 unsigned short block_sz;
 unsigned short runt_guard;

 union {
  struct {
   unsigned long ndb_tot_pxc;
   dseg_struct dataseg[4];
  } non_db;
  struct {
   unsigned long db_data_pxc;
   unsigned long db_dif_pxc;
   unsigned short rsvd_1;
   unsigned short blk_dsd_cnt;
   unsigned long rsvd_2;
   dseg_struct dataseg[3];
  } db;
 };
} cont_crc1_struct;
enum { fciocb_assert_line_200 = (!(sizeof(cont_crc1_struct) != ((64/4)-(4/4)))) };



typedef struct cmnd7_s {
 unsigned long cmnd_handle;
 unsigned short cmnd_target;
 unsigned short cmnd_timeout;
 unsigned short cmnd_seg_cnt;
 unsigned short cmnd_rsvd_0;
 unsigned long cmnd_lun_l;
 unsigned long cmnd_lun_h;
 union {
  struct {
   unsigned short cmnd_tm;
   unsigned short cmnd_crn;
  };
  unsigned long cmnd_cntl;
 };
 unsigned long cmnd_cdb0;
 unsigned long cmnd_cdb1;
 unsigned long cmnd_cdb2;
 unsigned long cmnd_cdb3;
 unsigned long cmnd_byte_cnt;
 unsigned long cmnd_target_id:24,
   cmnd_vp_index:8;
 dseg_struct cmnd_dataseg0;

} cmnd7_struct;
enum { fciocb_assert_line_229 = (!(sizeof(cmnd7_struct) != ((64/4)-(4/4)))) };


typedef struct cmnd6_s {
 unsigned long cmnd_handle;
 unsigned short cmnd_target;
 unsigned short cmnd_timeout;
 unsigned short cmnd_seg_cnt;
 unsigned short cmnd_fcprsp_len;
 unsigned long cmnd_lun_l;
 unsigned long cmnd_lun_h;
 unsigned short cmnd_cntl;
 unsigned short cmnd_fcpcmd_len;
 unsigned long cmnd_fcpcmd_adr_lo;
 unsigned long cmnd_fcpcmd_adr_hi;
 unsigned long cmnd_fcprsp_adr_lo;
 unsigned long cmnd_fcprsp_adr_hi;
 unsigned long cmnd_byte_cnt;
 unsigned long cmnd_target_id:24,
   cmnd_vp_index:8;
 dseg_struct cmnd_dataseg0;

} cmnd6_struct;
enum { fciocb_assert_line_252 = (!(sizeof(cmnd6_struct) != ((64/4)-(4/4)))) };


typedef struct cmnd_crc1_s {
 unsigned long cmnd_handle;
 unsigned short cmnd_target;
 unsigned short cmnd_timeout;
 unsigned short cmnd_seg_cnt;
 union {
  unsigned short cmnd_crc1_rsvd_0;
  unsigned short cmnd_crc3_opts;
 };
 unsigned long cmnd_lun_l;
 unsigned long cmnd_lun_h;
 union {
  struct {
   unsigned short cmnd_tm;
   unsigned short cmnd_crn;
  };
  unsigned long cmnd_cntl;
 };
 unsigned long cmnd_cdb0;
 unsigned long cmnd_cdb1;
 unsigned long cmnd_cdb2;
 unsigned long cmnd_cdb3;
 unsigned long cmnd_byte_cnt;
 unsigned long cmnd_target_id:24,
   cmnd_vp_index:8;
 unsigned long cmnd_ref_tag;
 unsigned short cmnd_app_tag;
 unsigned short cmnd_ref_mask_l;
 unsigned short cmnd_ref_mask_h;
 unsigned short cmnd_app_mask;
} cmnd_crc1_struct;
enum { fciocb_assert_line_286 = (!(sizeof(cmnd_crc1_struct) != ((64/4)-(4/4)))) };


typedef struct cmnd_crc2_s {
 unsigned long cmnd_handle;
 unsigned short cmnd_target;
 unsigned short cmnd_timeout;
 unsigned short cmnd_seg_cnt;
 unsigned short cmnd_fcprsp_len;
 unsigned long cmnd_lun_l;
 unsigned long cmnd_lun_h;
 unsigned short cmnd_cntl;
 unsigned short cmnd_fcpcmd_len;
 unsigned long cmnd_fcpcmd_adr_l;
 unsigned long cmnd_fcpcmd_adr_h;
 unsigned long cmnd_fcprsp_adr_l;
 unsigned long cmnd_fcprsp_adr_h;
 unsigned long cmnd_byte_cnt;
 unsigned long cmnd_target_id:24,
   cmnd_vp_index:8;
 dseg_struct cmnd_crc_ctx_dsd;
} cmnd_crc2_struct;
enum { fciocb_assert_line_308 = (!(sizeof(cmnd_crc2_struct) != ((64/4)-(4/4)))) };


typedef struct cmnd_crc3_s {
 unsigned long cmnd_handle;
 unsigned short cmnd_target;
 unsigned short cmnd_timeout;
 unsigned short cmnd_seg_cnt;
 unsigned short cmnd_crc3_opts;
 unsigned long cmnd_lun_l;
 unsigned long cmnd_lun_h;
 union {
  struct {
   unsigned short cmnd_tm;
   unsigned short cmnd_crn;
  };
  unsigned long cmnd_cntl;
 };
 unsigned long cmnd_cdb0;
 unsigned long cmnd_cdb1;
 unsigned long cmnd_cdb2;
 unsigned long cmnd_cdb3;
 unsigned long cmnd_byte_cnt;
 unsigned long cmnd_target_id:24,
   cmnd_vp_index:8;
 unsigned long cmnd_ref_tag0;
 unsigned short cmnd_app_tag0;
 union {
  struct {
   unsigned short cmnd_rep_ref_tag0_l;
   unsigned short cmnd_rep_ref_tag0_h;
   unsigned short cmnd_rep_app_tag0;
  } vr;
  struct {
   unsigned short cmnd_ref_mask0_l;
   unsigned short cmnd_ref_mask0_h;
   unsigned short cmnd_app_mask0;
  } nvr;
 };

} cmnd_crc3_struct;
enum { fciocb_assert_line_349 = (!(sizeof(cmnd_crc3_struct) != ((64/4)-(4/4)))) };



typedef struct sts0_iocb_s {
 unsigned long sts_handle;
 unsigned short sts_status;
 unsigned short sts_oxid;
 unsigned long sts_fw_resid;
 union {
  unsigned short sts_status_flags;
  unsigned short sts_fcp_rsp_pyld_len;
 };
 unsigned short sts_state_flags;
 unsigned short sts_retry_delay_timer;
 unsigned short sts_scsi_status;
 unsigned long sts_scsi_resid;
 unsigned long sts_sens_len;
 unsigned long sts_rsp_len;
 union {
  unsigned long sts_rsp_sns_info[7];
  struct {
   unsigned long sts_rsvd_0[3];
   unsigned long sts_act_dif[2];
   unsigned long sts_exp_dif[2];
  };
 };





} sts0_iocb_struct;
enum { fciocb_assert_line_382 = (!(sizeof(sts0_iocb_struct) != ((64/4)-(4/4)))) };



typedef struct tm_iocb_s {
 unsigned long scsi_tm_handle;
 unsigned short scsi_tm_target;
 unsigned short scsi_tm_rsvd_0;
 unsigned short scsi_tm_delay;
 unsigned short scsi_tm_timeout;
 unsigned long scsi_tm_lun_l;
 unsigned long scsi_tm_lun_h;
 unsigned long scsi_tm_flags;
 unsigned long scsi_tm_rsvd_1[5];
 unsigned long scsi_tm_target_id:24,
   cmnd_vp_index:8;
 unsigned short scsi_tm_xvp_index;
 unsigned short scsi_tm_rsvd_2;
 unsigned long scsi_tm_rsvd_3[2];
} tm_iocb_struct;
enum { fciocb_assert_line_402 = (!(sizeof(tm_iocb_struct) != ((64/4)-(4/4)))) };



typedef struct marker_s {
 unsigned long mrkr_handle;
 unsigned short mrkr_target;
 unsigned char mrkr_modfr;
 unsigned char mrkr_rsvd_0;
 unsigned short mrkr_vp_index;
 unsigned short mrkr_rsvd_1;
 unsigned long mrkr_lun_l;
 unsigned long mrkr_lun_h;
 unsigned long mrkr_rsvd_2[10];
} marker_struct;
enum { fciocb_assert_line_417 = (!(sizeof(marker_struct) != ((64/4)-(4/4)))) };



typedef struct ctio7_s {
 unsigned long ctio_handle;
 union {
  unsigned short ctio_target;
  unsigned short ctio_status;
 };
 unsigned short ctio_timeout;
 unsigned short ctio_seg_cnt;
 unsigned char ctio_vp_index;
 unsigned char ctio_add_flags;
 unsigned long ctio_init_id:24,
   ctio_rsvd_0:8;
 mim_adr_struct rcv_xchg_adr;
 union {
  struct {
   unsigned short ctio_rsvd_1;
   unsigned short ctio_flags;
   unsigned long ctio_rsvd_2;
   unsigned short ctio_oxid;
   unsigned short ctio_rsvd_3;
   unsigned long ctio_ro;
   unsigned long ctio_rsvd_4;
   unsigned long ctio_byte_cnt;
   unsigned long ctio_rsvd_5;
   dseg_struct ctio_dataseg0;
  } mode0;
  struct {
   unsigned short ctio_sns_len;
   unsigned short ctio_flags;
   unsigned long ctio_resid_len;
   unsigned short ctio_oxid;
   unsigned short ctio_scsi_sts;
   unsigned short ctio_rsp_len;
   unsigned short ctio_rsvd_3;
   unsigned char ctio_rsp_sns_info[24];
  } mode1;
  struct {
   unsigned short ctio_rsvd_1;
   unsigned short ctio_flags;
   unsigned long ctio_resid_len;
   unsigned short ctio_oxid;
   unsigned char ctio_rsvd_2[10];
   unsigned long ctio_byte_cnt;
   unsigned long ctio_rsvd_3;
   dseg_struct ctio_dataseg0;
  } mode2;
 };
} ctio7_struct;
enum { fciocb_assert_line_469 = (!(sizeof(ctio7_struct) != ((64/4)-(4/4)))) };


typedef struct ctio_crc1_s {
 unsigned long ctio_handle;
 union {
  unsigned short ctio_target;
  unsigned short ctio_status;
 };
 unsigned short ctio_timeout;
 unsigned short ctio_seg_cnt;
 unsigned char ctio_vp_index;
 unsigned char ctio_add_flags;
 unsigned long ctio_init_id:24,
   ctio_rsvd_0:8;
 mim_adr_struct rcv_xchg_adr;

 unsigned short ctio_rsvd_1;
 unsigned short ctio_flags;
 unsigned long ctio_rsvd_2;
 unsigned short ctio_oxid;
 unsigned short ctio_rsvd_3;
 unsigned long ctio_ro;
 unsigned long ctio_rsvd_4;
 unsigned long ctio_byte_cnt;
 unsigned long ctio_rsvd_5;

 unsigned long cmnd_ref_tag;
 unsigned short cmnd_app_tag;
 unsigned short cmnd_ref_mask_l;
 unsigned short cmnd_ref_mask_h;
 unsigned short cmnd_app_mask;

} ctio_crc1_struct;
enum { fciocb_assert_line_503 = (!(sizeof(ctio_crc1_struct) != ((64/4)-(4/4)))) };


typedef struct ctio_crc2_s {
 unsigned long ctio_handle;
 union {
  unsigned short ctio_target;
  unsigned short ctio_status;
 };
 unsigned short ctio_timeout;
 unsigned short ctio_seg_cnt;
 unsigned char ctio_vp_index;
 unsigned char ctio_add_flags;
 unsigned long ctio_init_id:24,
   ctio_rsvd_0:8;
 mim_adr_struct rcv_xchg_adr;

 unsigned short ctio_rsvd_1;
 unsigned short ctio_flags;
 unsigned long ctio_rsvd_2;
 unsigned short ctio_oxid;
 unsigned short ctio_rsvd_3;
 unsigned long ctio_ro;
 unsigned long ctio_rsvd_4;
 unsigned long ctio_byte_cnt;
 unsigned long ctio_rsvd_5;

 dseg_struct ctio_crc_ctx_dsd;

} ctio_crc2_struct;
enum { fciocb_assert_line_533 = (!(sizeof(ctio_crc2_struct) != ((64/4)-(4/4)))) };



typedef struct ctio_crc3_s {
 unsigned long ctio_handle;
 union {
  unsigned short ctio_target;
  unsigned short ctio_status;
 };
 unsigned short ctio_timeout;
 unsigned short ctio_seg_cnt;
 unsigned char ctio_vp_index;
 unsigned char ctio_add_flags;
 unsigned long ctio_init_id:24,
   ctio_rsvd_0:8;
 mim_adr_struct rcv_xchg_adr;

 unsigned short ctio_rsvd_1;
 unsigned short ctio_flags;
 unsigned long ctio_rsvd_2;
 unsigned short ctio_oxid;
 unsigned short ctio_rsvd_3;
 unsigned long ctio_ro;
 unsigned long ctio_rsvd_4;
 unsigned long ctio_byte_cnt;
 unsigned long ctio_rsvd_5;
 unsigned long ctio_ref_tag0;
 unsigned short ctio_app_tag0;

 union {
  struct {
   unsigned short ctio_rep_ref_tag0_l;
   unsigned short ctio_rep_ref_tag0_h;
   unsigned short ctio_rep_app_tag0;
  } vr;
  struct {
   unsigned short ctio_ref_mask0_l;
   unsigned short ctio_ref_mask0_h;
   unsigned short ctio_app_mask0;
  } nvr;
 };

} ctio_crc3_struct;
enum { fciocb_assert_line_577 = (!(sizeof(ctio_crc3_struct) != ((64/4)-(4/4)))) };


typedef struct ctio_crc4_s {
 unsigned long ctio_handle;
 union {
  unsigned short ctio_target;
  unsigned short ctio_status;
 };
 unsigned short ctio_timeout;
 unsigned short ctio_seg_cnt;
 unsigned char ctio_vp_index;
 unsigned char ctio_add_flags;
 unsigned long ctio_init_id:24,
   ctio_rsvd_0:8;
 mim_adr_struct rcv_xchg_adr;

 unsigned short ctio_app_tag0;
 unsigned short ctio_flags;
 unsigned long ctio_ref_tag0;
 unsigned short ctio_oxid;
 unsigned short ctio_prot_opts;
 unsigned long ctio_ro;
 unsigned short ctio_guard_seed;
 unsigned short ctio_rsvd_4;
 unsigned long ctio_byte_cnt;
 unsigned long ctio_tot_ptc;

 dseg_struct ctio_dataseg0;

} ctio_crc4_struct;
enum { fciocb_assert_line_608 = (!(sizeof(ctio_crc4_struct) != ((64/4)-(4/4)))) };




typedef struct fc_iocb_s {
 fc_iocb_hdr_struct hdr;
 union {
  cont1_struct cont1;
  cont_crc1_struct cont_crc1;
  cmnd7_struct cmnd7;
  cmnd6_struct cmnd6;
  cmnd_crc1_struct cmnd_crc1;
  cmnd_crc2_struct cmnd_crc2;
  cmnd_crc3_struct cmnd_crc3;
  sts0_iocb_struct status0;
  tm_iocb_struct tskmgt;
  marker_struct marker;
  ctio7_struct ctio7;
  ctio_crc1_struct ctio_crc1;
  ctio_crc2_struct ctio_crc2;
  ctio_crc3_struct ctio_crc3;
  ctio_crc4_struct ctio_crc4;
 };
} fc_iocb_struct;


typedef struct atio_s {
 union {
  struct {
   unsigned char iocb_type;
   unsigned char iocb_count;
  };
  unsigned short iocb_cnt_typ;
 };
 unsigned short atio_cmnd_len:12,
   atio_attr:4;
 mim_adr_struct rcv_xchg_adr;
 unsigned long atio_frame_hdr[6];
 unsigned long atio_payload[8];
} atio_struct;
enum { fciocb_assert_line_649 = (!(sizeof(atio_struct) != (64/4))) };



typedef struct fc_fw_def_s {
 union {
  unsigned long tbd_scratch[16];
  struct {
   mim_adr_struct t10_crc_cntxt;
   unsigned long rsvd[15];
  };

 };



} fc_fw_def_struct;
enum { fciocb_assert_line_666 = (!(sizeof(fc_fw_def_struct) != 64)) };


typedef struct disk_crc_ctxt_s {
 unsigned long io_handle;
 unsigned long ref_tag;
 unsigned short app_tag;
 unsigned short ref_mask_l;

 unsigned short ref_mask_h;
 unsigned short app_mask;

 unsigned short guard_seed;
 unsigned short prot_opts;

 unsigned short block_sz;
 unsigned short runt_guard;

 union {
  struct {
   unsigned long ndb_tot_pxc;
   unsigned long rsvd_0;
   unsigned long rsvd_1;
   unsigned long rsvd_2;
   dseg_struct data_dsd;
   unsigned long rsvd_3[3];
  } non_db;
  struct {
   unsigned long db_data_pxc;
   unsigned long db_dif_pxc;
   unsigned short rsvd_1;
   unsigned short blk_dsd_cnt;
   unsigned long rsvd_2;
   dseg_struct data_dsd;
   dseg_struct dif_dsd;
  } db;
 };
} dcrc_ctxt_struct;
# 6 "./include/ql_drp.h" 2
# 50 "./include/ql_drp.h"
#pragma pack(push,4)

typedef struct {
 union {
  unsigned long gen_iocb[16];
  fc_iocb_struct fc_iocb;


 };
 union {
  unsigned long gen_def[16];
  fc_fw_def_struct fc_fw_def;

 };


 union {

  struct {
   alcb_struct lo_alcb;
   alcb_struct hi_alcb;
   unsigned long hdr_digest;
   unsigned long data_digest;
   mim_adr_struct t10_ctx;
   union {
    dseg_struct dsd[4];
    skp_msk_dsd_struct sm_dsd[2];
    unsigned long fill[12];
   };
   mim_adr_struct nxt_crp_adr;
  };
  unsigned long misc_data[32];
  unsigned char scratch[128];
 };
} drp_struct;
#pragma pack(pop)

enum { fciocb_assert_line_87 = (!(sizeof(drp_struct) != (256/4))) };




#pragma pack(push,4)
typedef struct {
 unsigned long vld_flags_9To0;
 dseg_struct dsd_list_0[10];
 unsigned long rsvd1;
 unsigned long vld_flags_19to10;
 dseg_struct dsd_list_1[10];
 mim_adr_struct nxt_crp_ptr;
} crp_struct;
#pragma pack(pop)

enum { fciocb_assert_line_103 = (!(sizeof(crp_struct) != (256/4))) };
# 7 "sp.h" 2


typedef enum _dmaType {
 DMA_TYPE_MIM,
 DMA_TYPE_MQS,
 DMA_TYPE_DSD,
 DMA_TYPE_CRC_CNTXT,
 DMA_TYPE_SWQE,
 DMA_TYPE_ROCE_CONTEXT
} dmaType;

typedef enum _protType {
 PROT_HQP,
 PROT_ROCE
} protType;
# 92 "sp.h"
struct _dmaQue;
struct _hqpCb;



typedef struct _dmaCB {
 struct _dmaCB *next;

 dmaType type;
 protType protocol;
 unsigned long hqpId;
 unsigned long hdwReg;
 unsigned long adrh;
 unsigned long adrl;
 unsigned long region;
 unsigned long length;
 void * spBufAdr;
 unsigned long result;
}dmaCb;





typedef struct _dmaQue {
 dmaCb *head;
 dmaCb *tail;
}dmaQue;





typedef struct _Qobj {
 struct _Qobj *next;
}Qobj;





typedef struct _Que {
 Qobj *head;
 Qobj *tail;
}Que;





typedef enum _hqpState {
 HQP_STATE_INACTIVE,
 HQP_STATE_SLOW_PATH_REQ,
 HQP_STATE_WAIT_HQP_CNTXT_DMA,
 HQP_STATE_WAIT_DRPCRP_DESC,
 HQP_STATE_WAIT_DMACB,
 HQP_STATE_WAIT_SQ_CNTXT_DMA,
 HQP_STATE_WAIT_IOCB_BLK,
 HQP_STATE_WAIT_FOR_DSD_DMA,
 HQP_STATE_WAIT_FOR_DSD_LPTR_DMA,
 HQP_STATE_WAIT_FOR_MIM_BLK_ALLOC,
 HQP_STATE_WAIT_FOR_MIM_DMA,
 HQP_STATE_WAIT_FOR_MQS_DMA,
 HQP_STATE_WAIT_FOR_CRC_CNTXT_DMA,
 HQP_STATE_WAIT_FOR_CRC_DIF_DMA,
 HQP_STATE_WAIT_FOR_DIF_LPTR_DMA,
 HQP_STATE_PROC_IOCB
}hqpState;





struct _bufDesc;






struct _hqpCb {
 struct _hqpCb *next;

 struct _bufDesc *pIocbBlkChain;
 dmaCb *pDmaCb;
 struct _bufDesc *pDrp;
 struct _bufDesc *pCrp;
 struct _bufDesc *pT10Cntxt;
 fc_iocb_struct *pCurIocb;
 void *pBuf;

 hqpState state;
 unsigned long numIocbProcessed;


 unsigned short dsdIndxInBuf;

 unsigned char dsdIndxInDrpCrp;
 unsigned char iocbIndx;
 unsigned short flags;
 unsigned char rsvd;
 unsigned char iocbCount;
 unsigned short dsdCount;
}__attribute__ ((packed));

typedef struct _hqpCb hqpCb;
# 229 "sp.h"
typedef struct _hqpQue {
 hqpCb *head;
 hqpCb *tail;
} hqpQue;






struct _hqpCntxtEntry {
 union {
  unsigned long hqpCntxtW1;
  struct {
 unsigned long vpid:10,
    port:2,
    type:4,
    iocbRegion:6,
    cntxtRegion:6,
    cntxtSize:3,
    valid:1;
  };
 };
 unsigned short mqsL1q;
} __attribute__ ((packed));


typedef struct _hqpCntxtEntry hqpCntxtEntry;
# 278 "sp.h"
struct _hqmHqpCntxt {


 union {
  unsigned long hqpCntxtRq0;
  struct {
   unsigned long vpid:10,
     rq0rsvd0:2,
     dici:1,
     port:2,
     rq0rsvd:1,
     duci:1,
     rq0rsvd2:1,
     type:4,
     iocbRegion:6,
     state:4;
  };
 };
 union {
  unsigned long hqpCntxtRq1;
  struct {
   unsigned long mqsL1Que:16,
     cntxtRegion:6,
     cntxtSize:3,
     rq1rsvd0:7;
  };
 };
 unsigned short hqpCntxtRqConsIndxBits;
 unsigned short hqpCntxtRqBaseAddrBits;
 unsigned long hqpCntxtRqConsIndxAdrl;
 unsigned long hqpCntxtRqConsIndxAdrh;
 unsigned long hqpCntxtRqBaseAdrl;
 unsigned long hqpCntxtRqBaseAdrh;
 union {
  unsigned long hqpCntxtRq7;
  struct {
   unsigned long rqQueLength:16,
    rqes:3,
    hostPageSize:3,
    rmc:2,
    rq7rsvd0:8;
  };
 };


 unsigned long hqpCntxtRp00;
 unsigned long hqpCntxtRp01;
 unsigned short hqpCntxtRp0ConsIndxBits;
 unsigned short hqpCntxtRp0BaseAddrBits;
 unsigned long hqpCntxtRp0ConsIndxAdrl;
 unsigned long hqpCntxtRp0ConsIndxAdrh;
 unsigned long hqpCntxtRp0BaseAdrl;
 unsigned long hqpCntxtRp0BaseAdrh;
 union {
  unsigned long hqpCntxtRp07;
  struct {
   unsigned long rp0QueLength:16,
    rpe0:3,
    rp0hostPageSize:3,
    rp0rmc:2,
    rp0rsvd1:8;
  };
 };


 unsigned long hqpCntxtRp10;
 unsigned long hqpCntxtRp11;
 unsigned short hqpCntxtRp1ConsIndxBits;
 unsigned short hqpCntxtRp1BaseAddrBits;
 unsigned long hqpCntxtRp1ConsIndxAdrl;
 unsigned long hqpCntxtRp1ConsIndxAdrh;
 unsigned long hqpCntxtRp1BaseAdrl;
 unsigned long hqpCntxtRp1BaseAdrh;
 union {
  unsigned long hqpCntxtRp17;
  struct {
   unsigned long rp1QueLength:16,
    rpe1:3,
    rp1hostPageSize:3,
    rp1rmc:2,
    rp1rsvd1:8;
  };
 };

 unsigned long anonBuf[8];

}__attribute__ ((packed)) ;

typedef struct _hqmHqpCntxt hqmHqpCntxt;
# 376 "sp.h"
struct _sqCntxtEntry {
 unsigned long queAdrl;
 unsigned long queAdrh;
 unsigned short queLength;
 unsigned short hqpid;
 union {
  unsigned long sqCntxt3;
  struct {
   unsigned long en:1,
     sw:1,
     rsvd1:1,
     rmc:2,
     qes:3,
     swqeRegion:6,
     rsvd2:2,
     nxtSeqNum:4,
     hostPageSize:3,
     rsvd3:9;
  };
 };
 unsigned short consIdx;
 unsigned short rsvd4;
 unsigned long rsvd5;
 unsigned short mqsL1q;
 unsigned short cntxtRegion;
 unsigned long pcieBits;

 struct _sqCntxtEntry *next;

} __attribute__ ((packed));


typedef struct _sqCntxtEntry sqCntxtEntry;
# 424 "sp.h"
typedef enum {
 HASH_FREE,
 HASH_ASSIGNED,
 HASH_DELETED,
 HASH_RO

} T_HASH_SLOT_STATE;







typedef struct _hashEntry {
 unsigned long state:2,
      key:18,
      rsvd:12;
 sqCntxtEntry *cntxtAdr;
}hashEntry;






typedef struct _drp_crp {
 union {
  crp_struct crp;
  drp_struct drp;
 };
} drp_crp;
# 475 "sp.h"
typedef struct _bufDesc {
 unsigned long pad_for_mqs;
 union {
  drp_crp lbuf;
  fc_iocb_struct iocb[4];
 };
 unsigned long pad_for_dma[2];
 struct _bufDesc *next;
 mim_adr_struct mbuf;
 unsigned long hqpId;
}bufDesc;





typedef struct _drpCrpQue {
 bufDesc *head;
 bufDesc *tail;
} drpCrpQue;





typedef struct _bufQue {
 bufDesc *head;
 bufDesc *tail;
} bufQue;



typedef struct _opcodeFormatRamEntry {
 union {
  unsigned long long OpcodeFormat;
  struct {
   unsigned long long
    lengthInIocb :2,
    numDsds :2,
    createAlcbs :1,
    routeToSP :1,
    ctrlFlagsPsn :2,
    ctrlFlagsMsk :16,
    prefetchIocb :1,
    prefetchContext :1,
    conxIdPsn :2,



    conxIdPrefix :4,
    iocbCountFmt :2,


    ecc :7,
    rsvd :23;
  };
 };
} opcodeFormatRamEntry;
# 576 "sp.h"
typedef struct _mqsLink {
 unsigned long link[4];
}mqsLink;
# 635 "sp.h"
typedef struct _mqsMessage {
 mqsLink link;
 unsigned long iocb[32];
}mqsMessage;
# 690 "sp.h"
void mainLoop(void);



int enqueDmaCb(dmaCb *pDmaCb, dmaQue *pDmaQue);
dmaCb *dequeAndUpdateDmaCbStatus(dmaQue *pDmaQue);
dmaCb *dequeDmaCb(dmaQue *pDmaQue);
int dmaQueIsEmpty(dmaQue *pDmaQue);
int fpFifoIsEmpty(void);
int fpFifoIsFull(void);
int enqueFpFifo(unsigned long adr);
int abFifoIsEmpty(void);
int abFifoIsFull(void);
int dequeAbFifo(unsigned long *pHqpId, bufDesc **pBufAdr);
int enqueHqpCb(hqpCb *pHqpCb, hqpQue *pHqpQue);
hqpCb *dequeHqpCb(hqpQue *pHqpQue);
int hqpQueIsEmpty(hqpQue *pHqpQue);
void getIocbStateString(hqpState state, char *buf);
void getIocbStateString(hqpState state, char *buf);

void *top(void *que);
void ProcessSlowPathRequest(int hqpId);
void getHqpContext(int hqpId);
bufDesc * allocDrpCrp(int hqpId);
int processIocb(int hqpId);
int ProcessDsdList(int hqpId, int dsdListPointer);
void ReleaseHqpResources(int hqpId);




sqCntxtEntry *sqHashGet(hashEntry *table, unsigned long key);
unsigned long sqHashAdd(hashEntry *table, unsigned long key, sqCntxtEntry *value);
unsigned long sqHashDelete(hashEntry *table, unsigned long key);
unsigned long sqHashKey(unsigned long key, unsigned long indx);

void *dmalloc(unsigned long length);
void dfree(void *);
# 8 "main.c" 2
# 1 "sp_hardware.h" 1
# 24 "sp_hardware.h"
typedef struct _sp_regs {
 unsigned long hqmDebugReg;
 unsigned long hqmIoRingReg;
 unsigned long hqmLoadRamAdrReg;
 unsigned long hqmLoadRamDataReg;
 unsigned long hqmIpcMsgDataReg;
 unsigned long hqmIpcMsgCmdReg;
 unsigned long hqmSemaphoreReg;

 unsigned long hqmHqpConfigReg;






 unsigned long hqmHqpStatusReg;
# 68 "sp_hardware.h"
 unsigned long FreePoolFifoReg;
# 78 "sp_hardware.h"
 unsigned long hqpIocbFetchReg;
# 93 "sp_hardware.h"
 unsigned long iocbDmaCmdReg;
# 113 "sp_hardware.h"
 unsigned long iocbDmaSpAdrReg;


 unsigned long iocbDmaAdrlReg;
 unsigned long iocbDmaAdrhReg;

 unsigned long iocbDmaHqpIdReg;
# 130 "sp_hardware.h"
 unsigned long mimBlkRqReg;
# 147 "sp_hardware.h"
 unsigned long mimDma0CmdReg;
# 158 "sp_hardware.h"
 unsigned long mimDma0AdrReg;





 unsigned long mimDma0BlkOffsetReg;


 unsigned long mimDma0SpAdrReg;






 unsigned long mqsDma0CmdReg;
# 183 "sp_hardware.h"
 unsigned long hqpCntxtCmdReg;




 unsigned long hqpCntxtSpAdrReg;






 unsigned long hqpCmdCmpltReg;





 unsigned long hqmNumIocbPerBlockReg;






 unsigned long sqStatusReg;







 unsigned long sqCntxtCmdReg;




 unsigned long sqCntxtSpAdrReg;






 unsigned long sqCntxtUpCmdReg;




 unsigned long sqCntxtUpDataReg;







 unsigned long hostDmaCmdReg;
# 261 "sp_hardware.h"
 unsigned long hostDmaSpAdrReg;


 unsigned long hostDmaAdrlReg;
 unsigned long hostDmaAdrhReg;

 unsigned long hostDmaHqpIdReg;
# 280 "sp_hardware.h"
 unsigned long mimDma1CmdReg;
 unsigned long mimDma1AdrReg;
 unsigned long mimDma1BlkOffsetReg;
 unsigned long mimDma1SpAdrReg;







 unsigned long mqsDma1CmdReg;




 unsigned long conxIdIncCountReg;



 unsigned long mqsTieCnxReg;
 unsigned long mqsTiePrf0Reg;
 unsigned long mqsTiePrf1Reg;
 unsigned long mqsTieL1qReg;

} sp_regs;
# 534 "sp_hardware.h"
extern sp_regs spRegs __attribute__ ((section(".hdwregs")));
# 9 "main.c" 2

# 1 "simhdw.h" 1
# 31 "simhdw.h"
struct _FCP_CDB {
 unsigned char cdb[16];
};



typedef struct _scsiBlk {
 unsigned char buf[16];
} scsiBlk;
# 51 "simhdw.h"
typedef struct _timer {
 unsigned long tick[100];
 unsigned long *pNxtTick;
} timer;
# 63 "simhdw.h"
void fpHdwSimFifoInit(void);
int fpHdwSimFifoIsFull(void);
int fpHdwSimFifoIsEmpty(void);
void enqueueFpHdwSimFifo(void);
unsigned long dequeueFpHdwSimFifo(void);
void abHdwSimFifoInit(void);
int abHdwSimFifoIsFull(void);
int enqueueAbHdwSimFifo(unsigned long val);
void dequeueAbHdwSimFifo(void);


int SlowPathIocb_Ct6DsdList(void);
int SlowPathIocb_Ct7Ct1(void);
int SlowPathIocb_CtCRC_2DsdList(void);

void mlmHdwSim(void);
void initMim(void);
opcodeFormatRamEntry ReadOpcodeFormatRam( int opcode, int protocol);
void hqmFetchHdwSim(void);
void hqmCmdCmpltHdwSim(void);
void hqmMimDma0HdwSim(void);
void hqmMimClr0HdwSim(void);
void hqmMqsDma0HdwSim(void);
void hqpContextDmaHdwSim(void);
void initContext(void);
void initOpcodeFormatRam(void);
void initHdwRegs(void);
void mqsCnxIdIncHdwSim(void);

void DipslayAllocatedDrpCrpBlockList(void);
void DisplayDrpCrpChain (hqpCb *pHqpCb);
void DisplayMqsMessage(mqsMessage *pMsg);
unsigned long calcTimerTime(timer *t);
# 11 "main.c" 2

# 1 "./include/fc_iocb.h" 1
# 13 "main.c" 2

# 1 "./include/ql_xmngr.h" 1
# 284 "./include/ql_xmngr.h"
typedef struct scsi_tag_s {



    unsigned short tx_frm_sz;
    unsigned short rsvd1;
    unsigned long tx_flags;
    unsigned long exp_tx_ro;
    unsigned long rem_tx_cnt;

    union {
        unsigned long exp_tx_seqid_cnt;
        struct {
            unsigned short tx_seq_cnt;
            unsigned char tx_dfctl;
            unsigned char tx_seq_id;
        };
    };


    unsigned long rx_flags;
    unsigned long exp_rx_ro;
    unsigned long rem_rx_cnt;

    union {
        unsigned long exp_rx_seqid_cnt;
        struct {
            unsigned short rx_seq_cnt;
            unsigned char rx_dfctl;
            unsigned char rx_seq_id;
        };
    };



    unsigned long task_retry_id;
    unsigned long fill[13];

} x_scsi_struct;






typedef struct xcb_s {

    unsigned long port:3,
            flags:29;

    unsigned long iocb_handle;
    unsigned short hpq_id;
    unsigned short ctl_flags;
    unsigned short x_state;
    unsigned char x_event;
    unsigned char x_owner;
    unsigned short othr_xid;
    unsigned short my_xid;
    mim_adr_struct pcb_adr;
    mim_adr_struct drp_adr;
    mim_adr_struct x_link_adr;
    mim_adr_struct x_cont_link_adr;

    union {
        x_scsi_struct scsi_own;
        unsigned long misc_data[16];
    };

} xcb_struct;
# 15 "main.c" 2
# 61 "main.c"
unsigned long simIocbComplete = 1;
unsigned long passCount = 0;


volatile register unsigned long *rMb ;
unsigned long shdMb0;
# 91 "main.c"
dmaQue iocbDma;
dmaQue hostDma;
dmaQue mimDma;
dmaQue mqsDma;
dmaQue hqpCtxDma;
dmaQue swqeDma;
dmaQue roceCtxDma;
# 106 "main.c"
dmaQue fwDsdQue;
dmaQue fwSwqeQue;
dmaQue fwCntxt;
dmaQue fwMimQue;




bufQue iocbBlkWaitQ;
hqpQue hqpRdyQ;
hqpQue genWaitQ;
# 131 "main.c"
bufDesc iocbBuf[4] __attribute__ ((section(".off_data"),aligned(4))) ;




bufDesc drpCrpArray[8] __attribute__ ((section(".off_data"),aligned(4)));




hqpCb *HqpLookup[(1<<11)] __attribute__ ((section(".off_data"),aligned(4)));




sqCntxtEntry sqCntxt[(64)] ;
# 162 "main.c"
dmaCb dmaCbArray[(4)];
hqpCb hqpCbArray[4 ];

hqpCntxtEntry hqpCntxt[(1<<11)];
sqCntxtEntry* sqHash[(64)];






bufQue drpCrpFreePool;

hqpQue drpCrpWaitQ;

unsigned long actNumIocbBlks;



hqpQue dmaCbWaitQ;


hqpQue hqpCbFreePool;



int main(void) {

int i;

dmaCb *pDmaCb = dmaCbArray;

bufDesc *pIocbBuf = iocbBuf;

bufDesc *pDrpCrpDesc = drpCrpArray;
bufQue *pDrpCrpFreePool = &drpCrpFreePool;

hqpCb *pHqpCb = hqpCbArray;
hqpQue *pHqpCbFreePool = &hqpCbFreePool;





 rMb = (unsigned long *)0x7020;





shdMb0 = 0x0001;
*rMb = shdMb0;




 iocbDma.head = 0;
 iocbDma.tail = 0;
 hostDma.head = 0;
 hostDma.tail = 0;
 mimDma.head = 0;
 mimDma.tail = 0;
 mqsDma.head = 0;
 mqsDma.tail = 0;
 hqpCtxDma.head = 0;
 hqpCtxDma.tail = 0;
 swqeDma.head = 0;
 swqeDma.tail = 0;




 fwDsdQue.head = 0;
 fwDsdQue.tail = 0;
 fwSwqeQue.head = 0;
 fwSwqeQue.tail = 0;
 fwCntxt.head = 0;
 fwCntxt.tail = 0;
 fwMimQue.head = 0;
 fwMimQue.tail = 0;




 iocbBlkWaitQ.head = 0;
 iocbBlkWaitQ.tail = 0;

 drpCrpWaitQ.head = 0;
 drpCrpWaitQ.tail = 0;

 hqpRdyQ.head = 0;
 hqpRdyQ.tail = 0;




 drpCrpFreePool.head = 0;
 drpCrpFreePool.tail = 0;




 hqpCbFreePool.head = 0;
 hqpCbFreePool.tail = 0;





 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqmHqpStatusReg)))) = 0);
 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->FreePoolFifoReg)))) = (1<<31));
# 292 "main.c"
 unsigned long dummyHqpId;
 bufDesc *dummyBufAdr;

unsigned long loopCount = 256;

 while (dequeAbFifo(&dummyHqpId,&dummyBufAdr)) {



  if (--loopCount) {
   exit(1);
  }
 }
# 314 "main.c"
 for (i=0; i<4; i++) {

  if ( !enqueFpFifo((unsigned long)pIocbBuf) ) {
   break;
  } else {
   pIocbBuf++;
  }
 }

 actNumIocbBlks = i;






 if (actNumIocbBlks < 4) {
;
;
 }
# 346 "main.c"
 for (i=0; i<8; i++) {
  enque(pDrpCrpDesc++,pDrpCrpFreePool);
 }
# 358 "main.c"
 for (i=0; i<4; i++) {
  pHqpCb->pDmaCb = pDmaCb++;
  enque(pHqpCb++,pHqpCbFreePool);
 }






 for (i=0; i< (1<<11); i++) {
  HqpLookup[i]= 0;
 }







 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqmNumIocbPerBlockReg)))) = 4);






 initHdwRegs();
 initMim();
 initOpcodeFormatRam();
 initContext();

shdMb0 &= ~0x0001;
*rMb = shdMb0;

 mainLoop();

 return 0;
}
# 405 "main.c"
void mainLoop(void) {

unsigned long hqmStatusReg;





shdMb0 = 0x0002;
*rMb = shdMb0;




 while (passCount < 2) {
# 442 "main.c"
  if (!queIsEmpty(&hostDma)) {
   unsigned long treg;
   dmaCb *pDmaCb;
   dmaCb *pNextDmaCb;



   treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));
   if (treg & (1 << 31)) {

    pDmaCb = (dmaCb *)deque(&hostDma);
    pDmaCb->result = treg;




    if (!queIsEmpty(&hostDma)) {

     pNextDmaCb = (dmaCb *)top(&hostDma);


     (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaSpAdrReg)))) = (((unsigned long)pNextDmaCb->spBufAdr) & (0x00007FFF)));
     (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrlReg)))) = pNextDmaCb->adrl);
     (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrhReg)))) = pNextDmaCb->adrl);
     (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaHqpIdReg)))) = pNextDmaCb->hqpId);
     treg = (0<<14) + pNextDmaCb->length;

     (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))) = treg);







     hostDmaHdwSim();






  }



    ProcessSlowPathRequest(pDmaCb->hqpId);
   }
  }
# 515 "main.c"
  if (!queIsEmpty(&drpCrpWaitQ)) {
   if (!queIsEmpty(&drpCrpFreePool)) {
    hqpCb *pHqpCb = (hqpCb *)deque(&drpCrpWaitQ);
    unsigned long hqpId = pHqpCb->pIocbBlkChain->hqpId & (0x7FF);
    if (allocDrpCrp(hqpId)) {
     pHqpCb->state = HQP_STATE_PROC_IOCB;
     processIocb(hqpId);
    } else {


    }
   }
  }




  if (!queIsEmpty(&iocbBlkWaitQ)) {
   if (!queIsEmpty(&hqpCbFreePool)) {
    hqpCb *pHqpCb = (hqpCb *)deque(&hqpCbFreePool);
    memset(pHqpCb,0,sizeof(hqpCb));
    pHqpCb->pIocbBlkChain = (bufDesc *)deque(&iocbBlkWaitQ);
    unsigned long hqpId = pHqpCb->pIocbBlkChain->hqpId & (0x7FF);
    if (HqpLookup[hqpId]) {
     ;
     ;


     enque(pHqpCb->pIocbBlkChain, &iocbBlkWaitQ);
     enque(pHqpCb,&hqpCbFreePool);

    } else {




     pHqpCb->state = HQP_STATE_SLOW_PATH_REQ;
     pHqpCb->pIocbBlkChain->next = 0;
     HqpLookup[hqpId] = pHqpCb;
     ProcessSlowPathRequest(hqpId);
    }
   }
  }
# 578 "main.c"
  unsigned long hqpId;
  unsigned long rawAbFifoData;
  hqpCb *pHqpCb;
  bufDesc *buf;

  while (dequeAbFifo(&rawAbFifoData, &buf)) {

   bufDesc *curBlk;
   hqpId = rawAbFifoData & (0x7FF);
   buf->hqpId = rawAbFifoData;



   pHqpCb = HqpLookup[hqpId];




   if (!pHqpCb) {
    if (!queIsEmpty(&hqpCbFreePool)) {
     pHqpCb = (hqpCb *)deque(&hqpCbFreePool);
     HqpLookup[hqpId] = pHqpCb;

     pHqpCb->pIocbBlkChain = buf;
     pHqpCb->pCurIocb = pHqpCb->pIocbBlkChain->iocb;
     pHqpCb->state = HQP_STATE_SLOW_PATH_REQ;
     pHqpCb->pIocbBlkChain->next = 0;
     pHqpCb->pDrp = buf;
     buf->mbuf = buf->lbuf.drp.nxt_crp_adr;
     buf->lbuf.drp.nxt_crp_adr.full_adr = 0;
     ProcessSlowPathRequest(hqpId);
     break;
    } else {



     enque(buf, &iocbBlkWaitQ);
     continue;
    }
   }




   if (pHqpCb->pIocbBlkChain) {
    curBlk = pHqpCb->pIocbBlkChain->next;
    while (curBlk->next) {
     curBlk = curBlk->next;
    }
    curBlk->next = buf;
   } else {
    pHqpCb->pIocbBlkChain = buf;
    pHqpCb->iocbIndx = 0;
   }
   buf->next = 0;



   if (pHqpCb->state == HQP_STATE_WAIT_IOCB_BLK) {
    ProcessSlowPathRequest(hqpId);
   }
  }
# 650 "main.c"
  if (simIocbComplete) {

   SlowPathIocb_Ct6DsdList();







   passCount++;
  }



 }

shdMb0 &= ~0x0002;
*rMb = shdMb0;
}
# 708 "main.c"
void ProcessSlowPathRequest(int hqpId) {

unsigned long treg;
hqpCb *pHqpCb = HqpLookup[hqpId];
bufDesc *pDrpCrp;
# 721 "main.c"
 if (!hqpCntxt[hqpId].valid) {







  getHqpContext(hqpId);
 }





  if (pHqpCb->state == HQP_STATE_SLOW_PATH_REQ ) {



simIocbComplete = 0;
shdMb0 |= 0x0004;
*rMb = shdMb0;



  pHqpCb->iocbIndx = 0;
  pHqpCb->state = HQP_STATE_PROC_IOCB;
  pHqpCb->iocbCount = pHqpCb->pCurIocb->hdr.iocb_count;
  pHqpCb->numIocbProcessed = 0;
  }



 while(1) {



  if (!processIocb(hqpId)) {
   return;
  }
  pHqpCb->numIocbProcessed += 1;
  pHqpCb->iocbIndx++;
  pHqpCb->iocbCount--;
# 789 "main.c"
  if (pHqpCb->iocbCount) {
# 800 "main.c"
   if (pHqpCb->iocbIndx == ((pHqpCb->pIocbBlkChain->hqpId & (0x07 << 13)) >> 13) ) {
    if (pHqpCb->pIocbBlkChain->next) {
     bufDesc *pCurIocbBlk = pHqpCb->pIocbBlkChain;



     pHqpCb->iocbIndx = 0;



     pHqpCb->pIocbBlkChain = pHqpCb->pIocbBlkChain->next;
     pHqpCb->pCurIocb = pHqpCb->pIocbBlkChain->iocb;



     if ( pCurIocbBlk->hqpId & (0x03 << 11)) {
      enqueFpFifo((unsigned long)pCurIocbBlk);
     }

    } else {



     if ( pHqpCb->pIocbBlkChain->hqpId & (0x03 << 11)) {
      enqueFpFifo((unsigned long)(pHqpCb->pIocbBlkChain));
     }




     pHqpCb->state = HQP_STATE_WAIT_IOCB_BLK;
     pHqpCb->pIocbBlkChain = 0;




     int count = pHqpCb->iocbCount;
     if (pHqpCb->iocbCount > 4) {
      count = 4;
     }
     treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpIocbFetchReg)))));

     while ( !(treg & (1<<31)) ) {
      treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpIocbFetchReg)))));
     }
     treg = (count << 16) + hqpId;
     (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpIocbFetchReg)))) = treg);

*rMb = shdMb0 | 0x0008;
    hqmFetchHdwSim();
*rMb = shdMb0;

    return;

    }
   } else {



    pHqpCb->pCurIocb = &pHqpCb->pIocbBlkChain->iocb[pHqpCb->iocbIndx];
   }

  } else {
   break;
  }
  }

  opcodeFormatRamEntry opcodeFmt;
  int protocol = hqpCntxt[hqpId].type - 1;


  opcodeFmt = ReadOpcodeFormatRam(pHqpCb->pDrp->lbuf.drp.gen_iocb[0] & 0xFF, protocol);







  if (pHqpCb->pT10Cntxt) {
  bufDesc *pDrpCrpDesc = pHqpCb->pT10Cntxt;
  bufDesc *pCurDrpCrpDesc;



   pHqpCb->pDrp->lbuf.drp.gen_def[0] = pHqpCb->pT10Cntxt->mbuf.full_adr | 0x80000000;




   if (opcodeFmt.createAlcbs) {




    pDrpCrpDesc->lbuf.drp.misc_data[0] = pDrpCrpDesc->mbuf.full_adr | 0x80000000;
    pDrpCrpDesc->lbuf.drp.misc_data[1] = 1;
    pDrpCrpDesc->lbuf.drp.misc_data[2] = pDrpCrpDesc->lbuf.drp.dsd[0].addr_lo;
    pDrpCrpDesc->lbuf.drp.misc_data[3] = pDrpCrpDesc->lbuf.drp.dsd[0].addr_hi;
    pDrpCrpDesc->lbuf.drp.misc_data[4] = pDrpCrpDesc->lbuf.drp.dsd[0].length;
    pDrpCrpDesc->lbuf.drp.misc_data[5] = pDrpCrpDesc->lbuf.drp.gen_iocb[3];
   }
# 912 "main.c"
   while (pDrpCrpDesc) {

    treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0CmdReg)))));

    while ( !(treg & (1<<31)) ) {
     treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0CmdReg)))));
    }

    (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0AdrReg)))) = pDrpCrpDesc->mbuf.blk_id);
    (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0BlkOffsetReg)))) = 0);
    (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0SpAdrReg)))) = (((unsigned long)&pDrpCrpDesc->lbuf) & (0x00007FFF)));
    treg = (pDrpCrpDesc->mbuf.mem_rgn << 16) | (0<<15) | sizeof(drp_crp);

    (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0CmdReg)))) = treg);


*rMb = shdMb0 | 0x0008;
   hqmMimDma0HdwSim();
*rMb = shdMb0;

   pCurDrpCrpDesc = pDrpCrpDesc;
    pDrpCrpDesc = pDrpCrpDesc->next;
   enque(pCurDrpCrpDesc,&drpCrpFreePool);
   }
  }




 bufDesc *pDrpCrpDesc = pHqpCb->pDrp;





  if (opcodeFmt.createAlcbs) {





   pDrpCrpDesc->lbuf.drp.misc_data[0] = pDrpCrpDesc->mbuf.full_adr | 0x80000000;
   pDrpCrpDesc->lbuf.drp.misc_data[1] = 1;
   pDrpCrpDesc->lbuf.drp.misc_data[2] = pDrpCrpDesc->lbuf.drp.dsd[0].addr_lo;
   pDrpCrpDesc->lbuf.drp.misc_data[3] = pDrpCrpDesc->lbuf.drp.dsd[0].addr_hi;
   pDrpCrpDesc->lbuf.drp.misc_data[4] = pDrpCrpDesc->lbuf.drp.dsd[0].length;
   pDrpCrpDesc->lbuf.drp.misc_data[5] = pDrpCrpDesc->lbuf.drp.gen_iocb[3];
  }





 treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0CmdReg)))));

 while ( !(treg & (1<<31)) ) {
  treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0CmdReg)))));
 }

 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0AdrReg)))) = pDrpCrpDesc->mbuf.blk_id);
 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0BlkOffsetReg)))) = 0);
 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0SpAdrReg)))) = (((unsigned long)&pDrpCrpDesc->lbuf) & (0x00007FFF)));
 treg = (pDrpCrpDesc->mbuf.mem_rgn << 16) | (0<<15) | sizeof(drp_crp);

 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0CmdReg)))) = treg);

*rMb = shdMb0 | 0x0008;
  hqmMimDma0HdwSim();
*rMb = shdMb0;


 pDrpCrpDesc = pDrpCrpDesc->next;
 bufDesc *pCurDrpCrpDesc;






  while (pDrpCrpDesc) {

   treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0CmdReg)))));

   while ( !(treg & (1<<31)) ) {
    treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0CmdReg)))));
   }

   (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0AdrReg)))) = pDrpCrpDesc->mbuf.blk_id);
   (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0BlkOffsetReg)))) = 0);
   (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0SpAdrReg)))) = (((unsigned long)&pDrpCrpDesc->lbuf) & (0x00007FFF)));
   treg = (pDrpCrpDesc->mbuf.mem_rgn << 16) | (0<<15) | sizeof(drp_crp);
   (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimDma0CmdReg)))) = treg);

*rMb = shdMb0 | 0x0008;
  hqmMimDma0HdwSim();
*rMb = shdMb0;

  pCurDrpCrpDesc = pDrpCrpDesc;
   pDrpCrpDesc = pDrpCrpDesc->next;
  enque(pCurDrpCrpDesc,&drpCrpFreePool);
  }






shdMb0 |= 0x0010;
*rMb = shdMb0;
# 1034 "main.c"
 unsigned long *pMqsIocb = (unsigned long *)pHqpCb->pDrp;
  pMqsIocb[31] = pHqpCb->pDrp->mbuf.full_adr | (1<<31);
  pMqsIocb[0] = (hqpCntxt[hqpId].type) | (hqpCntxt[hqpId].port << 4) | (hqpId << 7);
# 1045 "main.c"
  unsigned long conxId = opcodeFmt.conxIdPrefix<<24;

  switch (opcodeFmt.conxIdPsn) {

   case 0x0:



    treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->conxIdIncCountReg)))));
    while (!(treg & (0x1<<31))) {
     treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->conxIdIncCountReg)))));
    }

    (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->conxIdIncCountReg)))) = 0);

*rMb = shdMb0 | 0x0008;
    mqsCnxIdIncHdwSim();
*rMb = ~shdMb0;

    treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->conxIdIncCountReg)))));
    while (!(treg & (0x1<<31))) {
     treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->conxIdIncCountReg)))));
    }
    conxId += (treg & 0x00FFFFFF);

    break;

   case 0x01:
    conxId += hqpCntxt[hqpId].vpid;
    break;

   case 0x02:
    conxId += pMqsIocb[3] & 0x0000FFFF;
    break;

   case 0x03:
    conxId += pMqsIocb[3] & 0x00FFFFFF;
    break;
  }

  (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mqsTieCnxReg)))) = conxId);




  switch (hqpCntxt[hqpId].type-1) {

   case (0x01 -1): {



    unsigned long temp = (pMqsIocb[3] & 0x0000FFFF) + ( hqpCntxt[hqpId].hqpCntxtW1 & 0x0FFF0000);



    (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mqsTiePrf0Reg)))) = temp);



    (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mqsTiePrf0Reg)))) = 0);
    break;
   }
   case (0x02 -1):

    break;

   case (0x03 -1):

    break;

   case (0x04 -1):

    break;

  }



  (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mqsTieL1qReg)))) = hqpCntxt[hqpId].mqsL1q);


shdMb0 &= ~0x0010;
*rMb = shdMb0;




  treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mqsDma0CmdReg)))));

  while ( !(treg & (1<<31)) ) {
   treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mqsDma0CmdReg)))));
  }

  (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mqsDma0CmdReg)))) = (unsigned long)pMqsIocb);


*rMb = shdMb0 | 0x0008;
  hqmMqsDma0HdwSim();
*rMb = shdMb0;
# 1152 "main.c"
  treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mqsDma0CmdReg)))));

  while ( !(treg & (1<<31)) ) {
   treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mqsDma0CmdReg)))));
  }





 treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpCmdCmpltReg)))));

 while ( !(treg & (1<<31)) ) {
  treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpCmdCmpltReg)))));
 }
 treg = (pHqpCb->numIocbProcessed << 16) + hqpId;
 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpCmdCmpltReg)))) = treg);

*rMb = shdMb0 | 0x0008;
 hqmCmdCmpltHdwSim();
*rMb = shdMb0;







 ReleaseHqpResources(hqpId);


simIocbComplete = 1;




shdMb0 &= ~0x0004;
*rMb = shdMb0;
}
# 1212 "main.c"
int processIocb(int hqpId) {

int protocol = hqpCntxt[hqpId].type-1;
hqpCb *pHqpCb = HqpLookup[hqpId];
bufDesc * pDrpCrp;
opcodeFormatRamEntry opcodeFmt;







 switch (protocol) {




  case (0x01 -1): {

   unsigned long iocbIndx = pHqpCb->iocbIndx;




   fc_iocb_struct *pIocb = pHqpCb->pCurIocb;




   opcodeFmt = ReadOpcodeFormatRam(pIocb->hdr.iocb_type, protocol);







   switch (pIocb->hdr.iocb_type) {

    case 0x48: {

     dmaCb *pDmaCb = pHqpCb->pDmaCb;
     unsigned long treg;







     switch (pHqpCb->state) {

      case HQP_STATE_PROC_IOCB:




       if (pIocb->cmnd6.cmnd_cntl & 0x0004) {
        pHqpCb->flags |= 0x0001;
       }




       pDmaCb->spBufAdr = &pHqpCb->pDrp->lbuf.drp.dsd[0];



       pHqpCb->pBuf = pDmaCb->spBufAdr;
       pDmaCb->type = DMA_TYPE_DSD;
       pDmaCb->hqpId = hqpId;
       if (pHqpCb->flags & 0x0001) {
        pHqpCb->flags |= 0x0002;
        pDmaCb->adrh = pIocb->cmnd6.cmnd_dataseg0.addr_hi;
        pDmaCb->adrl = pIocb->cmnd6.cmnd_dataseg0.addr_lo;
        pDmaCb->length = pIocb->cmnd6.cmnd_dataseg0.length;
        pHqpCb->dsdCount = pIocb->cmnd6.cmnd_dataseg0.length / (sizeof(dseg_struct)*4) ;
        pHqpCb->state = HQP_STATE_WAIT_FOR_DSD_DMA;

        pHqpCb->dsdIndxInDrpCrp = 0;




        if (pDmaCb->length > ((4 +1)*sizeof(dseg_struct)*4)) {
         pDmaCb->length = 4*sizeof(dseg_struct)*4;
        }



        if (!queIsEmpty(&hostDma)) {
         enque(pDmaCb,&hostDma);
         return 0;
        }

        treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));

        while ( !(treg & (1 << 31)) ) {
         treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));
        }

        (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaSpAdrReg)))) = (((unsigned long)pDmaCb->spBufAdr) & (0x00007FFF)));
        (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrlReg)))) = pDmaCb->adrl);
        (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrhReg)))) = pDmaCb->adrh);
        (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaHqpIdReg)))) = hqpId);
        treg = (0<<14) + pDmaCb->length;

        (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))) = treg);
        enque(pDmaCb,&hostDma);


*rMb = shdMb0 | 0x0008;
        hostDmaHdwSim();
*rMb = shdMb0;



        return 0;
       } else {




       }
       break;




      case HQP_STATE_WAIT_FOR_DSD_DMA:

       if (!ProcessDsdList(hqpId,0)) {
        return 0;
       }
       break;




      case HQP_STATE_WAIT_FOR_DSD_LPTR_DMA: {

       pHqpCb->state = HQP_STATE_WAIT_FOR_DSD_DMA;
       if (!ProcessDsdList(hqpId, 1)) {
        return 0;
       }
       break;
     }
     }
     break;
    }





    case 0x18 : {






     dseg_struct *pDseg = &(pIocb->cmnd7.cmnd_dataseg0);
     dseg_struct *pDsegInDrpCrp = &pHqpCb->pDrp->lbuf.drp.dsd[0];





     pDsegInDrpCrp[0].addr_hi = pDseg->addr_hi;
     pDsegInDrpCrp[0].addr_lo = pDseg->addr_lo;
     pDsegInDrpCrp[0].length = pDseg->length;
     pHqpCb->dsdIndxInDrpCrp = 1;
     pHqpCb->flags |= 0x0002;
     pHqpCb->dsdCount = pIocb->cmnd7.cmnd_seg_cnt-1;
     break;
    }
# 1398 "main.c"
    case 0x0A: {






     dseg_struct *pDsegInDrpCrp;
     dseg_struct *pDseg = &pIocb->cont1.cont_dataseg[pHqpCb->dsdIndxInBuf];

     while (pHqpCb->dsdCount) {

      if (pHqpCb->flags & 0x0002) {
       pDsegInDrpCrp = &pHqpCb->pDrp->lbuf.drp.dsd[pHqpCb->dsdIndxInDrpCrp];

       while ( (pHqpCb->dsdIndxInDrpCrp < 4) &&
        (pHqpCb->dsdIndxInBuf < 5) &&
        (pHqpCb->dsdCount)) {

        if (!pDseg->length) {



        }
        pDsegInDrpCrp->addr_hi = pDseg->addr_hi;
        pDsegInDrpCrp->addr_lo = pDseg->addr_lo;
        pDsegInDrpCrp->length = pDseg->length;
        pDsegInDrpCrp++;
        pDseg++;
        pHqpCb->dsdIndxInDrpCrp++;
        pHqpCb->dsdIndxInBuf++;
        pHqpCb->dsdCount--;
       }



       if (!pHqpCb->dsdCount) {
     break;
    }

       if (pHqpCb->dsdIndxInDrpCrp == 4) {



        pHqpCb->flags &= ~0x0002;



        pHqpCb->pDrp->next = allocDrpCrp(hqpId);







        if (!pHqpCb->pDrp->next) {

         return 0;
        }



        pHqpCb->pDrp->lbuf.drp.nxt_crp_adr.full_adr = pHqpCb->pDrp->next->mbuf.full_adr | 0x80000000;






        pHqpCb->pCrp = pHqpCb->pDrp->next;
        pHqpCb->pCrp->next = 0;
        pHqpCb->dsdIndxInDrpCrp = 0;




        pDsegInDrpCrp = &pHqpCb->pCrp->lbuf.crp.dsd_list_0[0];

       }


       if (pHqpCb->dsdIndxInBuf == 5) {
   break;
 }



      } else {



       pDsegInDrpCrp = &pHqpCb->pCrp->lbuf.crp.dsd_list_0[pHqpCb->dsdIndxInDrpCrp];

       while ( (pHqpCb->dsdIndxInDrpCrp < 20) &&
        (pHqpCb->dsdIndxInBuf < 5) &&
        (pHqpCb->dsdCount)) {

        if (!pDseg->length) {



}
        pDsegInDrpCrp->addr_hi = pDseg->addr_hi;
        pDsegInDrpCrp->addr_lo = pDseg->addr_lo;
        pDsegInDrpCrp->length = pDseg->length;

        pDsegInDrpCrp++;
        pDseg++;
        pHqpCb->dsdIndxInDrpCrp++;
        pHqpCb->dsdIndxInBuf++;
        pHqpCb->dsdCount--;
       }



       if (!pHqpCb->dsdCount) {
        break;
       }

       if (pHqpCb->dsdIndxInDrpCrp == 20) {




        pHqpCb->pCrp->next = allocDrpCrp(hqpId);







        if (!pHqpCb->pCrp->next) {

         return 0;
        }




        pHqpCb->pCrp->lbuf.crp.nxt_crp_ptr.full_adr = pHqpCb->pCrp->next->mbuf.full_adr | 0x80000000;




        pHqpCb->pCrp = pHqpCb->pCrp->next;
        pHqpCb->pCrp->next = 0;
        pHqpCb->dsdIndxInDrpCrp = 0;




        pDsegInDrpCrp = &pHqpCb->pCrp->lbuf.crp.dsd_list_0[0];

       }



       if (pHqpCb->dsdIndxInBuf == 5) {
        break;
    }

    }

   }
     break;
    }


    case 0x6A: {

     dmaCb *pDmaCb = pHqpCb->pDmaCb;
     unsigned long treg;
# 1580 "main.c"
     switch (pHqpCb->state) {

      case HQP_STATE_PROC_IOCB:

       if (pIocb->cmnd_crc2.cmnd_cntl & 0x0004) {
        pHqpCb->flags |= 0x0001;
       }
       if (pIocb->cmnd_crc2.cmnd_cntl & 0x0008) {
        pHqpCb->flags |= 0x0004;
       }



       pHqpCb->pT10Cntxt = allocDrpCrp(hqpId);







       if (!pHqpCb->pT10Cntxt) {

        return 0;
       }





       pDmaCb->type = DMA_TYPE_CRC_CNTXT;
       pDmaCb->spBufAdr = &pHqpCb->pT10Cntxt->lbuf;
       pDmaCb->adrh = pIocb->cmnd_crc2.cmnd_crc_ctx_dsd.addr_hi;
       pDmaCb->adrl = pIocb->cmnd_crc2.cmnd_crc_ctx_dsd.addr_lo;
       pDmaCb->length = sizeof(dcrc_ctxt_struct)*4;
       pDmaCb->hqpId = hqpId;
       pHqpCb->state = HQP_STATE_WAIT_FOR_CRC_CNTXT_DMA;



       if (!queIsEmpty(&hostDma)) {
        enque(pDmaCb, &hostDma);
        return 0;
       }

       treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));

       while ( !(treg & (1 << 31)) ) {
        treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));
       }

       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaSpAdrReg)))) = (((unsigned long)pDmaCb->spBufAdr) & (0x00007FFF)));
       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrlReg)))) = pDmaCb->adrl);
       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrhReg)))) = pDmaCb->adrh);
       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaHqpIdReg)))) = hqpId);
       treg = (0<<14) + pDmaCb->length;

       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))) = treg);
       enque(pDmaCb,&hostDma);


*rMb = shdMb0 | 0x0008;
       hostDmaHdwSim();
*rMb = shdMb0;



       return 0;
       break;




      case HQP_STATE_WAIT_FOR_DSD_DMA:

       if (!ProcessDsdList(hqpId,0)) {
        return 0;
       }





       if (!(pHqpCb->flags & 0x0004)) {
        break;
       }
       dcrc_ctxt_struct *pCrcCntxt = (dcrc_ctxt_struct *)&pHqpCb->pT10Cntxt->lbuf;
       pDmaCb->type = DMA_TYPE_DSD;
       pHqpCb->pT10Cntxt->next = allocDrpCrp(hqpId);



       pHqpCb->pT10Cntxt->lbuf.drp.nxt_crp_adr.full_adr = pHqpCb->pT10Cntxt->next->mbuf.full_adr | 0x80000000;
       pHqpCb->flags &= ~0x0002;
       pHqpCb->pCrp = pHqpCb->pT10Cntxt->next;
       pDmaCb->spBufAdr = &pHqpCb->pCrp->lbuf.crp.dsd_list_0[0];
       pDmaCb->adrh = pCrcCntxt->db.dif_dsd.addr_hi;
       pDmaCb->adrl = pCrcCntxt->db.dif_dsd.addr_lo;
       pDmaCb->length = pCrcCntxt->db.dif_dsd.length;
       pHqpCb->dsdCount = pCrcCntxt->db.dif_dsd.length / (sizeof(dseg_struct)*4);
       pHqpCb->state = HQP_STATE_WAIT_FOR_CRC_DIF_DMA;




       if (pDmaCb->length > ((20 +1)*sizeof(dseg_struct)*4)) {
        pDmaCb->length = 20*sizeof(dseg_struct)*4;
       }




       if (!queIsEmpty(&hostDma)) {
        enque(pDmaCb,&hostDma);
        return 0;
       }

       treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));

       while ( !(treg & (1 << 31)) ) {
        treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));
       }

       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaSpAdrReg)))) = (((unsigned long)pDmaCb->spBufAdr) & (0x00007FFF)));
       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrlReg)))) = pDmaCb->adrl);
       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrhReg)))) = pDmaCb->adrh);
       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaHqpIdReg)))) = hqpId);
       treg = (0<<14) + pDmaCb->length;

       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))) = treg);
       enque(pDmaCb,&hostDma);


*rMb = shdMb0 | 0x0008;
       hostDmaHdwSim();
*rMb = shdMb0;



       return 0;

       break;




       case HQP_STATE_WAIT_FOR_DSD_LPTR_DMA: {

        pHqpCb->state = HQP_STATE_WAIT_FOR_DSD_DMA;
        if (!ProcessDsdList(hqpId, 1)) {
         return 0;
        }





        if (!(pHqpCb->flags & 0x0004)) {
         break;
        }
        dcrc_ctxt_struct *pCrcCntxt = (dcrc_ctxt_struct *)&pHqpCb->pT10Cntxt->lbuf;
        pDmaCb->type = DMA_TYPE_DSD;
        pHqpCb->pT10Cntxt->next = allocDrpCrp(hqpId);
        pHqpCb->flags &= ~0x0002;
        pHqpCb->pCrp = pHqpCb->pT10Cntxt->next;
        pDmaCb->spBufAdr = &pHqpCb->pCrp->lbuf.crp.dsd_list_0[0];
        pDmaCb->adrh = pCrcCntxt->db.dif_dsd.addr_hi;
        pDmaCb->adrl = pCrcCntxt->db.dif_dsd.addr_lo;
        pDmaCb->length = pCrcCntxt->db.dif_dsd.length;
        pHqpCb->dsdCount = pCrcCntxt->db.dif_dsd.length / (sizeof(dseg_struct)*4);
        pHqpCb->state = HQP_STATE_WAIT_FOR_CRC_DIF_DMA;





        if (pDmaCb->length > ((20 +1)*sizeof(dseg_struct)*4)) {
         pDmaCb->length = 20*sizeof(dseg_struct)*4;
        }




        if (!queIsEmpty(&hostDma)) {
         enque(pDmaCb,&hostDma);
         return 0;
        }

        treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));

        while ( !(treg & (1 << 31)) ) {
         treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));
        }

        (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaSpAdrReg)))) = (((unsigned long)pDmaCb->spBufAdr) & (0x00007FFF)) >> 2);
        (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrlReg)))) = pDmaCb->adrl);
        (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrhReg)))) = pDmaCb->adrh);
        (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaHqpIdReg)))) = hqpId);
        treg = (0<<14) + pDmaCb->length;

        (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))) = treg);
        enque(pDmaCb,&hostDma);




        hostDmaHdwSim();




        return 0;

        break;
       }






      case HQP_STATE_WAIT_FOR_CRC_DIF_DMA:

       if (!ProcessDsdList(hqpId,0)) {
        return 0;
       }
       break;




      case HQP_STATE_WAIT_FOR_DIF_LPTR_DMA:

       pHqpCb->state = HQP_STATE_WAIT_FOR_CRC_DIF_DMA;
       if (!ProcessDsdList(hqpId, 1)) {
        return 0;
       }
       break;




      case HQP_STATE_WAIT_FOR_CRC_CNTXT_DMA: {

       if (!(pHqpCb->flags & (0x0001 | 0x0004 ))) {
        break;
       }



       pHqpCb->pBuf = pDmaCb->spBufAdr;
       dcrc_ctxt_struct *pCrcCntxt = (dcrc_ctxt_struct *)&pHqpCb->pT10Cntxt->lbuf;
       pDmaCb->type = DMA_TYPE_DSD;

       if (pHqpCb->flags & 0x0001) {
        pDmaCb->spBufAdr = &pHqpCb->pDrp->lbuf.drp.dsd[0];
        pHqpCb->flags |= 0x0002;
        pDmaCb->adrh = pCrcCntxt->db.data_dsd.addr_hi;
        pDmaCb->adrl = pCrcCntxt->db.data_dsd.addr_lo;
        pDmaCb->length = pCrcCntxt->db.data_dsd.length;
        pHqpCb->dsdCount = pCrcCntxt->db.data_dsd.length / (sizeof(dseg_struct)*4);
        pHqpCb->state = HQP_STATE_WAIT_FOR_DSD_DMA;




        if (pDmaCb->length > ((4 +1)*sizeof(dseg_struct)*4)) {
         pDmaCb->length = 4*sizeof(dseg_struct)*4;
        }

       } else if (pHqpCb->flags & 0x0004) {
        pHqpCb->pT10Cntxt->next = allocDrpCrp(hqpId);



        pHqpCb->pT10Cntxt->lbuf.drp.nxt_crp_adr.full_adr = pHqpCb->pT10Cntxt->next->mbuf.full_adr | 0x80000000;
        pHqpCb->flags &= ~0x0002;
        pHqpCb->pCrp = pHqpCb->pT10Cntxt->next;
        pDmaCb->spBufAdr = &pHqpCb->pCrp->lbuf.crp.dsd_list_0[0];
        pDmaCb->adrh = pCrcCntxt->db.dif_dsd.addr_hi;
        pDmaCb->adrl = pCrcCntxt->db.dif_dsd.addr_lo;
        pDmaCb->length = pCrcCntxt->db.dif_dsd.length;
        pHqpCb->dsdCount = pCrcCntxt->db.dif_dsd.length / (sizeof(dseg_struct)*4);
        pHqpCb->state = HQP_STATE_WAIT_FOR_CRC_DIF_DMA;





        if (pDmaCb->length > ((20 +1)*sizeof(dseg_struct)*4)) {
         pDmaCb->length = 20*sizeof(dseg_struct)*4;
       }

       }
       pHqpCb->dsdIndxInDrpCrp = 0;



       if (!queIsEmpty(&hostDma)) {
        enque(pDmaCb,&hostDma);
        return 0;
       }

       treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));

       while ( !(treg & (1 << 31)) ) {
        treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));
       }

       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaSpAdrReg)))) = (((unsigned long)pDmaCb->spBufAdr) & (0x00007FFF)));
       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrlReg)))) = pDmaCb->adrl);
       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrhReg)))) = pDmaCb->adrh);
       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaHqpIdReg)))) = hqpId);
       treg = (0<<14) + pDmaCb->length;

       (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))) = treg);
       enque(pDmaCb,&hostDma);


*rMb = shdMb0 | 0x0008;
       hostDmaHdwSim();
*rMb = shdMb0;



       return 0;
      }
      break;
     }

    }

    default:
     break;

   }
   break;
  }

  case (0x02 -1):
   break;

  case (0x03 -1):
   break;

  case (0x04 -1):
   break;

 }


 return 1;
}
# 1946 "main.c"
int ProcessDsdList(int hqpId, int dsdListPointer) {

hqpCb *pHqpCb = HqpLookup[hqpId];
dmaCb *pDmaCb = pHqpCb->pDmaCb;

unsigned long workingOnDrp = (pHqpCb->flags & 0x0002)? 1 : 0;
unsigned long numDsegsInDrpCrp = (pHqpCb->pDmaCb->length / (sizeof(dseg_struct)*4));

unsigned long totalNumDsds = pHqpCb->dsdCount-1;
dseg_struct *pDsdListPtr;
unsigned long treg;





 pHqpCb->dsdCount -= numDsegsInDrpCrp;
 pHqpCb->dsdIndxInDrpCrp += numDsegsInDrpCrp;



 if (!pHqpCb->dsdCount) {



  pDsdListPtr = ((dseg_struct *)pDmaCb->spBufAdr)+(numDsegsInDrpCrp-1);




  if (!dsdListPointer) {
  pHqpCb->dsdIndxInDrpCrp--;
  numDsegsInDrpCrp--;
 }

  if (!pDsdListPtr->length) {



    pHqpCb->flags &= ~0x0002;
# 1994 "main.c"
   if (pHqpCb->dsdIndxInDrpCrp == 0) {




    bufDesc *pCurCrpDrp = pHqpCb->pDrp;
    while (pCurCrpDrp && (pCurCrpDrp->next != pHqpCb->pCrp)) {
     pCurCrpDrp = pCurCrpDrp->next;
   }
    pCurCrpDrp->next = 0;
    enque(pHqpCb->pCrp,&drpCrpFreePool);





    pCurCrpDrp->lbuf.crp.nxt_crp_ptr.full_adr = 0;
   }
   return 1;
  }



  pDmaCb->adrh = pDsdListPtr->addr_hi;
  pDmaCb->adrl = pDsdListPtr->addr_lo;
  pDmaCb->length = pDsdListPtr->length;
  pHqpCb->dsdCount = pDsdListPtr->length / (sizeof(dseg_struct)*4);

 } else {



  pDmaCb->adrl += pDmaCb->length;
  pDmaCb->length = pHqpCb->dsdCount * sizeof(dseg_struct) *4;
   }



 if (pDmaCb->length == (sizeof(dseg_struct)*4)) {



  pDmaCb->spBufAdr = dmalloc(sizeof(dseg_struct));
  pHqpCb->state = HQP_STATE_WAIT_FOR_DSD_LPTR_DMA;






 } else if (workingOnDrp) {



  if (numDsegsInDrpCrp == 4) {
    workingOnDrp = 0;
    pHqpCb->flags &= ~0x0002;




    pHqpCb->pDrp->next = allocDrpCrp(hqpId);







    if (!pHqpCb->pDrp->next) {

     return 0;
    }



    pHqpCb->pDrp->lbuf.drp.nxt_crp_adr.full_adr = pHqpCb->pDrp->next->mbuf.full_adr | 0x80000000;



    pHqpCb->pCrp = pHqpCb->pDrp->next;
    pHqpCb->pCrp->next = 0;
    pHqpCb->dsdIndxInDrpCrp = 0;




   pDmaCb->spBufAdr = &pHqpCb->pCrp->lbuf.crp.dsd_list_0[0];



   if (pDmaCb->length > ( (20 +1)*sizeof(dseg_struct)*4) ) {
    pDmaCb->length = 20*sizeof(dseg_struct)*4;
   }

  } else {



   pDmaCb->spBufAdr += (4 - numDsegsInDrpCrp);
   pDmaCb->length = (4 - numDsegsInDrpCrp) * sizeof(dseg_struct) *4;
   }




 } else {




   if (pHqpCb->dsdIndxInDrpCrp == 20) {



    pHqpCb->pCrp->next = allocDrpCrp(hqpId);







    if (!pHqpCb->pCrp->next) {


     return 0;
    }




    pHqpCb->pCrp->lbuf.crp.nxt_crp_ptr.full_adr = pHqpCb->pCrp->next->mbuf.full_adr | 0x80000000;




    pHqpCb->pCrp = pHqpCb->pCrp->next;
    pHqpCb->pCrp->next = 0;
    pHqpCb->dsdIndxInDrpCrp = 0;



   pDmaCb->spBufAdr = &pHqpCb->pCrp->lbuf.crp.dsd_list_0[0];



   if (pDmaCb->length > ( (20 +1)*sizeof(dseg_struct)*4) ) {
    pDmaCb->length = 20*sizeof(dseg_struct)*4;
   }
  } else {



   pDmaCb->spBufAdr += (20 - numDsegsInDrpCrp);
   pDmaCb->length = (20 - numDsegsInDrpCrp) * sizeof(dseg_struct)*4;
  }
 }
# 2161 "main.c"
 if (!queIsEmpty(&hostDma)) {
  enque(pDmaCb,&hostDma);
  return 0;
 }

 treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));

 while ( !(treg & (1 << 31)) ) {
  treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))));
 }

 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaSpAdrReg)))) = (((unsigned long)pDmaCb->spBufAdr) & (0x00007FFF)));
 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrlReg)))) = pDmaCb->adrl);
 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaAdrhReg)))) = pDmaCb->adrl);
 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaHqpIdReg)))) = hqpId);
 treg = (0<<14) + pDmaCb->length;

 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hostDmaCmdReg)))) = treg);
 enque(pDmaCb,&hostDma);


*rMb = shdMb0 | 0x0008;
 hostDmaHdwSim();
*rMb = shdMb0;


 return 0;
}
# 2207 "main.c"
void ReleaseHqpResources(int hqpId) {

hqpCb *pHqpCb = HqpLookup[hqpId];
unsigned long treg;
# 2219 "main.c"
 if (pHqpCb->pBuf) {
  dfree(pHqpCb->pBuf);
 }





 enqueFpFifo((unsigned long)(pHqpCb->pDrp));

 enque(pHqpCb,&hqpCbFreePool);
 HqpLookup[hqpId] = 0;
}
# 2252 "main.c"
void getHqpContext(int hqpId) {

unsigned long treg;
hqmHqpCntxt *pBuf;
hqpCntxtEntry *pHqpCntxtEntry = &hqpCntxt[hqpId];





 treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpCntxtCmdReg)))));

 while ( !(treg & (1<<31)) ) {
  treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpCntxtCmdReg)))));
 }



 pBuf = (hqmHqpCntxt *)dmalloc(sizeof(hqmHqpCntxt));

 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpCntxtSpAdrReg)))) = ((((unsigned long)pBuf) & (0x00007FFF))));
 (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpCntxtCmdReg)))) = hqpId);


*rMb = shdMb0 | 0x0008;
 hqpContextDmaHdwSim();;
*rMb = shdMb0;


 treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpCntxtCmdReg)))));

 while ( !(treg & (1<<31)) ) {
  treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->hqpCntxtCmdReg)))));
 }




 pHqpCntxtEntry->vpid = pBuf->vpid;
 pHqpCntxtEntry->port = pBuf->port;
 pHqpCntxtEntry->type = pBuf->type;
 pHqpCntxtEntry->iocbRegion = pBuf->iocbRegion;
 pHqpCntxtEntry->mqsL1q = pBuf->mqsL1Que;
 pHqpCntxtEntry->cntxtSize = pBuf->cntxtSize;
 pHqpCntxtEntry->cntxtRegion = pBuf->cntxtRegion;
 if (pBuf->state == 0x8) {
  pHqpCntxtEntry->valid = 1;
 } else {
  pHqpCntxtEntry->valid = 0;
 }






 dfree(pBuf);
}
# 2338 "main.c"
bufDesc *allocDrpCrp(int hqpId) {

unsigned long treg;
hqpCb *pHqpCb = HqpLookup[hqpId];
bufDesc * pDrpCrp;
# 2351 "main.c"
 if (!queIsEmpty(&drpCrpFreePool)) {
  pDrpCrp = (bufDesc *)deque(&drpCrpFreePool);

  memclrMim0(pDrpCrp,sizeof(bufDesc));




  treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimBlkRqReg)))));

  while ( !(treg & (1<<31)) ) {
   treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimBlkRqReg)))));
  }




  treg = (1<<27) + (hqpCntxt[hqpId].iocbRegion << 20);
  (*((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimBlkRqReg)))) = treg);


*rMb = shdMb0 | 0x0008;
 mlmHdwSim();
*rMb = shdMb0;

  treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimBlkRqReg)))));
  while ( !(treg & (1<<31)) ) {
   treg = ( *((volatile unsigned long *)(((unsigned long)&spRegs) + (((unsigned long)&((sp_regs *)0)->mimBlkRqReg)))));
  }
  if (treg & (1<<30)) {
   enque(pDrpCrp,&drpCrpFreePool);
   return 0;
  }



  pDrpCrp->mbuf.blk_id = treg & (0x7FF);
  pDrpCrp->mbuf.mem_rgn = hqpCntxt[hqpId].iocbRegion;
  return pDrpCrp;




 } else {
  return 0;
 }
}
# 2409 "main.c"
unsigned long calcTimerTime(timer *t) {

unsigned long time;
unsigned long delta = 0;
unsigned long *pStTick;
unsigned long *pEndTick;

 if (t->tick[1] < t->tick[0]) {
  time = (0xFFFFFFFF - (t->tick[0] - t->tick[1])) + 1;
 } else {
  time = t->tick[1] - t->tick[0];
 }
 pStTick = &(t->tick[2]);
 pEndTick = &(t->tick[3]);

 while (*pStTick) {
  if (*pEndTick < *pStTick) {
   delta += ((0xFFFFFFFF - (*pStTick - *pEndTick)) + 1);
  } else {
   delta += (*pEndTick - *pStTick);
  }
  pEndTick += 2;
  pStTick += 2;

 }
 return (time - delta);
}

 No Errors found

***************** Productions *************************
 Productions recorded by SymbolTable class:
Line: 9  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 9  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 9  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 9  Token: IDENTIFIER        Lexeme: uint32
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 9  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: uint32 added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: uint32 updated
setTypeName: uint32 updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> external_declaration
Line: 11  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 11  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 11  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 11  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 11  Token: IDENTIFIER        Lexeme: U64
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 declaration_specifiers -> type_specifier declaration_specifiers
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 11  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: U64 added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: U64 updated
setTypeName: U64 updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 12  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 12  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 12  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 12  Token: IDENTIFIER        Lexeme: U32
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 12  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: U32 added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: U32 updated
setTypeName: U32 updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 13  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 13  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 13  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 13  Token: IDENTIFIER        Lexeme: U16
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 13  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: U16 added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: U16 updated
setTypeName: U16 updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 14  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 14  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 14  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 14  Token: IDENTIFIER        Lexeme: U8
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 14  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: U8 added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: U8 updated
setTypeName: U8 updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 27  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 27  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 27  Token: {  Lexeme: {
Line: 28  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 28  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 28  Token: IDENTIFIER        Lexeme: addr_lo
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 28  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 29  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 29  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 29  Token: IDENTIFIER        Lexeme: addr_hi
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 29  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 30  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 30  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 30  Token: IDENTIFIER        Lexeme: length
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 30  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 31  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 31  Token: IDENTIFIER        Lexeme: dseg_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 31  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dseg_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: dseg_struct updated
setTypeName: dseg_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 36  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 36  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 36  Token: {  Lexeme: {
Line: 37  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 37  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 37  Token: IDENTIFIER        Lexeme: ref_tag
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 37  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 38  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 38  Token: {  Lexeme: {
Line: 39  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 39  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 39  Token: IDENTIFIER        Lexeme: rep_ref_tag
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 39  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 40  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 40  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 40  Token: IDENTIFIER        Lexeme: ref_mask
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 40  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 41  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 41  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 42  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 42  Token: {  Lexeme: {
Line: 43  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 43  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 43  Token: IDENTIFIER        Lexeme: rep_app_tag
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 43  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 44  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 44  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 44  Token: IDENTIFIER        Lexeme: app_mask
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 44  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 45  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 45  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 46  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 46  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 46  Token: IDENTIFIER        Lexeme: app_tag
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 46  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 47  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 47  Token: IDENTIFIER        Lexeme: skp_msk_tag_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 47  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: skp_msk_tag_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: skp_msk_tag_struct updated
setTypeName: skp_msk_tag_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 50  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 50  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 50  Token: {  Lexeme: {
Line: 51  Token: IDENTIFIER        Lexeme: skp_msk_tag_struct
 type_specifier -> TYPE_NAME
Line: 51  Token: IDENTIFIER        Lexeme: tag
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 51  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 52  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 52  Token: IDENTIFIER        Lexeme: dsd
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 52  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 53  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 53  Token: IDENTIFIER        Lexeme: skp_msk_dsd_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 53  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: skp_msk_dsd_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: skp_msk_dsd_struct updated
setTypeName: skp_msk_dsd_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 57  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 57  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 57  Token: {  Lexeme: {
Line: 58  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 58  Token: {  Lexeme: {
Line: 59  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 59  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 59  Token: IDENTIFIER        Lexeme: full_adr
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 59  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 60  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 60  Token: {  Lexeme: {
Line: 61  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 61  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 61  Token: IDENTIFIER        Lexeme: blk_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 61  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 61  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 61  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 62  Token: IDENTIFIER        Lexeme: mem_rgn
 direct_declarator -> IDENTIFIER
Line: 62  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 62  Token: CONSTANT          Lexeme: 6
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 62  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 63  Token: IDENTIFIER        Lexeme: flags
 direct_declarator -> IDENTIFIER
Line: 63  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 63  Token: CONSTANT          Lexeme: 6
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 63  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 64  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 64  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 65  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 65  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 66  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 66  Token: IDENTIFIER        Lexeme: mim_adr_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 66  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: mim_adr_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: mim_adr_struct updated
setTypeName: mim_adr_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 67  Token: ENUM              Lexeme: enum
Line: 67  Token: {  Lexeme: {
Line: 67  Token: IDENTIFIER        Lexeme: ql_struct_assert_line_102
Line: 67  Token: =  Lexeme: =
Line: 67  Token: (  Lexeme: (
Line: 67  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 67  Token: (  Lexeme: (
Line: 67  Token: SIZEOF            Lexeme: sizeof
Line: 67  Token: (  Lexeme: (
Line: 67  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 67  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 67  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 67  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 67  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 67  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 67  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 67  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 69  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 69  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 69  Token: {  Lexeme: {
Line: 70  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 70  Token: IDENTIFIER        Lexeme: nxt_crp_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 70  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 71  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 71  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 71  Token: IDENTIFIER        Lexeme: nxt_crp_ofst
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 71  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 72  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 72  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 72  Token: IDENTIFIER        Lexeme: nxt_dsd_rel_idx
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 72  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 73  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 73  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 73  Token: IDENTIFIER        Lexeme: rsvd0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 73  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 74  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 74  Token: IDENTIFIER        Lexeme: cur_dsd
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 74  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 75  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 75  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 75  Token: IDENTIFIER        Lexeme: rem_dsd_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 75  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 76  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 76  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 76  Token: IDENTIFIER        Lexeme: rsvd1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 76  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 77  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 77  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 77  Token: IDENTIFIER        Lexeme: cur_dsd_rist
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 77  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 78  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 78  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 78  Token: IDENTIFIER        Lexeme: tot_ofst
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 78  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 79  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 79  Token: IDENTIFIER        Lexeme: alcb_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 79  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: alcb_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: alcb_struct updated
setTypeName: alcb_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 80  Token: ENUM              Lexeme: enum
Line: 80  Token: {  Lexeme: {
Line: 80  Token: IDENTIFIER        Lexeme: ql_struct_assert_line_124
Line: 80  Token: =  Lexeme: =
Line: 80  Token: (  Lexeme: (
Line: 80  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 80  Token: (  Lexeme: (
Line: 80  Token: SIZEOF            Lexeme: sizeof
Line: 80  Token: (  Lexeme: (
Line: 80  Token: IDENTIFIER        Lexeme: alcb_struct
 type_specifier -> TYPE_NAME
Line: 80  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 80  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 80  Token: CONSTANT          Lexeme: 32
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 80  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 80  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 80  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 80  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 90  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 90  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 90  Token: IDENTIFIER        Lexeme: fc_iocb_hdr_s
Line: 90  Token: {  Lexeme: {
Line: 91  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 91  Token: {  Lexeme: {
Line: 92  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 92  Token: {  Lexeme: {
Line: 93  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 93  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 93  Token: IDENTIFIER        Lexeme: iocb_type
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 93  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 94  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 94  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 94  Token: IDENTIFIER        Lexeme: iocb_count
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 94  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 95  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 95  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 96  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 96  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 96  Token: IDENTIFIER        Lexeme: iocb_cnt_typ
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 96  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 97  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 97  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 98  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 98  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 98  Token: IDENTIFIER        Lexeme: iocb_sysdef_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 98  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 99  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 99  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 99  Token: IDENTIFIER        Lexeme: iocb_status
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 99  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 100  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 100  Token: IDENTIFIER        Lexeme: fc_iocb_hdr_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 100  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fc_iocb_hdr_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: fc_iocb_hdr_struct updated
setTypeName: fc_iocb_hdr_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 101  Token: ENUM              Lexeme: enum
Line: 101  Token: {  Lexeme: {
Line: 101  Token: IDENTIFIER        Lexeme: fciocb_assert_line_167
Line: 101  Token: =  Lexeme: =
Line: 101  Token: (  Lexeme: (
Line: 101  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 101  Token: (  Lexeme: (
Line: 101  Token: SIZEOF            Lexeme: sizeof
Line: 101  Token: (  Lexeme: (
Line: 101  Token: IDENTIFIER        Lexeme: fc_iocb_hdr_struct
 type_specifier -> TYPE_NAME
Line: 101  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 101  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 101  Token: (  Lexeme: (
Line: 101  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 101  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 101  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 101  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 101  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 101  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 101  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 101  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 107  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 107  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 107  Token: IDENTIFIER        Lexeme: cont1_s
Line: 107  Token: {  Lexeme: {
Line: 108  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 108  Token: IDENTIFIER        Lexeme: cont_dataseg
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 108  Token: [  Lexeme: [
Line: 108  Token: CONSTANT          Lexeme: 5
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 108  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 108  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 109  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 109  Token: IDENTIFIER        Lexeme: cont1_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 109  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: cont1_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: cont1_struct updated
setTypeName: cont1_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 110  Token: ENUM              Lexeme: enum
Line: 110  Token: {  Lexeme: {
Line: 110  Token: IDENTIFIER        Lexeme: fciocb_assert_line_176
Line: 110  Token: =  Lexeme: =
Line: 110  Token: (  Lexeme: (
Line: 110  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 110  Token: (  Lexeme: (
Line: 110  Token: SIZEOF            Lexeme: sizeof
Line: 110  Token: (  Lexeme: (
Line: 110  Token: IDENTIFIER        Lexeme: cont1_struct
 type_specifier -> TYPE_NAME
Line: 110  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 110  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 110  Token: (  Lexeme: (
Line: 110  Token: (  Lexeme: (
Line: 110  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 110  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 110  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 110  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 110  Token: (  Lexeme: (
Line: 110  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 110  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 110  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 110  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 110  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 113  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 113  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 113  Token: IDENTIFIER        Lexeme: cont_crc1_s
Line: 113  Token: {  Lexeme: {
Line: 114  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 114  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 114  Token: IDENTIFIER        Lexeme: guard_seed
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 114  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 115  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 115  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 115  Token: IDENTIFIER        Lexeme: prot_opts
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 115  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 116  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 116  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 116  Token: IDENTIFIER        Lexeme: block_sz
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 116  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 117  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 117  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 117  Token: IDENTIFIER        Lexeme: runt_guard
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 117  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 119  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 119  Token: {  Lexeme: {
Line: 120  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 120  Token: {  Lexeme: {
Line: 121  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 121  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 121  Token: IDENTIFIER        Lexeme: ndb_tot_pxc
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 121  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 122  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 122  Token: IDENTIFIER        Lexeme: dataseg
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 122  Token: [  Lexeme: [
Line: 122  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 122  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 122  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 123  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 123  Token: IDENTIFIER        Lexeme: non_db
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 123  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 124  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 124  Token: {  Lexeme: {
Line: 125  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 125  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 125  Token: IDENTIFIER        Lexeme: db_data_pxc
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 125  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 126  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 126  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 126  Token: IDENTIFIER        Lexeme: db_dif_pxc
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 126  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 127  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 127  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 127  Token: IDENTIFIER        Lexeme: rsvd_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 127  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 128  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 128  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 128  Token: IDENTIFIER        Lexeme: blk_dsd_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 128  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 129  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 129  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 129  Token: IDENTIFIER        Lexeme: rsvd_2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 129  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 130  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 130  Token: IDENTIFIER        Lexeme: dataseg
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 130  Token: [  Lexeme: [
Line: 130  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 130  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 130  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 131  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 131  Token: IDENTIFIER        Lexeme: db
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 131  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 132  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 132  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 133  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 133  Token: IDENTIFIER        Lexeme: cont_crc1_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 133  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: cont_crc1_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: cont_crc1_struct updated
setTypeName: cont_crc1_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 134  Token: ENUM              Lexeme: enum
Line: 134  Token: {  Lexeme: {
Line: 134  Token: IDENTIFIER        Lexeme: fciocb_assert_line_200
Line: 134  Token: =  Lexeme: =
Line: 134  Token: (  Lexeme: (
Line: 134  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 134  Token: (  Lexeme: (
Line: 134  Token: SIZEOF            Lexeme: sizeof
Line: 134  Token: (  Lexeme: (
Line: 134  Token: IDENTIFIER        Lexeme: cont_crc1_struct
 type_specifier -> TYPE_NAME
Line: 134  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 134  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 134  Token: (  Lexeme: (
Line: 134  Token: (  Lexeme: (
Line: 134  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 134  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 134  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 134  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 134  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 134  Token: (  Lexeme: (
Line: 134  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 134  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 134  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 134  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 134  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 134  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 134  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 134  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 134  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 138  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 138  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 138  Token: IDENTIFIER        Lexeme: cmnd7_s
Line: 138  Token: {  Lexeme: {
Line: 139  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 139  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 139  Token: IDENTIFIER        Lexeme: cmnd_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 139  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 140  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 140  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 140  Token: IDENTIFIER        Lexeme: cmnd_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 140  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 141  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 141  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 141  Token: IDENTIFIER        Lexeme: cmnd_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 141  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 142  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 142  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 142  Token: IDENTIFIER        Lexeme: cmnd_seg_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 142  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 143  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 143  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 143  Token: IDENTIFIER        Lexeme: cmnd_rsvd_0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 143  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 144  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 144  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 144  Token: IDENTIFIER        Lexeme: cmnd_lun_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 144  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 145  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 145  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 145  Token: IDENTIFIER        Lexeme: cmnd_lun_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 145  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 146  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 146  Token: {  Lexeme: {
Line: 147  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 147  Token: {  Lexeme: {
Line: 148  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 148  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 148  Token: IDENTIFIER        Lexeme: cmnd_tm
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 148  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 149  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 149  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 149  Token: IDENTIFIER        Lexeme: cmnd_crn
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 149  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 150  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 150  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 151  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 151  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 151  Token: IDENTIFIER        Lexeme: cmnd_cntl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 151  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 152  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 152  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 153  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 153  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 153  Token: IDENTIFIER        Lexeme: cmnd_cdb0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 153  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 154  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 154  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 154  Token: IDENTIFIER        Lexeme: cmnd_cdb1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 154  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 155  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 155  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 155  Token: IDENTIFIER        Lexeme: cmnd_cdb2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 155  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 156  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 156  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 156  Token: IDENTIFIER        Lexeme: cmnd_cdb3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 156  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 157  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 157  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 157  Token: IDENTIFIER        Lexeme: cmnd_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 157  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 158  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 158  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 158  Token: IDENTIFIER        Lexeme: cmnd_target_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 158  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 158  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 158  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 159  Token: IDENTIFIER        Lexeme: cmnd_vp_index
 direct_declarator -> IDENTIFIER
Line: 159  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 159  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 159  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 160  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 160  Token: IDENTIFIER        Lexeme: cmnd_dataseg0
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 160  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 162  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 162  Token: IDENTIFIER        Lexeme: cmnd7_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 162  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: cmnd7_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: cmnd7_struct updated
setTypeName: cmnd7_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 163  Token: ENUM              Lexeme: enum
Line: 163  Token: {  Lexeme: {
Line: 163  Token: IDENTIFIER        Lexeme: fciocb_assert_line_229
Line: 163  Token: =  Lexeme: =
Line: 163  Token: (  Lexeme: (
Line: 163  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 163  Token: (  Lexeme: (
Line: 163  Token: SIZEOF            Lexeme: sizeof
Line: 163  Token: (  Lexeme: (
Line: 163  Token: IDENTIFIER        Lexeme: cmnd7_struct
 type_specifier -> TYPE_NAME
Line: 163  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 163  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 163  Token: (  Lexeme: (
Line: 163  Token: (  Lexeme: (
Line: 163  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 163  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 163  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 163  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 163  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 163  Token: (  Lexeme: (
Line: 163  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 163  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 163  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 163  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 163  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 163  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 163  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 163  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 163  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 166  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 166  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 166  Token: IDENTIFIER        Lexeme: cmnd6_s
Line: 166  Token: {  Lexeme: {
Line: 167  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 167  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 167  Token: IDENTIFIER        Lexeme: cmnd_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 167  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 168  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 168  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 168  Token: IDENTIFIER        Lexeme: cmnd_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 168  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 169  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 169  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 169  Token: IDENTIFIER        Lexeme: cmnd_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 169  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 170  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 170  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 170  Token: IDENTIFIER        Lexeme: cmnd_seg_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 170  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 171  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 171  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 171  Token: IDENTIFIER        Lexeme: cmnd_fcprsp_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 171  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 172  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 172  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 172  Token: IDENTIFIER        Lexeme: cmnd_lun_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 172  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 173  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 173  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 173  Token: IDENTIFIER        Lexeme: cmnd_lun_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 173  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 174  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 174  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 174  Token: IDENTIFIER        Lexeme: cmnd_cntl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 174  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 175  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 175  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 175  Token: IDENTIFIER        Lexeme: cmnd_fcpcmd_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 175  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 176  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 176  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 176  Token: IDENTIFIER        Lexeme: cmnd_fcpcmd_adr_lo
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 176  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 177  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 177  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 177  Token: IDENTIFIER        Lexeme: cmnd_fcpcmd_adr_hi
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 177  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 178  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 178  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 178  Token: IDENTIFIER        Lexeme: cmnd_fcprsp_adr_lo
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 178  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 179  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 179  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 179  Token: IDENTIFIER        Lexeme: cmnd_fcprsp_adr_hi
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 179  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 180  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 180  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 180  Token: IDENTIFIER        Lexeme: cmnd_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 180  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 181  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 181  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 181  Token: IDENTIFIER        Lexeme: cmnd_target_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 181  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 181  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 181  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 182  Token: IDENTIFIER        Lexeme: cmnd_vp_index
 direct_declarator -> IDENTIFIER
Line: 182  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 182  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 182  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 183  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 183  Token: IDENTIFIER        Lexeme: cmnd_dataseg0
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 183  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 185  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 185  Token: IDENTIFIER        Lexeme: cmnd6_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 185  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: cmnd6_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: cmnd6_struct updated
setTypeName: cmnd6_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 186  Token: ENUM              Lexeme: enum
Line: 186  Token: {  Lexeme: {
Line: 186  Token: IDENTIFIER        Lexeme: fciocb_assert_line_252
Line: 186  Token: =  Lexeme: =
Line: 186  Token: (  Lexeme: (
Line: 186  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 186  Token: (  Lexeme: (
Line: 186  Token: SIZEOF            Lexeme: sizeof
Line: 186  Token: (  Lexeme: (
Line: 186  Token: IDENTIFIER        Lexeme: cmnd6_struct
 type_specifier -> TYPE_NAME
Line: 186  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 186  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 186  Token: (  Lexeme: (
Line: 186  Token: (  Lexeme: (
Line: 186  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 186  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 186  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 186  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 186  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 186  Token: (  Lexeme: (
Line: 186  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 186  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 186  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 186  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 186  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 186  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 186  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 186  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 186  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 189  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 189  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 189  Token: IDENTIFIER        Lexeme: cmnd_crc1_s
Line: 189  Token: {  Lexeme: {
Line: 190  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 190  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 190  Token: IDENTIFIER        Lexeme: cmnd_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 190  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 191  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 191  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 191  Token: IDENTIFIER        Lexeme: cmnd_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 191  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 192  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 192  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 192  Token: IDENTIFIER        Lexeme: cmnd_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 192  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 193  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 193  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 193  Token: IDENTIFIER        Lexeme: cmnd_seg_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 193  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 194  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 194  Token: {  Lexeme: {
Line: 195  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 195  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 195  Token: IDENTIFIER        Lexeme: cmnd_crc1_rsvd_0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 195  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 196  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 196  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 196  Token: IDENTIFIER        Lexeme: cmnd_crc3_opts
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 196  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 197  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 197  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 198  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 198  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 198  Token: IDENTIFIER        Lexeme: cmnd_lun_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 198  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 199  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 199  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 199  Token: IDENTIFIER        Lexeme: cmnd_lun_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 199  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 200  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 200  Token: {  Lexeme: {
Line: 201  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 201  Token: {  Lexeme: {
Line: 202  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 202  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 202  Token: IDENTIFIER        Lexeme: cmnd_tm
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 202  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 203  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 203  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 203  Token: IDENTIFIER        Lexeme: cmnd_crn
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 203  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 204  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 204  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 205  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 205  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 205  Token: IDENTIFIER        Lexeme: cmnd_cntl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 205  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 206  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 206  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 207  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 207  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 207  Token: IDENTIFIER        Lexeme: cmnd_cdb0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 207  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 208  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 208  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 208  Token: IDENTIFIER        Lexeme: cmnd_cdb1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 208  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 209  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 209  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 209  Token: IDENTIFIER        Lexeme: cmnd_cdb2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 209  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 210  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 210  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 210  Token: IDENTIFIER        Lexeme: cmnd_cdb3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 210  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 211  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 211  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 211  Token: IDENTIFIER        Lexeme: cmnd_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 211  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 212  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 212  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 212  Token: IDENTIFIER        Lexeme: cmnd_target_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 212  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 212  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 212  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 213  Token: IDENTIFIER        Lexeme: cmnd_vp_index
 direct_declarator -> IDENTIFIER
Line: 213  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 213  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 213  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 214  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 214  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 214  Token: IDENTIFIER        Lexeme: cmnd_ref_tag
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 214  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 215  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 215  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 215  Token: IDENTIFIER        Lexeme: cmnd_app_tag
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 215  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 216  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 216  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 216  Token: IDENTIFIER        Lexeme: cmnd_ref_mask_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 216  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 217  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 217  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 217  Token: IDENTIFIER        Lexeme: cmnd_ref_mask_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 217  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 218  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 218  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 218  Token: IDENTIFIER        Lexeme: cmnd_app_mask
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 218  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 219  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 219  Token: IDENTIFIER        Lexeme: cmnd_crc1_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 219  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: cmnd_crc1_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: cmnd_crc1_struct updated
setTypeName: cmnd_crc1_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 220  Token: ENUM              Lexeme: enum
Line: 220  Token: {  Lexeme: {
Line: 220  Token: IDENTIFIER        Lexeme: fciocb_assert_line_286
Line: 220  Token: =  Lexeme: =
Line: 220  Token: (  Lexeme: (
Line: 220  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 220  Token: (  Lexeme: (
Line: 220  Token: SIZEOF            Lexeme: sizeof
Line: 220  Token: (  Lexeme: (
Line: 220  Token: IDENTIFIER        Lexeme: cmnd_crc1_struct
 type_specifier -> TYPE_NAME
Line: 220  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 220  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 220  Token: (  Lexeme: (
Line: 220  Token: (  Lexeme: (
Line: 220  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 220  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 220  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 220  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 220  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 220  Token: (  Lexeme: (
Line: 220  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 220  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 220  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 220  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 220  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 220  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 220  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 220  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 220  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 223  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 223  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 223  Token: IDENTIFIER        Lexeme: cmnd_crc2_s
Line: 223  Token: {  Lexeme: {
Line: 224  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 224  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 224  Token: IDENTIFIER        Lexeme: cmnd_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 224  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 225  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 225  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 225  Token: IDENTIFIER        Lexeme: cmnd_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 225  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 226  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 226  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 226  Token: IDENTIFIER        Lexeme: cmnd_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 226  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 227  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 227  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 227  Token: IDENTIFIER        Lexeme: cmnd_seg_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 227  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 228  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 228  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 228  Token: IDENTIFIER        Lexeme: cmnd_fcprsp_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 228  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 229  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 229  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 229  Token: IDENTIFIER        Lexeme: cmnd_lun_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 229  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 230  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 230  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 230  Token: IDENTIFIER        Lexeme: cmnd_lun_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 230  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 231  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 231  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 231  Token: IDENTIFIER        Lexeme: cmnd_cntl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 231  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 232  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 232  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 232  Token: IDENTIFIER        Lexeme: cmnd_fcpcmd_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 232  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 233  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 233  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 233  Token: IDENTIFIER        Lexeme: cmnd_fcpcmd_adr_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 233  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 234  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 234  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 234  Token: IDENTIFIER        Lexeme: cmnd_fcpcmd_adr_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 234  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 235  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 235  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 235  Token: IDENTIFIER        Lexeme: cmnd_fcprsp_adr_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 235  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 236  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 236  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 236  Token: IDENTIFIER        Lexeme: cmnd_fcprsp_adr_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 236  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 237  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 237  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 237  Token: IDENTIFIER        Lexeme: cmnd_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 237  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 238  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 238  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 238  Token: IDENTIFIER        Lexeme: cmnd_target_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 238  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 238  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 238  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 239  Token: IDENTIFIER        Lexeme: cmnd_vp_index
 direct_declarator -> IDENTIFIER
Line: 239  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 239  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 239  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 240  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 240  Token: IDENTIFIER        Lexeme: cmnd_crc_ctx_dsd
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 240  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 241  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 241  Token: IDENTIFIER        Lexeme: cmnd_crc2_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 241  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: cmnd_crc2_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: cmnd_crc2_struct updated
setTypeName: cmnd_crc2_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 242  Token: ENUM              Lexeme: enum
Line: 242  Token: {  Lexeme: {
Line: 242  Token: IDENTIFIER        Lexeme: fciocb_assert_line_308
Line: 242  Token: =  Lexeme: =
Line: 242  Token: (  Lexeme: (
Line: 242  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 242  Token: (  Lexeme: (
Line: 242  Token: SIZEOF            Lexeme: sizeof
Line: 242  Token: (  Lexeme: (
Line: 242  Token: IDENTIFIER        Lexeme: cmnd_crc2_struct
 type_specifier -> TYPE_NAME
Line: 242  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 242  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 242  Token: (  Lexeme: (
Line: 242  Token: (  Lexeme: (
Line: 242  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 242  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 242  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 242  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 242  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 242  Token: (  Lexeme: (
Line: 242  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 242  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 242  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 242  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 242  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 242  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 242  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 242  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 242  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 245  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 245  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 245  Token: IDENTIFIER        Lexeme: cmnd_crc3_s
Line: 245  Token: {  Lexeme: {
Line: 246  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 246  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 246  Token: IDENTIFIER        Lexeme: cmnd_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 246  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 247  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 247  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 247  Token: IDENTIFIER        Lexeme: cmnd_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 247  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 248  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 248  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 248  Token: IDENTIFIER        Lexeme: cmnd_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 248  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 249  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 249  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 249  Token: IDENTIFIER        Lexeme: cmnd_seg_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 249  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 250  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 250  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 250  Token: IDENTIFIER        Lexeme: cmnd_crc3_opts
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 250  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 251  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 251  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 251  Token: IDENTIFIER        Lexeme: cmnd_lun_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 251  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 252  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 252  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 252  Token: IDENTIFIER        Lexeme: cmnd_lun_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 252  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 253  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 253  Token: {  Lexeme: {
Line: 254  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 254  Token: {  Lexeme: {
Line: 255  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 255  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 255  Token: IDENTIFIER        Lexeme: cmnd_tm
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 255  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 256  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 256  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 256  Token: IDENTIFIER        Lexeme: cmnd_crn
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 256  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 257  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 257  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 258  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 258  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 258  Token: IDENTIFIER        Lexeme: cmnd_cntl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 258  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 259  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 259  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 260  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 260  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 260  Token: IDENTIFIER        Lexeme: cmnd_cdb0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 260  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 261  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 261  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 261  Token: IDENTIFIER        Lexeme: cmnd_cdb1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 261  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 262  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 262  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 262  Token: IDENTIFIER        Lexeme: cmnd_cdb2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 262  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 263  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 263  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 263  Token: IDENTIFIER        Lexeme: cmnd_cdb3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 263  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 264  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 264  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 264  Token: IDENTIFIER        Lexeme: cmnd_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 264  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 265  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 265  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 265  Token: IDENTIFIER        Lexeme: cmnd_target_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 265  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 265  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 265  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 266  Token: IDENTIFIER        Lexeme: cmnd_vp_index
 direct_declarator -> IDENTIFIER
Line: 266  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 266  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 266  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 267  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 267  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 267  Token: IDENTIFIER        Lexeme: cmnd_ref_tag0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 267  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 268  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 268  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 268  Token: IDENTIFIER        Lexeme: cmnd_app_tag0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 268  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 269  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 269  Token: {  Lexeme: {
Line: 270  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 270  Token: {  Lexeme: {
Line: 271  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 271  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 271  Token: IDENTIFIER        Lexeme: cmnd_rep_ref_tag0_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 271  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 272  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 272  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 272  Token: IDENTIFIER        Lexeme: cmnd_rep_ref_tag0_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 272  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 273  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 273  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 273  Token: IDENTIFIER        Lexeme: cmnd_rep_app_tag0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 273  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 274  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 274  Token: IDENTIFIER        Lexeme: vr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 274  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 275  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 275  Token: {  Lexeme: {
Line: 276  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 276  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 276  Token: IDENTIFIER        Lexeme: cmnd_ref_mask0_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 276  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 277  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 277  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 277  Token: IDENTIFIER        Lexeme: cmnd_ref_mask0_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 277  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 278  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 278  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 278  Token: IDENTIFIER        Lexeme: cmnd_app_mask0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 278  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 279  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 279  Token: IDENTIFIER        Lexeme: nvr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 279  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 280  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 280  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 282  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 282  Token: IDENTIFIER        Lexeme: cmnd_crc3_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 282  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: cmnd_crc3_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: cmnd_crc3_struct updated
setTypeName: cmnd_crc3_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 283  Token: ENUM              Lexeme: enum
Line: 283  Token: {  Lexeme: {
Line: 283  Token: IDENTIFIER        Lexeme: fciocb_assert_line_349
Line: 283  Token: =  Lexeme: =
Line: 283  Token: (  Lexeme: (
Line: 283  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 283  Token: (  Lexeme: (
Line: 283  Token: SIZEOF            Lexeme: sizeof
Line: 283  Token: (  Lexeme: (
Line: 283  Token: IDENTIFIER        Lexeme: cmnd_crc3_struct
 type_specifier -> TYPE_NAME
Line: 283  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 283  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 283  Token: (  Lexeme: (
Line: 283  Token: (  Lexeme: (
Line: 283  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 283  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 283  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 283  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 283  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 283  Token: (  Lexeme: (
Line: 283  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 283  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 283  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 283  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 283  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 283  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 283  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 283  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 283  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 287  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 287  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 287  Token: IDENTIFIER        Lexeme: sts0_iocb_s
Line: 287  Token: {  Lexeme: {
Line: 288  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 288  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 288  Token: IDENTIFIER        Lexeme: sts_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 288  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 289  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 289  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 289  Token: IDENTIFIER        Lexeme: sts_status
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 289  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 290  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 290  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 290  Token: IDENTIFIER        Lexeme: sts_oxid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 290  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 291  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 291  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 291  Token: IDENTIFIER        Lexeme: sts_fw_resid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 291  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 292  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 292  Token: {  Lexeme: {
Line: 293  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 293  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 293  Token: IDENTIFIER        Lexeme: sts_status_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 293  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 294  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 294  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 294  Token: IDENTIFIER        Lexeme: sts_fcp_rsp_pyld_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 294  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 295  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 295  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 296  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 296  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 296  Token: IDENTIFIER        Lexeme: sts_state_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 296  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 297  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 297  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 297  Token: IDENTIFIER        Lexeme: sts_retry_delay_timer
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 297  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 298  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 298  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 298  Token: IDENTIFIER        Lexeme: sts_scsi_status
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 298  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 299  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 299  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 299  Token: IDENTIFIER        Lexeme: sts_scsi_resid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 299  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 300  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 300  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 300  Token: IDENTIFIER        Lexeme: sts_sens_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 300  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 301  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 301  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 301  Token: IDENTIFIER        Lexeme: sts_rsp_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 301  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 302  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 302  Token: {  Lexeme: {
Line: 303  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 303  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 303  Token: IDENTIFIER        Lexeme: sts_rsp_sns_info
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 303  Token: [  Lexeme: [
Line: 303  Token: CONSTANT          Lexeme: 7
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 303  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 303  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 304  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 304  Token: {  Lexeme: {
Line: 305  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 305  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 305  Token: IDENTIFIER        Lexeme: sts_rsvd_0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 305  Token: [  Lexeme: [
Line: 305  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 305  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 305  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 306  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 306  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 306  Token: IDENTIFIER        Lexeme: sts_act_dif
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 306  Token: [  Lexeme: [
Line: 306  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 306  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 306  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 307  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 307  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 307  Token: IDENTIFIER        Lexeme: sts_exp_dif
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 307  Token: [  Lexeme: [
Line: 307  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 307  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 307  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 308  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 308  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 309  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 309  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 315  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 315  Token: IDENTIFIER        Lexeme: sts0_iocb_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 315  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: sts0_iocb_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: sts0_iocb_struct updated
setTypeName: sts0_iocb_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 316  Token: ENUM              Lexeme: enum
Line: 316  Token: {  Lexeme: {
Line: 316  Token: IDENTIFIER        Lexeme: fciocb_assert_line_382
Line: 316  Token: =  Lexeme: =
Line: 316  Token: (  Lexeme: (
Line: 316  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 316  Token: (  Lexeme: (
Line: 316  Token: SIZEOF            Lexeme: sizeof
Line: 316  Token: (  Lexeme: (
Line: 316  Token: IDENTIFIER        Lexeme: sts0_iocb_struct
 type_specifier -> TYPE_NAME
Line: 316  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 316  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 316  Token: (  Lexeme: (
Line: 316  Token: (  Lexeme: (
Line: 316  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 316  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 316  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 316  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 316  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 316  Token: (  Lexeme: (
Line: 316  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 316  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 316  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 316  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 316  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 316  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 316  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 316  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 316  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 320  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 320  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 320  Token: IDENTIFIER        Lexeme: tm_iocb_s
Line: 320  Token: {  Lexeme: {
Line: 321  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 321  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 321  Token: IDENTIFIER        Lexeme: scsi_tm_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 321  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 322  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 322  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 322  Token: IDENTIFIER        Lexeme: scsi_tm_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 322  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 323  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 323  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 323  Token: IDENTIFIER        Lexeme: scsi_tm_rsvd_0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 323  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 324  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 324  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 324  Token: IDENTIFIER        Lexeme: scsi_tm_delay
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 324  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 325  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 325  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 325  Token: IDENTIFIER        Lexeme: scsi_tm_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 325  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 326  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 326  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 326  Token: IDENTIFIER        Lexeme: scsi_tm_lun_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 326  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 327  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 327  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 327  Token: IDENTIFIER        Lexeme: scsi_tm_lun_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 327  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 328  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 328  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 328  Token: IDENTIFIER        Lexeme: scsi_tm_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 328  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 329  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 329  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 329  Token: IDENTIFIER        Lexeme: scsi_tm_rsvd_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 329  Token: [  Lexeme: [
Line: 329  Token: CONSTANT          Lexeme: 5
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 329  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 329  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 330  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 330  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 330  Token: IDENTIFIER        Lexeme: scsi_tm_target_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 330  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 330  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 330  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 331  Token: IDENTIFIER        Lexeme: cmnd_vp_index
 direct_declarator -> IDENTIFIER
Line: 331  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 331  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 331  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 332  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 332  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 332  Token: IDENTIFIER        Lexeme: scsi_tm_xvp_index
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 332  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 333  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 333  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 333  Token: IDENTIFIER        Lexeme: scsi_tm_rsvd_2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 333  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 334  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 334  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 334  Token: IDENTIFIER        Lexeme: scsi_tm_rsvd_3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 334  Token: [  Lexeme: [
Line: 334  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 334  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 334  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 335  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 335  Token: IDENTIFIER        Lexeme: tm_iocb_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 335  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: tm_iocb_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: tm_iocb_struct updated
setTypeName: tm_iocb_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 336  Token: ENUM              Lexeme: enum
Line: 336  Token: {  Lexeme: {
Line: 336  Token: IDENTIFIER        Lexeme: fciocb_assert_line_402
Line: 336  Token: =  Lexeme: =
Line: 336  Token: (  Lexeme: (
Line: 336  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 336  Token: (  Lexeme: (
Line: 336  Token: SIZEOF            Lexeme: sizeof
Line: 336  Token: (  Lexeme: (
Line: 336  Token: IDENTIFIER        Lexeme: tm_iocb_struct
 type_specifier -> TYPE_NAME
Line: 336  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 336  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 336  Token: (  Lexeme: (
Line: 336  Token: (  Lexeme: (
Line: 336  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 336  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 336  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 336  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 336  Token: (  Lexeme: (
Line: 336  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 336  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 336  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 336  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 336  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 340  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 340  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 340  Token: IDENTIFIER        Lexeme: marker_s
Line: 340  Token: {  Lexeme: {
Line: 341  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 341  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 341  Token: IDENTIFIER        Lexeme: mrkr_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 341  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 342  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 342  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 342  Token: IDENTIFIER        Lexeme: mrkr_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 342  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 343  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 343  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 343  Token: IDENTIFIER        Lexeme: mrkr_modfr
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 343  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 344  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 344  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 344  Token: IDENTIFIER        Lexeme: mrkr_rsvd_0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 344  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 345  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 345  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 345  Token: IDENTIFIER        Lexeme: mrkr_vp_index
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 345  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 346  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 346  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 346  Token: IDENTIFIER        Lexeme: mrkr_rsvd_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 346  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 347  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 347  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 347  Token: IDENTIFIER        Lexeme: mrkr_lun_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 347  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 348  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 348  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 348  Token: IDENTIFIER        Lexeme: mrkr_lun_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 348  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 349  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 349  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 349  Token: IDENTIFIER        Lexeme: mrkr_rsvd_2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 349  Token: [  Lexeme: [
Line: 349  Token: CONSTANT          Lexeme: 10
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 349  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 349  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 350  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 350  Token: IDENTIFIER        Lexeme: marker_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 350  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: marker_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: marker_struct updated
setTypeName: marker_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 351  Token: ENUM              Lexeme: enum
Line: 351  Token: {  Lexeme: {
Line: 351  Token: IDENTIFIER        Lexeme: fciocb_assert_line_417
Line: 351  Token: =  Lexeme: =
Line: 351  Token: (  Lexeme: (
Line: 351  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 351  Token: (  Lexeme: (
Line: 351  Token: SIZEOF            Lexeme: sizeof
Line: 351  Token: (  Lexeme: (
Line: 351  Token: IDENTIFIER        Lexeme: marker_struct
 type_specifier -> TYPE_NAME
Line: 351  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 351  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 351  Token: (  Lexeme: (
Line: 351  Token: (  Lexeme: (
Line: 351  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 351  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 351  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 351  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 351  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 351  Token: (  Lexeme: (
Line: 351  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 351  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 351  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 351  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 351  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 351  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 351  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 351  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 351  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 355  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 355  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 355  Token: IDENTIFIER        Lexeme: ctio7_s
Line: 355  Token: {  Lexeme: {
Line: 356  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 356  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 356  Token: IDENTIFIER        Lexeme: ctio_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 356  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 357  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 357  Token: {  Lexeme: {
Line: 358  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 358  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 358  Token: IDENTIFIER        Lexeme: ctio_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 358  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 359  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 359  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 359  Token: IDENTIFIER        Lexeme: ctio_status
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 359  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 360  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 360  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 361  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 361  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 361  Token: IDENTIFIER        Lexeme: ctio_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 361  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 362  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 362  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 362  Token: IDENTIFIER        Lexeme: ctio_seg_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 362  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 363  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 363  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 363  Token: IDENTIFIER        Lexeme: ctio_vp_index
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 363  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 364  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 364  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 364  Token: IDENTIFIER        Lexeme: ctio_add_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 364  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 365  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 365  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 365  Token: IDENTIFIER        Lexeme: ctio_init_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 365  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 365  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 365  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 366  Token: IDENTIFIER        Lexeme: ctio_rsvd_0
 direct_declarator -> IDENTIFIER
Line: 366  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 366  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 366  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 367  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 367  Token: IDENTIFIER        Lexeme: rcv_xchg_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 367  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 368  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 368  Token: {  Lexeme: {
Line: 369  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 369  Token: {  Lexeme: {
Line: 370  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 370  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 370  Token: IDENTIFIER        Lexeme: ctio_rsvd_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 370  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 371  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 371  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 371  Token: IDENTIFIER        Lexeme: ctio_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 371  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 372  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 372  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 372  Token: IDENTIFIER        Lexeme: ctio_rsvd_2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 372  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 373  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 373  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 373  Token: IDENTIFIER        Lexeme: ctio_oxid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 373  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 374  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 374  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 374  Token: IDENTIFIER        Lexeme: ctio_rsvd_3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 374  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 375  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 375  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 375  Token: IDENTIFIER        Lexeme: ctio_ro
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 375  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 376  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 376  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 376  Token: IDENTIFIER        Lexeme: ctio_rsvd_4
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 376  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 377  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 377  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 377  Token: IDENTIFIER        Lexeme: ctio_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 377  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 378  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 378  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 378  Token: IDENTIFIER        Lexeme: ctio_rsvd_5
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 378  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 379  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 379  Token: IDENTIFIER        Lexeme: ctio_dataseg0
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 379  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 380  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 380  Token: IDENTIFIER        Lexeme: mode0
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 380  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 381  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 381  Token: {  Lexeme: {
Line: 382  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 382  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 382  Token: IDENTIFIER        Lexeme: ctio_sns_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 382  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 383  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 383  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 383  Token: IDENTIFIER        Lexeme: ctio_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 383  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 384  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 384  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 384  Token: IDENTIFIER        Lexeme: ctio_resid_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 384  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 385  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 385  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 385  Token: IDENTIFIER        Lexeme: ctio_oxid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 385  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 386  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 386  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 386  Token: IDENTIFIER        Lexeme: ctio_scsi_sts
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 386  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 387  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 387  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 387  Token: IDENTIFIER        Lexeme: ctio_rsp_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 387  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 388  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 388  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 388  Token: IDENTIFIER        Lexeme: ctio_rsvd_3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 388  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 389  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 389  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 389  Token: IDENTIFIER        Lexeme: ctio_rsp_sns_info
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 389  Token: [  Lexeme: [
Line: 389  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 389  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 389  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 390  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 390  Token: IDENTIFIER        Lexeme: mode1
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 390  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 391  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 391  Token: {  Lexeme: {
Line: 392  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 392  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 392  Token: IDENTIFIER        Lexeme: ctio_rsvd_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 392  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 393  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 393  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 393  Token: IDENTIFIER        Lexeme: ctio_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 393  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 394  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 394  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 394  Token: IDENTIFIER        Lexeme: ctio_resid_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 394  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 395  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 395  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 395  Token: IDENTIFIER        Lexeme: ctio_oxid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 395  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 396  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 396  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 396  Token: IDENTIFIER        Lexeme: ctio_rsvd_2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 396  Token: [  Lexeme: [
Line: 396  Token: CONSTANT          Lexeme: 10
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 396  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 396  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 397  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 397  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 397  Token: IDENTIFIER        Lexeme: ctio_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 397  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 398  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 398  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 398  Token: IDENTIFIER        Lexeme: ctio_rsvd_3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 398  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 399  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 399  Token: IDENTIFIER        Lexeme: ctio_dataseg0
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 399  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 400  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 400  Token: IDENTIFIER        Lexeme: mode2
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 400  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 401  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 401  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 402  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 402  Token: IDENTIFIER        Lexeme: ctio7_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 402  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: ctio7_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: ctio7_struct updated
setTypeName: ctio7_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 403  Token: ENUM              Lexeme: enum
Line: 403  Token: {  Lexeme: {
Line: 403  Token: IDENTIFIER        Lexeme: fciocb_assert_line_469
Line: 403  Token: =  Lexeme: =
Line: 403  Token: (  Lexeme: (
Line: 403  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 403  Token: (  Lexeme: (
Line: 403  Token: SIZEOF            Lexeme: sizeof
Line: 403  Token: (  Lexeme: (
Line: 403  Token: IDENTIFIER        Lexeme: ctio7_struct
 type_specifier -> TYPE_NAME
Line: 403  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 403  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 403  Token: (  Lexeme: (
Line: 403  Token: (  Lexeme: (
Line: 403  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 403  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 403  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 403  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 403  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 403  Token: (  Lexeme: (
Line: 403  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 403  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 403  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 403  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 403  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 403  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 403  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 403  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 403  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 406  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 406  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 406  Token: IDENTIFIER        Lexeme: ctio_crc1_s
Line: 406  Token: {  Lexeme: {
Line: 407  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 407  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 407  Token: IDENTIFIER        Lexeme: ctio_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 407  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 408  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 408  Token: {  Lexeme: {
Line: 409  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 409  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 409  Token: IDENTIFIER        Lexeme: ctio_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 409  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 410  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 410  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 410  Token: IDENTIFIER        Lexeme: ctio_status
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 410  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 411  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 411  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 412  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 412  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 412  Token: IDENTIFIER        Lexeme: ctio_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 412  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 413  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 413  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 413  Token: IDENTIFIER        Lexeme: ctio_seg_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 413  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 414  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 414  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 414  Token: IDENTIFIER        Lexeme: ctio_vp_index
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 414  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 415  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 415  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 415  Token: IDENTIFIER        Lexeme: ctio_add_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 415  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 416  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 416  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 416  Token: IDENTIFIER        Lexeme: ctio_init_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 416  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 416  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 416  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 417  Token: IDENTIFIER        Lexeme: ctio_rsvd_0
 direct_declarator -> IDENTIFIER
Line: 417  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 417  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 417  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 418  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 418  Token: IDENTIFIER        Lexeme: rcv_xchg_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 418  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 420  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 420  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 420  Token: IDENTIFIER        Lexeme: ctio_rsvd_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 420  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 421  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 421  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 421  Token: IDENTIFIER        Lexeme: ctio_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 421  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 422  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 422  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 422  Token: IDENTIFIER        Lexeme: ctio_rsvd_2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 422  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 423  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 423  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 423  Token: IDENTIFIER        Lexeme: ctio_oxid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 423  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 424  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 424  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 424  Token: IDENTIFIER        Lexeme: ctio_rsvd_3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 424  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 425  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 425  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 425  Token: IDENTIFIER        Lexeme: ctio_ro
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 425  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 426  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 426  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 426  Token: IDENTIFIER        Lexeme: ctio_rsvd_4
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 426  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 427  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 427  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 427  Token: IDENTIFIER        Lexeme: ctio_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 427  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 428  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 428  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 428  Token: IDENTIFIER        Lexeme: ctio_rsvd_5
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 428  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 430  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 430  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 430  Token: IDENTIFIER        Lexeme: cmnd_ref_tag
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 430  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 431  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 431  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 431  Token: IDENTIFIER        Lexeme: cmnd_app_tag
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 431  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 432  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 432  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 432  Token: IDENTIFIER        Lexeme: cmnd_ref_mask_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 432  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 433  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 433  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 433  Token: IDENTIFIER        Lexeme: cmnd_ref_mask_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 433  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 434  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 434  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 434  Token: IDENTIFIER        Lexeme: cmnd_app_mask
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 434  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 436  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 436  Token: IDENTIFIER        Lexeme: ctio_crc1_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 436  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: ctio_crc1_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: ctio_crc1_struct updated
setTypeName: ctio_crc1_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 437  Token: ENUM              Lexeme: enum
Line: 437  Token: {  Lexeme: {
Line: 437  Token: IDENTIFIER        Lexeme: fciocb_assert_line_503
Line: 437  Token: =  Lexeme: =
Line: 437  Token: (  Lexeme: (
Line: 437  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 437  Token: (  Lexeme: (
Line: 437  Token: SIZEOF            Lexeme: sizeof
Line: 437  Token: (  Lexeme: (
Line: 437  Token: IDENTIFIER        Lexeme: ctio_crc1_struct
 type_specifier -> TYPE_NAME
Line: 437  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 437  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 437  Token: (  Lexeme: (
Line: 437  Token: (  Lexeme: (
Line: 437  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 437  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 437  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 437  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 437  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 437  Token: (  Lexeme: (
Line: 437  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 437  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 437  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 437  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 437  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 437  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 437  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 437  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 437  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 440  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 440  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 440  Token: IDENTIFIER        Lexeme: ctio_crc2_s
Line: 440  Token: {  Lexeme: {
Line: 441  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 441  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 441  Token: IDENTIFIER        Lexeme: ctio_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 441  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 442  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 442  Token: {  Lexeme: {
Line: 443  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 443  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 443  Token: IDENTIFIER        Lexeme: ctio_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 443  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 444  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 444  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 444  Token: IDENTIFIER        Lexeme: ctio_status
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 444  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 445  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 445  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 446  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 446  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 446  Token: IDENTIFIER        Lexeme: ctio_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 446  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 447  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 447  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 447  Token: IDENTIFIER        Lexeme: ctio_seg_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 447  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 448  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 448  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 448  Token: IDENTIFIER        Lexeme: ctio_vp_index
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 448  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 449  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 449  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 449  Token: IDENTIFIER        Lexeme: ctio_add_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 449  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 450  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 450  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 450  Token: IDENTIFIER        Lexeme: ctio_init_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 450  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 450  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 450  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 451  Token: IDENTIFIER        Lexeme: ctio_rsvd_0
 direct_declarator -> IDENTIFIER
Line: 451  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 451  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 451  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 452  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 452  Token: IDENTIFIER        Lexeme: rcv_xchg_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 452  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 454  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 454  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 454  Token: IDENTIFIER        Lexeme: ctio_rsvd_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 454  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 455  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 455  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 455  Token: IDENTIFIER        Lexeme: ctio_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 455  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 456  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 456  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 456  Token: IDENTIFIER        Lexeme: ctio_rsvd_2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 456  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 457  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 457  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 457  Token: IDENTIFIER        Lexeme: ctio_oxid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 457  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 458  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 458  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 458  Token: IDENTIFIER        Lexeme: ctio_rsvd_3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 458  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 459  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 459  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 459  Token: IDENTIFIER        Lexeme: ctio_ro
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 459  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 460  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 460  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 460  Token: IDENTIFIER        Lexeme: ctio_rsvd_4
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 460  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 461  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 461  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 461  Token: IDENTIFIER        Lexeme: ctio_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 461  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 462  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 462  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 462  Token: IDENTIFIER        Lexeme: ctio_rsvd_5
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 462  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 464  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 464  Token: IDENTIFIER        Lexeme: ctio_crc_ctx_dsd
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 464  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 466  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 466  Token: IDENTIFIER        Lexeme: ctio_crc2_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 466  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: ctio_crc2_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: ctio_crc2_struct updated
setTypeName: ctio_crc2_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 467  Token: ENUM              Lexeme: enum
Line: 467  Token: {  Lexeme: {
Line: 467  Token: IDENTIFIER        Lexeme: fciocb_assert_line_533
Line: 467  Token: =  Lexeme: =
Line: 467  Token: (  Lexeme: (
Line: 467  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 467  Token: (  Lexeme: (
Line: 467  Token: SIZEOF            Lexeme: sizeof
Line: 467  Token: (  Lexeme: (
Line: 467  Token: IDENTIFIER        Lexeme: ctio_crc2_struct
 type_specifier -> TYPE_NAME
Line: 467  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 467  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 467  Token: (  Lexeme: (
Line: 467  Token: (  Lexeme: (
Line: 467  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 467  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 467  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 467  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 467  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 467  Token: (  Lexeme: (
Line: 467  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 467  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 467  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 467  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 467  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 467  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 467  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 467  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 467  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 471  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 471  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 471  Token: IDENTIFIER        Lexeme: ctio_crc3_s
Line: 471  Token: {  Lexeme: {
Line: 472  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 472  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 472  Token: IDENTIFIER        Lexeme: ctio_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 472  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 473  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 473  Token: {  Lexeme: {
Line: 474  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 474  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 474  Token: IDENTIFIER        Lexeme: ctio_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 474  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 475  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 475  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 475  Token: IDENTIFIER        Lexeme: ctio_status
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 475  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 476  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 476  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 477  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 477  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 477  Token: IDENTIFIER        Lexeme: ctio_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 477  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 478  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 478  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 478  Token: IDENTIFIER        Lexeme: ctio_seg_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 478  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 479  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 479  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 479  Token: IDENTIFIER        Lexeme: ctio_vp_index
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 479  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 480  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 480  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 480  Token: IDENTIFIER        Lexeme: ctio_add_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 480  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 481  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 481  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 481  Token: IDENTIFIER        Lexeme: ctio_init_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 481  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 481  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 481  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 482  Token: IDENTIFIER        Lexeme: ctio_rsvd_0
 direct_declarator -> IDENTIFIER
Line: 482  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 482  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 482  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 483  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 483  Token: IDENTIFIER        Lexeme: rcv_xchg_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 483  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 485  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 485  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 485  Token: IDENTIFIER        Lexeme: ctio_rsvd_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 485  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 486  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 486  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 486  Token: IDENTIFIER        Lexeme: ctio_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 486  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 487  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 487  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 487  Token: IDENTIFIER        Lexeme: ctio_rsvd_2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 487  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 488  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 488  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 488  Token: IDENTIFIER        Lexeme: ctio_oxid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 488  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 489  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 489  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 489  Token: IDENTIFIER        Lexeme: ctio_rsvd_3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 489  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 490  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 490  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 490  Token: IDENTIFIER        Lexeme: ctio_ro
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 490  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 491  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 491  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 491  Token: IDENTIFIER        Lexeme: ctio_rsvd_4
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 491  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 492  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 492  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 492  Token: IDENTIFIER        Lexeme: ctio_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 492  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 493  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 493  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 493  Token: IDENTIFIER        Lexeme: ctio_rsvd_5
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 493  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 494  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 494  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 494  Token: IDENTIFIER        Lexeme: ctio_ref_tag0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 494  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 495  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 495  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 495  Token: IDENTIFIER        Lexeme: ctio_app_tag0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 495  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 497  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 497  Token: {  Lexeme: {
Line: 498  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 498  Token: {  Lexeme: {
Line: 499  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 499  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 499  Token: IDENTIFIER        Lexeme: ctio_rep_ref_tag0_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 499  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 500  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 500  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 500  Token: IDENTIFIER        Lexeme: ctio_rep_ref_tag0_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 500  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 501  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 501  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 501  Token: IDENTIFIER        Lexeme: ctio_rep_app_tag0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 501  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 502  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 502  Token: IDENTIFIER        Lexeme: vr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 502  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 503  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 503  Token: {  Lexeme: {
Line: 504  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 504  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 504  Token: IDENTIFIER        Lexeme: ctio_ref_mask0_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 504  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 505  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 505  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 505  Token: IDENTIFIER        Lexeme: ctio_ref_mask0_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 505  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 506  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 506  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 506  Token: IDENTIFIER        Lexeme: ctio_app_mask0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 506  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 507  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 507  Token: IDENTIFIER        Lexeme: nvr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 507  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 508  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 508  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 510  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 510  Token: IDENTIFIER        Lexeme: ctio_crc3_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 510  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: ctio_crc3_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: ctio_crc3_struct updated
setTypeName: ctio_crc3_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 511  Token: ENUM              Lexeme: enum
Line: 511  Token: {  Lexeme: {
Line: 511  Token: IDENTIFIER        Lexeme: fciocb_assert_line_577
Line: 511  Token: =  Lexeme: =
Line: 511  Token: (  Lexeme: (
Line: 511  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 511  Token: (  Lexeme: (
Line: 511  Token: SIZEOF            Lexeme: sizeof
Line: 511  Token: (  Lexeme: (
Line: 511  Token: IDENTIFIER        Lexeme: ctio_crc3_struct
 type_specifier -> TYPE_NAME
Line: 511  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 511  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 511  Token: (  Lexeme: (
Line: 511  Token: (  Lexeme: (
Line: 511  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 511  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 511  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 511  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 511  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 511  Token: (  Lexeme: (
Line: 511  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 511  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 511  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 511  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 511  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 511  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 511  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 511  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 511  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 514  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 514  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 514  Token: IDENTIFIER        Lexeme: ctio_crc4_s
Line: 514  Token: {  Lexeme: {
Line: 515  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 515  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 515  Token: IDENTIFIER        Lexeme: ctio_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 515  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 516  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 516  Token: {  Lexeme: {
Line: 517  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 517  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 517  Token: IDENTIFIER        Lexeme: ctio_target
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 517  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 518  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 518  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 518  Token: IDENTIFIER        Lexeme: ctio_status
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 518  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 519  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 519  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 520  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 520  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 520  Token: IDENTIFIER        Lexeme: ctio_timeout
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 520  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 521  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 521  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 521  Token: IDENTIFIER        Lexeme: ctio_seg_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 521  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 522  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 522  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 522  Token: IDENTIFIER        Lexeme: ctio_vp_index
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 522  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 523  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 523  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 523  Token: IDENTIFIER        Lexeme: ctio_add_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 523  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 524  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 524  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 524  Token: IDENTIFIER        Lexeme: ctio_init_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 524  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 524  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 524  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 525  Token: IDENTIFIER        Lexeme: ctio_rsvd_0
 direct_declarator -> IDENTIFIER
Line: 525  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 525  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 525  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 526  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 526  Token: IDENTIFIER        Lexeme: rcv_xchg_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 526  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 528  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 528  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 528  Token: IDENTIFIER        Lexeme: ctio_app_tag0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 528  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 529  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 529  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 529  Token: IDENTIFIER        Lexeme: ctio_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 529  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 530  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 530  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 530  Token: IDENTIFIER        Lexeme: ctio_ref_tag0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 530  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 531  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 531  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 531  Token: IDENTIFIER        Lexeme: ctio_oxid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 531  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 532  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 532  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 532  Token: IDENTIFIER        Lexeme: ctio_prot_opts
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 532  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 533  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 533  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 533  Token: IDENTIFIER        Lexeme: ctio_ro
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 533  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 534  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 534  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 534  Token: IDENTIFIER        Lexeme: ctio_guard_seed
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 534  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 535  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 535  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 535  Token: IDENTIFIER        Lexeme: ctio_rsvd_4
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 535  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 536  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 536  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 536  Token: IDENTIFIER        Lexeme: ctio_byte_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 536  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 537  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 537  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 537  Token: IDENTIFIER        Lexeme: ctio_tot_ptc
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 537  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 539  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 539  Token: IDENTIFIER        Lexeme: ctio_dataseg0
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 539  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 541  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 541  Token: IDENTIFIER        Lexeme: ctio_crc4_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 541  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: ctio_crc4_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: ctio_crc4_struct updated
setTypeName: ctio_crc4_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 542  Token: ENUM              Lexeme: enum
Line: 542  Token: {  Lexeme: {
Line: 542  Token: IDENTIFIER        Lexeme: fciocb_assert_line_608
Line: 542  Token: =  Lexeme: =
Line: 542  Token: (  Lexeme: (
Line: 542  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 542  Token: (  Lexeme: (
Line: 542  Token: SIZEOF            Lexeme: sizeof
Line: 542  Token: (  Lexeme: (
Line: 542  Token: IDENTIFIER        Lexeme: ctio_crc4_struct
 type_specifier -> TYPE_NAME
Line: 542  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 542  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 542  Token: (  Lexeme: (
Line: 542  Token: (  Lexeme: (
Line: 542  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 542  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 542  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 542  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 542  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 542  Token: (  Lexeme: (
Line: 542  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 542  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 542  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 542  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 542  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 542  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 542  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 542  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 542  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 547  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 547  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 547  Token: IDENTIFIER        Lexeme: fc_iocb_s
Line: 547  Token: {  Lexeme: {
Line: 548  Token: IDENTIFIER        Lexeme: fc_iocb_hdr_struct
 type_specifier -> TYPE_NAME
Line: 548  Token: IDENTIFIER        Lexeme: hdr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 548  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 549  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 549  Token: {  Lexeme: {
Line: 550  Token: IDENTIFIER        Lexeme: cont1_struct
 type_specifier -> TYPE_NAME
Line: 550  Token: IDENTIFIER        Lexeme: cont1
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 550  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 551  Token: IDENTIFIER        Lexeme: cont_crc1_struct
 type_specifier -> TYPE_NAME
Line: 551  Token: IDENTIFIER        Lexeme: cont_crc1
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 551  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 552  Token: IDENTIFIER        Lexeme: cmnd7_struct
 type_specifier -> TYPE_NAME
Line: 552  Token: IDENTIFIER        Lexeme: cmnd7
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 552  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 553  Token: IDENTIFIER        Lexeme: cmnd6_struct
 type_specifier -> TYPE_NAME
Line: 553  Token: IDENTIFIER        Lexeme: cmnd6
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 553  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 554  Token: IDENTIFIER        Lexeme: cmnd_crc1_struct
 type_specifier -> TYPE_NAME
Line: 554  Token: IDENTIFIER        Lexeme: cmnd_crc1
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 554  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 555  Token: IDENTIFIER        Lexeme: cmnd_crc2_struct
 type_specifier -> TYPE_NAME
Line: 555  Token: IDENTIFIER        Lexeme: cmnd_crc2
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 555  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 556  Token: IDENTIFIER        Lexeme: cmnd_crc3_struct
 type_specifier -> TYPE_NAME
Line: 556  Token: IDENTIFIER        Lexeme: cmnd_crc3
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 556  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 557  Token: IDENTIFIER        Lexeme: sts0_iocb_struct
 type_specifier -> TYPE_NAME
Line: 557  Token: IDENTIFIER        Lexeme: status0
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 557  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 558  Token: IDENTIFIER        Lexeme: tm_iocb_struct
 type_specifier -> TYPE_NAME
Line: 558  Token: IDENTIFIER        Lexeme: tskmgt
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 558  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 559  Token: IDENTIFIER        Lexeme: marker_struct
 type_specifier -> TYPE_NAME
Line: 559  Token: IDENTIFIER        Lexeme: marker
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 559  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 560  Token: IDENTIFIER        Lexeme: ctio7_struct
 type_specifier -> TYPE_NAME
Line: 560  Token: IDENTIFIER        Lexeme: ctio7
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 560  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 561  Token: IDENTIFIER        Lexeme: ctio_crc1_struct
 type_specifier -> TYPE_NAME
Line: 561  Token: IDENTIFIER        Lexeme: ctio_crc1
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 561  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 562  Token: IDENTIFIER        Lexeme: ctio_crc2_struct
 type_specifier -> TYPE_NAME
Line: 562  Token: IDENTIFIER        Lexeme: ctio_crc2
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 562  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 563  Token: IDENTIFIER        Lexeme: ctio_crc3_struct
 type_specifier -> TYPE_NAME
Line: 563  Token: IDENTIFIER        Lexeme: ctio_crc3
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 563  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 564  Token: IDENTIFIER        Lexeme: ctio_crc4_struct
 type_specifier -> TYPE_NAME
Line: 564  Token: IDENTIFIER        Lexeme: ctio_crc4
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 564  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 565  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 565  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 566  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 566  Token: IDENTIFIER        Lexeme: fc_iocb_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 566  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fc_iocb_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: fc_iocb_struct updated
setTypeName: fc_iocb_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 569  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 569  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 569  Token: IDENTIFIER        Lexeme: atio_s
Line: 569  Token: {  Lexeme: {
Line: 570  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 570  Token: {  Lexeme: {
Line: 571  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 571  Token: {  Lexeme: {
Line: 572  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 572  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 572  Token: IDENTIFIER        Lexeme: iocb_type
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 572  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 573  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 573  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 573  Token: IDENTIFIER        Lexeme: iocb_count
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 573  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 574  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 574  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 575  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 575  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 575  Token: IDENTIFIER        Lexeme: iocb_cnt_typ
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 575  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 576  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 576  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 577  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 577  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 577  Token: IDENTIFIER        Lexeme: atio_cmnd_len
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 577  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 577  Token: CONSTANT          Lexeme: 12
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 577  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 578  Token: IDENTIFIER        Lexeme: atio_attr
 direct_declarator -> IDENTIFIER
Line: 578  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 578  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 578  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 579  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 579  Token: IDENTIFIER        Lexeme: rcv_xchg_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 579  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 580  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 580  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 580  Token: IDENTIFIER        Lexeme: atio_frame_hdr
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 580  Token: [  Lexeme: [
Line: 580  Token: CONSTANT          Lexeme: 6
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 580  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 580  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 581  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 581  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 581  Token: IDENTIFIER        Lexeme: atio_payload
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 581  Token: [  Lexeme: [
Line: 581  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 581  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 581  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 582  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 582  Token: IDENTIFIER        Lexeme: atio_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 582  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: atio_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: atio_struct updated
setTypeName: atio_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 583  Token: ENUM              Lexeme: enum
Line: 583  Token: {  Lexeme: {
Line: 583  Token: IDENTIFIER        Lexeme: fciocb_assert_line_649
Line: 583  Token: =  Lexeme: =
Line: 583  Token: (  Lexeme: (
Line: 583  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 583  Token: (  Lexeme: (
Line: 583  Token: SIZEOF            Lexeme: sizeof
Line: 583  Token: (  Lexeme: (
Line: 583  Token: IDENTIFIER        Lexeme: atio_struct
 type_specifier -> TYPE_NAME
Line: 583  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 583  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 583  Token: (  Lexeme: (
Line: 583  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 583  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 583  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 583  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 583  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 583  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 583  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 583  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 587  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 587  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 587  Token: IDENTIFIER        Lexeme: fc_fw_def_s
Line: 587  Token: {  Lexeme: {
Line: 588  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 588  Token: {  Lexeme: {
Line: 589  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 589  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 589  Token: IDENTIFIER        Lexeme: tbd_scratch
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 589  Token: [  Lexeme: [
Line: 589  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 589  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 589  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 590  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 590  Token: {  Lexeme: {
Line: 591  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 591  Token: IDENTIFIER        Lexeme: t10_crc_cntxt
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 591  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 592  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 592  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 592  Token: IDENTIFIER        Lexeme: rsvd
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 592  Token: [  Lexeme: [
Line: 592  Token: CONSTANT          Lexeme: 15
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 592  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 592  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 593  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 593  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 595  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 595  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 599  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 599  Token: IDENTIFIER        Lexeme: fc_fw_def_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 599  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fc_fw_def_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: fc_fw_def_struct updated
setTypeName: fc_fw_def_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 600  Token: ENUM              Lexeme: enum
Line: 600  Token: {  Lexeme: {
Line: 600  Token: IDENTIFIER        Lexeme: fciocb_assert_line_666
Line: 600  Token: =  Lexeme: =
Line: 600  Token: (  Lexeme: (
Line: 600  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 600  Token: (  Lexeme: (
Line: 600  Token: SIZEOF            Lexeme: sizeof
Line: 600  Token: (  Lexeme: (
Line: 600  Token: IDENTIFIER        Lexeme: fc_fw_def_struct
 type_specifier -> TYPE_NAME
Line: 600  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 600  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 600  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 600  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 600  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 600  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 600  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 603  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 603  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 603  Token: IDENTIFIER        Lexeme: disk_crc_ctxt_s
Line: 603  Token: {  Lexeme: {
Line: 604  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 604  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 604  Token: IDENTIFIER        Lexeme: io_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 604  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 605  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 605  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 605  Token: IDENTIFIER        Lexeme: ref_tag
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 605  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 606  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 606  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 606  Token: IDENTIFIER        Lexeme: app_tag
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 606  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 607  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 607  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 607  Token: IDENTIFIER        Lexeme: ref_mask_l
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 607  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 609  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 609  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 609  Token: IDENTIFIER        Lexeme: ref_mask_h
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 609  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 610  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 610  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 610  Token: IDENTIFIER        Lexeme: app_mask
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 610  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 612  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 612  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 612  Token: IDENTIFIER        Lexeme: guard_seed
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 612  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 613  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 613  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 613  Token: IDENTIFIER        Lexeme: prot_opts
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 613  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 615  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 615  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 615  Token: IDENTIFIER        Lexeme: block_sz
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 615  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 616  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 616  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 616  Token: IDENTIFIER        Lexeme: runt_guard
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 616  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 618  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 618  Token: {  Lexeme: {
Line: 619  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 619  Token: {  Lexeme: {
Line: 620  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 620  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 620  Token: IDENTIFIER        Lexeme: ndb_tot_pxc
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 620  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 621  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 621  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 621  Token: IDENTIFIER        Lexeme: rsvd_0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 621  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 622  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 622  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 622  Token: IDENTIFIER        Lexeme: rsvd_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 622  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 623  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 623  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 623  Token: IDENTIFIER        Lexeme: rsvd_2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 623  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 624  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 624  Token: IDENTIFIER        Lexeme: data_dsd
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 624  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 625  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 625  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 625  Token: IDENTIFIER        Lexeme: rsvd_3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 625  Token: [  Lexeme: [
Line: 625  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 625  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 625  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 626  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 626  Token: IDENTIFIER        Lexeme: non_db
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 626  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 627  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 627  Token: {  Lexeme: {
Line: 628  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 628  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 628  Token: IDENTIFIER        Lexeme: db_data_pxc
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 628  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 629  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 629  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 629  Token: IDENTIFIER        Lexeme: db_dif_pxc
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 629  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 630  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 630  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 630  Token: IDENTIFIER        Lexeme: rsvd_1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 630  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 631  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 631  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 631  Token: IDENTIFIER        Lexeme: blk_dsd_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 631  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 632  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 632  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 632  Token: IDENTIFIER        Lexeme: rsvd_2
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 632  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 633  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 633  Token: IDENTIFIER        Lexeme: data_dsd
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 633  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 634  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 634  Token: IDENTIFIER        Lexeme: dif_dsd
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 634  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 635  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 635  Token: IDENTIFIER        Lexeme: db
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 635  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 636  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 636  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 637  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 637  Token: IDENTIFIER        Lexeme: dcrc_ctxt_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 637  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dcrc_ctxt_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: dcrc_ctxt_struct updated
setTypeName: dcrc_ctxt_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 642  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 642  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 642  Token: {  Lexeme: {
Line: 643  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 643  Token: {  Lexeme: {
Line: 644  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 644  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 644  Token: IDENTIFIER        Lexeme: gen_iocb
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 644  Token: [  Lexeme: [
Line: 644  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 644  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 644  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 645  Token: IDENTIFIER        Lexeme: fc_iocb_struct
 type_specifier -> TYPE_NAME
Line: 645  Token: IDENTIFIER        Lexeme: fc_iocb
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 645  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 648  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 648  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 649  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 649  Token: {  Lexeme: {
Line: 650  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 650  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 650  Token: IDENTIFIER        Lexeme: gen_def
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 650  Token: [  Lexeme: [
Line: 650  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 650  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 650  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 651  Token: IDENTIFIER        Lexeme: fc_fw_def_struct
 type_specifier -> TYPE_NAME
Line: 651  Token: IDENTIFIER        Lexeme: fc_fw_def
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 651  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 653  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 653  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 656  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 656  Token: {  Lexeme: {
Line: 658  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 658  Token: {  Lexeme: {
Line: 659  Token: IDENTIFIER        Lexeme: alcb_struct
 type_specifier -> TYPE_NAME
Line: 659  Token: IDENTIFIER        Lexeme: lo_alcb
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 659  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 660  Token: IDENTIFIER        Lexeme: alcb_struct
 type_specifier -> TYPE_NAME
Line: 660  Token: IDENTIFIER        Lexeme: hi_alcb
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 660  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 661  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 661  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 661  Token: IDENTIFIER        Lexeme: hdr_digest
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 661  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 662  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 662  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 662  Token: IDENTIFIER        Lexeme: data_digest
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 662  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 663  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 663  Token: IDENTIFIER        Lexeme: t10_ctx
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 663  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 664  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 664  Token: {  Lexeme: {
Line: 665  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 665  Token: IDENTIFIER        Lexeme: dsd
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 665  Token: [  Lexeme: [
Line: 665  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 665  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 665  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 666  Token: IDENTIFIER        Lexeme: skp_msk_dsd_struct
 type_specifier -> TYPE_NAME
Line: 666  Token: IDENTIFIER        Lexeme: sm_dsd
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 666  Token: [  Lexeme: [
Line: 666  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 666  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 666  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 667  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 667  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 667  Token: IDENTIFIER        Lexeme: fill
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 667  Token: [  Lexeme: [
Line: 667  Token: CONSTANT          Lexeme: 12
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 667  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 667  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 668  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 668  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 669  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 669  Token: IDENTIFIER        Lexeme: nxt_crp_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 669  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 670  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 670  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 671  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 671  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 671  Token: IDENTIFIER        Lexeme: misc_data
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 671  Token: [  Lexeme: [
Line: 671  Token: CONSTANT          Lexeme: 32
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 671  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 671  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 672  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 672  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 672  Token: IDENTIFIER        Lexeme: scratch
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 672  Token: [  Lexeme: [
Line: 672  Token: CONSTANT          Lexeme: 128
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 672  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 672  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 673  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 673  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 674  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 674  Token: IDENTIFIER        Lexeme: drp_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 674  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: drp_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: drp_struct updated
setTypeName: drp_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 677  Token: ENUM              Lexeme: enum
Line: 677  Token: {  Lexeme: {
Line: 677  Token: IDENTIFIER        Lexeme: fciocb_assert_line_87
Line: 677  Token: =  Lexeme: =
Line: 677  Token: (  Lexeme: (
Line: 677  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 677  Token: (  Lexeme: (
Line: 677  Token: SIZEOF            Lexeme: sizeof
Line: 677  Token: (  Lexeme: (
Line: 677  Token: IDENTIFIER        Lexeme: drp_struct
 type_specifier -> TYPE_NAME
Line: 677  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 677  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 677  Token: (  Lexeme: (
Line: 677  Token: CONSTANT          Lexeme: 256
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 677  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 677  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 677  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 677  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 677  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 677  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 677  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 683  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 683  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 683  Token: {  Lexeme: {
Line: 684  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 684  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 684  Token: IDENTIFIER        Lexeme: vld_flags_9To0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 684  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 685  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 685  Token: IDENTIFIER        Lexeme: dsd_list_0
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 685  Token: [  Lexeme: [
Line: 685  Token: CONSTANT          Lexeme: 10
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 685  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 685  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 686  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 686  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 686  Token: IDENTIFIER        Lexeme: rsvd1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 686  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 687  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 687  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 687  Token: IDENTIFIER        Lexeme: vld_flags_19to10
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 687  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 688  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 688  Token: IDENTIFIER        Lexeme: dsd_list_1
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 688  Token: [  Lexeme: [
Line: 688  Token: CONSTANT          Lexeme: 10
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 688  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 688  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 689  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 689  Token: IDENTIFIER        Lexeme: nxt_crp_ptr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 689  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 690  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 690  Token: IDENTIFIER        Lexeme: crp_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 690  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: crp_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: crp_struct updated
setTypeName: crp_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 693  Token: ENUM              Lexeme: enum
Line: 693  Token: {  Lexeme: {
Line: 693  Token: IDENTIFIER        Lexeme: fciocb_assert_line_103
Line: 693  Token: =  Lexeme: =
Line: 693  Token: (  Lexeme: (
Line: 693  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 693  Token: (  Lexeme: (
Line: 693  Token: SIZEOF            Lexeme: sizeof
Line: 693  Token: (  Lexeme: (
Line: 693  Token: IDENTIFIER        Lexeme: crp_struct
 type_specifier -> TYPE_NAME
Line: 693  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 693  Token: NE_OP             Lexeme: !=
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 693  Token: (  Lexeme: (
Line: 693  Token: CONSTANT          Lexeme: 256
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 693  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 693  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 693  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 693  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 693  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 693  Token: }  Lexeme: }
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 enumerator -> IDENTIFIER '=' constant_expression
 enumerator_list -> enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 693  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 697  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 697  Token: ENUM              Lexeme: enum
Line: 697  Token: IDENTIFIER        Lexeme: _dmaType
Line: 697  Token: {  Lexeme: {
Line: 698  Token: IDENTIFIER        Lexeme: DMA_TYPE_MIM
Line: 698  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator
Line: 699  Token: IDENTIFIER        Lexeme: DMA_TYPE_MQS
Line: 699  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 700  Token: IDENTIFIER        Lexeme: DMA_TYPE_DSD
Line: 700  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 701  Token: IDENTIFIER        Lexeme: DMA_TYPE_CRC_CNTXT
Line: 701  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 702  Token: IDENTIFIER        Lexeme: DMA_TYPE_SWQE
Line: 702  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 703  Token: IDENTIFIER        Lexeme: DMA_TYPE_ROCE_CONTEXT
Line: 704  Token: }  Lexeme: }
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
setTypeName: _dmaType updated
 enum_specifier -> ENUM IDENTIFIER '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 704  Token: IDENTIFIER        Lexeme: dmaType
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 704  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dmaType added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: dmaType updated
setTypeName: dmaType updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 706  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 706  Token: ENUM              Lexeme: enum
Line: 706  Token: IDENTIFIER        Lexeme: _protType
Line: 706  Token: {  Lexeme: {
Line: 707  Token: IDENTIFIER        Lexeme: PROT_HQP
Line: 707  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator
Line: 708  Token: IDENTIFIER        Lexeme: PROT_ROCE
Line: 709  Token: }  Lexeme: }
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
setTypeName: _protType updated
 enum_specifier -> ENUM IDENTIFIER '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 709  Token: IDENTIFIER        Lexeme: protType
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 709  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: protType added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: protType updated
setTypeName: protType updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 711  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 711  Token: IDENTIFIER        Lexeme: _dmaQue
Line: 711  Token: ;  Lexeme: ;
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 712  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 712  Token: IDENTIFIER        Lexeme: _hqpCb
Line: 712  Token: ;  Lexeme: ;
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 716  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 716  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 716  Token: IDENTIFIER        Lexeme: _dmaCB
Line: 716  Token: {  Lexeme: {
Line: 717  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 717  Token: IDENTIFIER        Lexeme: _dmaCB
Line: 717  Token: *  Lexeme: *
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 specifier_qualifier_list -> type_specifier
Line: 717  Token: IDENTIFIER        Lexeme: next
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 717  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 719  Token: IDENTIFIER        Lexeme: dmaType
 type_specifier -> TYPE_NAME
Line: 719  Token: IDENTIFIER        Lexeme: type
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 719  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 720  Token: IDENTIFIER        Lexeme: protType
 type_specifier -> TYPE_NAME
Line: 720  Token: IDENTIFIER        Lexeme: protocol
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 720  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 721  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 721  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 721  Token: IDENTIFIER        Lexeme: hqpId
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 721  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 722  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 722  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 722  Token: IDENTIFIER        Lexeme: hdwReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 722  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 723  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 723  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 723  Token: IDENTIFIER        Lexeme: adrh
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 723  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 724  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 724  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 724  Token: IDENTIFIER        Lexeme: adrl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 724  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 725  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 725  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 725  Token: IDENTIFIER        Lexeme: region
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 725  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 726  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 726  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 726  Token: IDENTIFIER        Lexeme: length
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 726  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 727  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 727  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 727  Token: IDENTIFIER        Lexeme: spBufAdr
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 727  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 728  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 728  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 728  Token: IDENTIFIER        Lexeme: result
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 728  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 729  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 729  Token: IDENTIFIER        Lexeme: dmaCb
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 729  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dmaCb added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: dmaCb updated
setTypeName: dmaCb updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 735  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 735  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 735  Token: IDENTIFIER        Lexeme: _dmaQue
Line: 735  Token: {  Lexeme: {
Line: 736  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 736  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 736  Token: IDENTIFIER        Lexeme: head
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 736  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 737  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 737  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 737  Token: IDENTIFIER        Lexeme: tail
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 737  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 738  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 738  Token: IDENTIFIER        Lexeme: dmaQue
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 738  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dmaQue added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: dmaQue updated
setTypeName: dmaQue updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 744  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 744  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 744  Token: IDENTIFIER        Lexeme: _Qobj
Line: 744  Token: {  Lexeme: {
Line: 745  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 745  Token: IDENTIFIER        Lexeme: _Qobj
Line: 745  Token: *  Lexeme: *
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 specifier_qualifier_list -> type_specifier
Line: 745  Token: IDENTIFIER        Lexeme: next
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 745  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 746  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 746  Token: IDENTIFIER        Lexeme: Qobj
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 746  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: Qobj added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: Qobj updated
setTypeName: Qobj updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 752  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 752  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 752  Token: IDENTIFIER        Lexeme: _Que
Line: 752  Token: {  Lexeme: {
Line: 753  Token: IDENTIFIER        Lexeme: Qobj
 type_specifier -> TYPE_NAME
Line: 753  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 753  Token: IDENTIFIER        Lexeme: head
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 753  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 754  Token: IDENTIFIER        Lexeme: Qobj
 type_specifier -> TYPE_NAME
Line: 754  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 754  Token: IDENTIFIER        Lexeme: tail
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 754  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 755  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 755  Token: IDENTIFIER        Lexeme: Que
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 755  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: Que added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: Que updated
setTypeName: Que updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 761  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 761  Token: ENUM              Lexeme: enum
Line: 761  Token: IDENTIFIER        Lexeme: _hqpState
Line: 761  Token: {  Lexeme: {
Line: 762  Token: IDENTIFIER        Lexeme: HQP_STATE_INACTIVE
Line: 762  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator
Line: 763  Token: IDENTIFIER        Lexeme: HQP_STATE_SLOW_PATH_REQ
Line: 763  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 764  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_HQP_CNTXT_DMA
Line: 764  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 765  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_DRPCRP_DESC
Line: 765  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 766  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_DMACB
Line: 766  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 767  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_SQ_CNTXT_DMA
Line: 767  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 768  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_IOCB_BLK
Line: 768  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 769  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_DMA
Line: 769  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 770  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_LPTR_DMA
Line: 770  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 771  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_MIM_BLK_ALLOC
Line: 771  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 772  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_MIM_DMA
Line: 772  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 773  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_MQS_DMA
Line: 773  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 774  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_CRC_CNTXT_DMA
Line: 774  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 775  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_CRC_DIF_DMA
Line: 775  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 776  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DIF_LPTR_DMA
Line: 776  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 777  Token: IDENTIFIER        Lexeme: HQP_STATE_PROC_IOCB
Line: 778  Token: }  Lexeme: }
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
setTypeName: _hqpState updated
 enum_specifier -> ENUM IDENTIFIER '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 778  Token: IDENTIFIER        Lexeme: hqpState
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 778  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpState added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: hqpState updated
setTypeName: hqpState updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 784  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 784  Token: IDENTIFIER        Lexeme: _bufDesc
Line: 784  Token: ;  Lexeme: ;
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 791  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 791  Token: IDENTIFIER        Lexeme: _hqpCb
Line: 791  Token: {  Lexeme: {
Line: 792  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 792  Token: IDENTIFIER        Lexeme: _hqpCb
Line: 792  Token: *  Lexeme: *
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 specifier_qualifier_list -> type_specifier
Line: 792  Token: IDENTIFIER        Lexeme: next
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 792  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 794  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 794  Token: IDENTIFIER        Lexeme: _bufDesc
Line: 794  Token: *  Lexeme: *
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 specifier_qualifier_list -> type_specifier
Line: 794  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 794  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 795  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 795  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 795  Token: IDENTIFIER        Lexeme: pDmaCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 795  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 796  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 796  Token: IDENTIFIER        Lexeme: _bufDesc
Line: 796  Token: *  Lexeme: *
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 specifier_qualifier_list -> type_specifier
Line: 796  Token: IDENTIFIER        Lexeme: pDrp
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 796  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 797  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 797  Token: IDENTIFIER        Lexeme: _bufDesc
Line: 797  Token: *  Lexeme: *
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 specifier_qualifier_list -> type_specifier
Line: 797  Token: IDENTIFIER        Lexeme: pCrp
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 797  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 798  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 798  Token: IDENTIFIER        Lexeme: _bufDesc
Line: 798  Token: *  Lexeme: *
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 specifier_qualifier_list -> type_specifier
Line: 798  Token: IDENTIFIER        Lexeme: pT10Cntxt
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 798  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 799  Token: IDENTIFIER        Lexeme: fc_iocb_struct
 type_specifier -> TYPE_NAME
Line: 799  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 799  Token: IDENTIFIER        Lexeme: pCurIocb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 799  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 800  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 800  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 800  Token: IDENTIFIER        Lexeme: pBuf
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 800  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 802  Token: IDENTIFIER        Lexeme: hqpState
 type_specifier -> TYPE_NAME
Line: 802  Token: IDENTIFIER        Lexeme: state
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 802  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 803  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 803  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 803  Token: IDENTIFIER        Lexeme: numIocbProcessed
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 803  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 806  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 806  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 806  Token: IDENTIFIER        Lexeme: dsdIndxInBuf
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 806  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 808  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 808  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 808  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 808  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 809  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 809  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 809  Token: IDENTIFIER        Lexeme: iocbIndx
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 809  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 810  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 810  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 810  Token: IDENTIFIER        Lexeme: flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 810  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 811  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 811  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 811  Token: IDENTIFIER        Lexeme: rsvd
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 811  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 812  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 812  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 812  Token: IDENTIFIER        Lexeme: iocbCount
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 812  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 813  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 813  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 813  Token: IDENTIFIER        Lexeme: dsdCount
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 813  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 814  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 814  Token: ATTRIBUTE         Lexeme: __attribute__
 declaration_specifiers -> type_specifier
 attribute_specifier -> ATTRIBUTE
Line: 814  Token: (  Lexeme: (
Line: 814  Token: (  Lexeme: (
Line: 814  Token: IDENTIFIER        Lexeme: packed
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 814  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
Line: 814  Token: COMPLEX           Lexeme: )
 attribute_specifier '(' primary_expression ')' 
Line: 814  Token: ;  Lexeme: ;
 declaration -> declaration_specifiers attribute_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 816  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 816  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 816  Token: IDENTIFIER        Lexeme: _hqpCb
Line: 816  Token: IDENTIFIER        Lexeme: hqpCb
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 816  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpCb added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: hqpCb updated
setTypeName: hqpCb updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 818  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 818  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 818  Token: IDENTIFIER        Lexeme: _hqpQue
Line: 818  Token: {  Lexeme: {
Line: 819  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 819  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 819  Token: IDENTIFIER        Lexeme: head
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 819  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 820  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 820  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 820  Token: IDENTIFIER        Lexeme: tail
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 820  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 821  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 821  Token: IDENTIFIER        Lexeme: hqpQue
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 821  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpQue added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: hqpQue updated
setTypeName: hqpQue updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 828  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 828  Token: IDENTIFIER        Lexeme: _hqpCntxtEntry
Line: 828  Token: {  Lexeme: {
Line: 829  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 829  Token: {  Lexeme: {
Line: 830  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 830  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 830  Token: IDENTIFIER        Lexeme: hqpCntxtW1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 830  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 831  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 831  Token: {  Lexeme: {
Line: 832  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 832  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 832  Token: IDENTIFIER        Lexeme: vpid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 832  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 832  Token: CONSTANT          Lexeme: 10
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 832  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 833  Token: IDENTIFIER        Lexeme: port
 direct_declarator -> IDENTIFIER
Line: 833  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 833  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 833  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 834  Token: IDENTIFIER        Lexeme: type
 direct_declarator -> IDENTIFIER
Line: 834  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 834  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 834  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 835  Token: IDENTIFIER        Lexeme: iocbRegion
 direct_declarator -> IDENTIFIER
Line: 835  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 835  Token: CONSTANT          Lexeme: 6
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 835  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 836  Token: IDENTIFIER        Lexeme: cntxtRegion
 direct_declarator -> IDENTIFIER
Line: 836  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 836  Token: CONSTANT          Lexeme: 6
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 836  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 837  Token: IDENTIFIER        Lexeme: cntxtSize
 direct_declarator -> IDENTIFIER
Line: 837  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 837  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 837  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 838  Token: IDENTIFIER        Lexeme: valid
 direct_declarator -> IDENTIFIER
Line: 838  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 838  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 838  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 839  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 839  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 840  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 840  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 841  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 841  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 841  Token: IDENTIFIER        Lexeme: mqsL1q
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 841  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 842  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 842  Token: ATTRIBUTE         Lexeme: __attribute__
 declaration_specifiers -> type_specifier
 attribute_specifier -> ATTRIBUTE
Line: 842  Token: (  Lexeme: (
Line: 842  Token: (  Lexeme: (
Line: 842  Token: IDENTIFIER        Lexeme: packed
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 842  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
Line: 842  Token: COMPLEX           Lexeme: )
 attribute_specifier '(' primary_expression ')' 
Line: 842  Token: ;  Lexeme: ;
 declaration -> declaration_specifiers attribute_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 845  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 845  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 845  Token: IDENTIFIER        Lexeme: _hqpCntxtEntry
Line: 845  Token: IDENTIFIER        Lexeme: hqpCntxtEntry
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 845  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpCntxtEntry added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: hqpCntxtEntry updated
setTypeName: hqpCntxtEntry updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 847  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 847  Token: IDENTIFIER        Lexeme: _hqmHqpCntxt
Line: 847  Token: {  Lexeme: {
Line: 850  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 850  Token: {  Lexeme: {
Line: 851  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 851  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 851  Token: IDENTIFIER        Lexeme: hqpCntxtRq0
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 851  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 852  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 852  Token: {  Lexeme: {
Line: 853  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 853  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 853  Token: IDENTIFIER        Lexeme: vpid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 853  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 853  Token: CONSTANT          Lexeme: 10
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 853  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 854  Token: IDENTIFIER        Lexeme: rq0rsvd0
 direct_declarator -> IDENTIFIER
Line: 854  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 854  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 854  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 855  Token: IDENTIFIER        Lexeme: dici
 direct_declarator -> IDENTIFIER
Line: 855  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 855  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 855  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 856  Token: IDENTIFIER        Lexeme: port
 direct_declarator -> IDENTIFIER
Line: 856  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 856  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 856  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 857  Token: IDENTIFIER        Lexeme: rq0rsvd
 direct_declarator -> IDENTIFIER
Line: 857  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 857  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 857  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 858  Token: IDENTIFIER        Lexeme: duci
 direct_declarator -> IDENTIFIER
Line: 858  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 858  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 858  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 859  Token: IDENTIFIER        Lexeme: rq0rsvd2
 direct_declarator -> IDENTIFIER
Line: 859  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 859  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 859  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 860  Token: IDENTIFIER        Lexeme: type
 direct_declarator -> IDENTIFIER
Line: 860  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 860  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 860  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 861  Token: IDENTIFIER        Lexeme: iocbRegion
 direct_declarator -> IDENTIFIER
Line: 861  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 861  Token: CONSTANT          Lexeme: 6
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 861  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 862  Token: IDENTIFIER        Lexeme: state
 direct_declarator -> IDENTIFIER
Line: 862  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 862  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 862  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 863  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 863  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 864  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 864  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 865  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 865  Token: {  Lexeme: {
Line: 866  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 866  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 866  Token: IDENTIFIER        Lexeme: hqpCntxtRq1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 866  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 867  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 867  Token: {  Lexeme: {
Line: 868  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 868  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 868  Token: IDENTIFIER        Lexeme: mqsL1Que
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 868  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 868  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 868  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 869  Token: IDENTIFIER        Lexeme: cntxtRegion
 direct_declarator -> IDENTIFIER
Line: 869  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 869  Token: CONSTANT          Lexeme: 6
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 869  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 870  Token: IDENTIFIER        Lexeme: cntxtSize
 direct_declarator -> IDENTIFIER
Line: 870  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 870  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 870  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 871  Token: IDENTIFIER        Lexeme: rq1rsvd0
 direct_declarator -> IDENTIFIER
Line: 871  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 871  Token: CONSTANT          Lexeme: 7
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 871  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 872  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 872  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 873  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 873  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 874  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 874  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 874  Token: IDENTIFIER        Lexeme: hqpCntxtRqConsIndxBits
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 874  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 875  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 875  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 875  Token: IDENTIFIER        Lexeme: hqpCntxtRqBaseAddrBits
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 875  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 876  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 876  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 876  Token: IDENTIFIER        Lexeme: hqpCntxtRqConsIndxAdrl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 876  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 877  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 877  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 877  Token: IDENTIFIER        Lexeme: hqpCntxtRqConsIndxAdrh
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 877  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 878  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 878  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 878  Token: IDENTIFIER        Lexeme: hqpCntxtRqBaseAdrl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 878  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 879  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 879  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 879  Token: IDENTIFIER        Lexeme: hqpCntxtRqBaseAdrh
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 879  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 880  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 880  Token: {  Lexeme: {
Line: 881  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 881  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 881  Token: IDENTIFIER        Lexeme: hqpCntxtRq7
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 881  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 882  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 882  Token: {  Lexeme: {
Line: 883  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 883  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 883  Token: IDENTIFIER        Lexeme: rqQueLength
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 883  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 883  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 883  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 884  Token: IDENTIFIER        Lexeme: rqes
 direct_declarator -> IDENTIFIER
Line: 884  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 884  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 884  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 885  Token: IDENTIFIER        Lexeme: hostPageSize
 direct_declarator -> IDENTIFIER
Line: 885  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 885  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 885  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 886  Token: IDENTIFIER        Lexeme: rmc
 direct_declarator -> IDENTIFIER
Line: 886  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 886  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 886  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 887  Token: IDENTIFIER        Lexeme: rq7rsvd0
 direct_declarator -> IDENTIFIER
Line: 887  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 887  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 887  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 888  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 888  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 889  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 889  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 892  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 892  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 892  Token: IDENTIFIER        Lexeme: hqpCntxtRp00
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 892  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 893  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 893  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 893  Token: IDENTIFIER        Lexeme: hqpCntxtRp01
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 893  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 894  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 894  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 894  Token: IDENTIFIER        Lexeme: hqpCntxtRp0ConsIndxBits
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 894  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 895  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 895  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 895  Token: IDENTIFIER        Lexeme: hqpCntxtRp0BaseAddrBits
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 895  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 896  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 896  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 896  Token: IDENTIFIER        Lexeme: hqpCntxtRp0ConsIndxAdrl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 896  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 897  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 897  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 897  Token: IDENTIFIER        Lexeme: hqpCntxtRp0ConsIndxAdrh
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 897  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 898  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 898  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 898  Token: IDENTIFIER        Lexeme: hqpCntxtRp0BaseAdrl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 898  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 899  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 899  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 899  Token: IDENTIFIER        Lexeme: hqpCntxtRp0BaseAdrh
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 899  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 900  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 900  Token: {  Lexeme: {
Line: 901  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 901  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 901  Token: IDENTIFIER        Lexeme: hqpCntxtRp07
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 901  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 902  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 902  Token: {  Lexeme: {
Line: 903  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 903  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 903  Token: IDENTIFIER        Lexeme: rp0QueLength
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 903  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 903  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 903  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 904  Token: IDENTIFIER        Lexeme: rpe0
 direct_declarator -> IDENTIFIER
Line: 904  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 904  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 904  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 905  Token: IDENTIFIER        Lexeme: rp0hostPageSize
 direct_declarator -> IDENTIFIER
Line: 905  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 905  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 905  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 906  Token: IDENTIFIER        Lexeme: rp0rmc
 direct_declarator -> IDENTIFIER
Line: 906  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 906  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 906  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 907  Token: IDENTIFIER        Lexeme: rp0rsvd1
 direct_declarator -> IDENTIFIER
Line: 907  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 907  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 907  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 908  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 908  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 909  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 909  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 912  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 912  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 912  Token: IDENTIFIER        Lexeme: hqpCntxtRp10
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 912  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 913  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 913  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 913  Token: IDENTIFIER        Lexeme: hqpCntxtRp11
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 913  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 914  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 914  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 914  Token: IDENTIFIER        Lexeme: hqpCntxtRp1ConsIndxBits
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 914  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 915  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 915  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 915  Token: IDENTIFIER        Lexeme: hqpCntxtRp1BaseAddrBits
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 915  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 916  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 916  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 916  Token: IDENTIFIER        Lexeme: hqpCntxtRp1ConsIndxAdrl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 916  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 917  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 917  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 917  Token: IDENTIFIER        Lexeme: hqpCntxtRp1ConsIndxAdrh
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 917  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 918  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 918  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 918  Token: IDENTIFIER        Lexeme: hqpCntxtRp1BaseAdrl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 918  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 919  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 919  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 919  Token: IDENTIFIER        Lexeme: hqpCntxtRp1BaseAdrh
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 919  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 920  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 920  Token: {  Lexeme: {
Line: 921  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 921  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 921  Token: IDENTIFIER        Lexeme: hqpCntxtRp17
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 921  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 922  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 922  Token: {  Lexeme: {
Line: 923  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 923  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 923  Token: IDENTIFIER        Lexeme: rp1QueLength
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 923  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 923  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 923  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 924  Token: IDENTIFIER        Lexeme: rpe1
 direct_declarator -> IDENTIFIER
Line: 924  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 924  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 924  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 925  Token: IDENTIFIER        Lexeme: rp1hostPageSize
 direct_declarator -> IDENTIFIER
Line: 925  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 925  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 925  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 926  Token: IDENTIFIER        Lexeme: rp1rmc
 direct_declarator -> IDENTIFIER
Line: 926  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 926  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 926  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 927  Token: IDENTIFIER        Lexeme: rp1rsvd1
 direct_declarator -> IDENTIFIER
Line: 927  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 927  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 927  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 928  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 928  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 929  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 929  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 931  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 931  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 931  Token: IDENTIFIER        Lexeme: anonBuf
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 931  Token: [  Lexeme: [
Line: 931  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 931  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 931  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 933  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 933  Token: ATTRIBUTE         Lexeme: __attribute__
 declaration_specifiers -> type_specifier
 attribute_specifier -> ATTRIBUTE
Line: 933  Token: (  Lexeme: (
Line: 933  Token: (  Lexeme: (
Line: 933  Token: IDENTIFIER        Lexeme: packed
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 933  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
Line: 933  Token: COMPLEX           Lexeme: )
 attribute_specifier '(' primary_expression ')' 
Line: 933  Token: ;  Lexeme: ;
 declaration -> declaration_specifiers attribute_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 935  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 935  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 935  Token: IDENTIFIER        Lexeme: _hqmHqpCntxt
Line: 935  Token: IDENTIFIER        Lexeme: hqmHqpCntxt
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 935  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqmHqpCntxt added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: hqmHqpCntxt updated
setTypeName: hqmHqpCntxt updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 937  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 937  Token: IDENTIFIER        Lexeme: _sqCntxtEntry
Line: 937  Token: {  Lexeme: {
Line: 938  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 938  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 938  Token: IDENTIFIER        Lexeme: queAdrl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 938  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 939  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 939  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 939  Token: IDENTIFIER        Lexeme: queAdrh
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 939  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 940  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 940  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 940  Token: IDENTIFIER        Lexeme: queLength
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 940  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 941  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 941  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 941  Token: IDENTIFIER        Lexeme: hqpid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 941  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 942  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 942  Token: {  Lexeme: {
Line: 943  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 943  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 943  Token: IDENTIFIER        Lexeme: sqCntxt3
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 943  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 944  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 944  Token: {  Lexeme: {
Line: 945  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 945  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 945  Token: IDENTIFIER        Lexeme: en
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 945  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 945  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 945  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 946  Token: IDENTIFIER        Lexeme: sw
 direct_declarator -> IDENTIFIER
Line: 946  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 946  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 946  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 947  Token: IDENTIFIER        Lexeme: rsvd1
 direct_declarator -> IDENTIFIER
Line: 947  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 947  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 947  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 948  Token: IDENTIFIER        Lexeme: rmc
 direct_declarator -> IDENTIFIER
Line: 948  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 948  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 948  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 949  Token: IDENTIFIER        Lexeme: qes
 direct_declarator -> IDENTIFIER
Line: 949  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 949  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 949  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 950  Token: IDENTIFIER        Lexeme: swqeRegion
 direct_declarator -> IDENTIFIER
Line: 950  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 950  Token: CONSTANT          Lexeme: 6
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 950  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 951  Token: IDENTIFIER        Lexeme: rsvd2
 direct_declarator -> IDENTIFIER
Line: 951  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 951  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 951  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 952  Token: IDENTIFIER        Lexeme: nxtSeqNum
 direct_declarator -> IDENTIFIER
Line: 952  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 952  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 952  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 953  Token: IDENTIFIER        Lexeme: hostPageSize
 direct_declarator -> IDENTIFIER
Line: 953  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 953  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 953  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 954  Token: IDENTIFIER        Lexeme: rsvd3
 direct_declarator -> IDENTIFIER
Line: 954  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 954  Token: CONSTANT          Lexeme: 9
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 954  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 955  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 955  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 956  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 956  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 957  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 957  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 957  Token: IDENTIFIER        Lexeme: consIdx
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 957  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 958  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 958  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 958  Token: IDENTIFIER        Lexeme: rsvd4
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 958  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 959  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 959  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 959  Token: IDENTIFIER        Lexeme: rsvd5
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 959  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 960  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 960  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 960  Token: IDENTIFIER        Lexeme: mqsL1q
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 960  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 961  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 961  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 961  Token: IDENTIFIER        Lexeme: cntxtRegion
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 961  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 962  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 962  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 962  Token: IDENTIFIER        Lexeme: pcieBits
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 962  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 964  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 964  Token: IDENTIFIER        Lexeme: _sqCntxtEntry
Line: 964  Token: *  Lexeme: *
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 specifier_qualifier_list -> type_specifier
Line: 964  Token: IDENTIFIER        Lexeme: next
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 964  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 966  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 966  Token: ATTRIBUTE         Lexeme: __attribute__
 declaration_specifiers -> type_specifier
 attribute_specifier -> ATTRIBUTE
Line: 966  Token: (  Lexeme: (
Line: 966  Token: (  Lexeme: (
Line: 966  Token: IDENTIFIER        Lexeme: packed
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 966  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
Line: 966  Token: COMPLEX           Lexeme: )
 attribute_specifier '(' primary_expression ')' 
Line: 966  Token: ;  Lexeme: ;
 declaration -> declaration_specifiers attribute_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 969  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 969  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 969  Token: IDENTIFIER        Lexeme: _sqCntxtEntry
Line: 969  Token: IDENTIFIER        Lexeme: sqCntxtEntry
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 969  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: sqCntxtEntry added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: sqCntxtEntry updated
setTypeName: sqCntxtEntry updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 971  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 971  Token: ENUM              Lexeme: enum
Line: 971  Token: {  Lexeme: {
Line: 972  Token: IDENTIFIER        Lexeme: HASH_FREE
Line: 972  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator
Line: 973  Token: IDENTIFIER        Lexeme: HASH_ASSIGNED
Line: 973  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 974  Token: IDENTIFIER        Lexeme: HASH_DELETED
Line: 974  Token: ,  Lexeme: ,
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
Line: 975  Token: IDENTIFIER        Lexeme: HASH_RO
Line: 977  Token: }  Lexeme: }
 enumerator -> IDENTIFIER
 enumerator_list -> enumerator_list ',' enumerator
 enum_specifier -> ENUM '{' enumerator_list '}'
 type_specifier -> enum_specifier
Line: 977  Token: IDENTIFIER        Lexeme: T_HASH_SLOT_STATE
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 977  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: T_HASH_SLOT_STATE added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: T_HASH_SLOT_STATE updated
setTypeName: T_HASH_SLOT_STATE updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 985  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 985  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 985  Token: IDENTIFIER        Lexeme: _hashEntry
Line: 985  Token: {  Lexeme: {
Line: 986  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 986  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 986  Token: IDENTIFIER        Lexeme: state
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 986  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 986  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 986  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 987  Token: IDENTIFIER        Lexeme: key
 direct_declarator -> IDENTIFIER
Line: 987  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 987  Token: CONSTANT          Lexeme: 18
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 987  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 988  Token: IDENTIFIER        Lexeme: rsvd
 direct_declarator -> IDENTIFIER
Line: 988  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 988  Token: CONSTANT          Lexeme: 12
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 988  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 989  Token: IDENTIFIER        Lexeme: sqCntxtEntry
 type_specifier -> TYPE_NAME
Line: 989  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 989  Token: IDENTIFIER        Lexeme: cntxtAdr
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 989  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 990  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 990  Token: IDENTIFIER        Lexeme: hashEntry
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 990  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hashEntry added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: hashEntry updated
setTypeName: hashEntry updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 997  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 997  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 997  Token: IDENTIFIER        Lexeme: _drp_crp
Line: 997  Token: {  Lexeme: {
Line: 998  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 998  Token: {  Lexeme: {
Line: 999  Token: IDENTIFIER        Lexeme: crp_struct
 type_specifier -> TYPE_NAME
Line: 999  Token: IDENTIFIER        Lexeme: crp
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 999  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1000  Token: IDENTIFIER        Lexeme: drp_struct
 type_specifier -> TYPE_NAME
Line: 1000  Token: IDENTIFIER        Lexeme: drp
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1000  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1001  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1001  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 1002  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1002  Token: IDENTIFIER        Lexeme: drp_crp
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1002  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: drp_crp added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: drp_crp updated
setTypeName: drp_crp updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1004  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1004  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1004  Token: IDENTIFIER        Lexeme: _bufDesc
Line: 1004  Token: {  Lexeme: {
Line: 1005  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1005  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1005  Token: IDENTIFIER        Lexeme: pad_for_mqs
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1005  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1006  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 1006  Token: {  Lexeme: {
Line: 1007  Token: IDENTIFIER        Lexeme: drp_crp
 type_specifier -> TYPE_NAME
Line: 1007  Token: IDENTIFIER        Lexeme: lbuf
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1007  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1008  Token: IDENTIFIER        Lexeme: fc_iocb_struct
 type_specifier -> TYPE_NAME
Line: 1008  Token: IDENTIFIER        Lexeme: iocb
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1008  Token: [  Lexeme: [
Line: 1008  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1008  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1008  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1009  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1009  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 1010  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1010  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1010  Token: IDENTIFIER        Lexeme: pad_for_dma
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1010  Token: [  Lexeme: [
Line: 1010  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1010  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1010  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1011  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1011  Token: IDENTIFIER        Lexeme: _bufDesc
Line: 1011  Token: *  Lexeme: *
 struct_or_union_specifier -> struct_or_union IDENTIFIER
 type_specifier -> struct_or_union_specifier
 specifier_qualifier_list -> type_specifier
Line: 1011  Token: IDENTIFIER        Lexeme: next
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1011  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1012  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 1012  Token: IDENTIFIER        Lexeme: mbuf
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1012  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1013  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1013  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1013  Token: IDENTIFIER        Lexeme: hqpId
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1013  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1014  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1014  Token: IDENTIFIER        Lexeme: bufDesc
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1014  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: bufDesc added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: bufDesc updated
setTypeName: bufDesc updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1020  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1020  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1020  Token: IDENTIFIER        Lexeme: _drpCrpQue
Line: 1020  Token: {  Lexeme: {
Line: 1021  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1021  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1021  Token: IDENTIFIER        Lexeme: head
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1021  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1022  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1022  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1022  Token: IDENTIFIER        Lexeme: tail
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1022  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1023  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1023  Token: IDENTIFIER        Lexeme: drpCrpQue
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1023  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: drpCrpQue added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: drpCrpQue updated
setTypeName: drpCrpQue updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1029  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1029  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1029  Token: IDENTIFIER        Lexeme: _bufQue
Line: 1029  Token: {  Lexeme: {
Line: 1030  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1030  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1030  Token: IDENTIFIER        Lexeme: head
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1030  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1031  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1031  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1031  Token: IDENTIFIER        Lexeme: tail
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1031  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1032  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1032  Token: IDENTIFIER        Lexeme: bufQue
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1032  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: bufQue added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: bufQue updated
setTypeName: bufQue updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1036  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1036  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1036  Token: IDENTIFIER        Lexeme: _opcodeFormatRamEntry
Line: 1036  Token: {  Lexeme: {
Line: 1037  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 1037  Token: {  Lexeme: {
Line: 1038  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1038  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1038  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1038  Token: IDENTIFIER        Lexeme: OpcodeFormat
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1038  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1039  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1039  Token: {  Lexeme: {
Line: 1040  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1040  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1040  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1041  Token: IDENTIFIER        Lexeme: lengthInIocb
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1041  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1041  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1041  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 1042  Token: IDENTIFIER        Lexeme: numDsds
 direct_declarator -> IDENTIFIER
Line: 1042  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1042  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1042  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1043  Token: IDENTIFIER        Lexeme: createAlcbs
 direct_declarator -> IDENTIFIER
Line: 1043  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1043  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1043  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1044  Token: IDENTIFIER        Lexeme: routeToSP
 direct_declarator -> IDENTIFIER
Line: 1044  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1044  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1044  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1045  Token: IDENTIFIER        Lexeme: ctrlFlagsPsn
 direct_declarator -> IDENTIFIER
Line: 1045  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1045  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1045  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1046  Token: IDENTIFIER        Lexeme: ctrlFlagsMsk
 direct_declarator -> IDENTIFIER
Line: 1046  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1046  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1046  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1047  Token: IDENTIFIER        Lexeme: prefetchIocb
 direct_declarator -> IDENTIFIER
Line: 1047  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1047  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1047  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1048  Token: IDENTIFIER        Lexeme: prefetchContext
 direct_declarator -> IDENTIFIER
Line: 1048  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1048  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1048  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1049  Token: IDENTIFIER        Lexeme: conxIdPsn
 direct_declarator -> IDENTIFIER
Line: 1049  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1049  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1049  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1053  Token: IDENTIFIER        Lexeme: conxIdPrefix
 direct_declarator -> IDENTIFIER
Line: 1053  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1053  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1053  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1054  Token: IDENTIFIER        Lexeme: iocbCountFmt
 direct_declarator -> IDENTIFIER
Line: 1054  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1054  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1054  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1057  Token: IDENTIFIER        Lexeme: ecc
 direct_declarator -> IDENTIFIER
Line: 1057  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1057  Token: CONSTANT          Lexeme: 7
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1057  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
Line: 1058  Token: IDENTIFIER        Lexeme: rsvd
 direct_declarator -> IDENTIFIER
Line: 1058  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1058  Token: CONSTANT          Lexeme: 23
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1058  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1059  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1059  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 1060  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1060  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** anonymoous_union -> struct_declaration ***
Line: 1061  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1061  Token: IDENTIFIER        Lexeme: opcodeFormatRamEntry
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1061  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: opcodeFormatRamEntry added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: opcodeFormatRamEntry updated
setTypeName: opcodeFormatRamEntry updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1063  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1063  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1063  Token: IDENTIFIER        Lexeme: _mqsLink
Line: 1063  Token: {  Lexeme: {
Line: 1064  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1064  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1064  Token: IDENTIFIER        Lexeme: link
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1064  Token: [  Lexeme: [
Line: 1064  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1064  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1064  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1065  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1065  Token: IDENTIFIER        Lexeme: mqsLink
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1065  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: mqsLink added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: mqsLink updated
setTypeName: mqsLink updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1067  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1067  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1067  Token: IDENTIFIER        Lexeme: _mqsMessage
Line: 1067  Token: {  Lexeme: {
Line: 1068  Token: IDENTIFIER        Lexeme: mqsLink
 type_specifier -> TYPE_NAME
Line: 1068  Token: IDENTIFIER        Lexeme: link
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1068  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1069  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1069  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1069  Token: IDENTIFIER        Lexeme: iocb
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1069  Token: [  Lexeme: [
Line: 1069  Token: CONSTANT          Lexeme: 32
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1069  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1069  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1070  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1070  Token: IDENTIFIER        Lexeme: mqsMessage
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1070  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: mqsMessage added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: mqsMessage updated
setTypeName: mqsMessage updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1072  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1072  Token: IDENTIFIER        Lexeme: mainLoop
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1072  Token: (  Lexeme: (
Line: 1072  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1072  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1072  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: mainLoop added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1076  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1076  Token: IDENTIFIER        Lexeme: enqueDmaCb
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1076  Token: (  Lexeme: (
Line: 1076  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 1076  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1076  Token: IDENTIFIER        Lexeme: pDmaCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1076  Token: ,  Lexeme: ,
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1076  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1076  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1076  Token: IDENTIFIER        Lexeme: pDmaQue
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1076  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1076  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: enqueDmaCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1077  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 1077  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1077  Token: IDENTIFIER        Lexeme: dequeAndUpdateDmaCbStatus
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1077  Token: (  Lexeme: (
Line: 1077  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1077  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1077  Token: IDENTIFIER        Lexeme: pDmaQue
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1077  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1077  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: dequeAndUpdateDmaCbStatus added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1078  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 1078  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1078  Token: IDENTIFIER        Lexeme: dequeDmaCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1078  Token: (  Lexeme: (
Line: 1078  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1078  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1078  Token: IDENTIFIER        Lexeme: pDmaQue
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1078  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1078  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: dequeDmaCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1079  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1079  Token: IDENTIFIER        Lexeme: dmaQueIsEmpty
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1079  Token: (  Lexeme: (
Line: 1079  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1079  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1079  Token: IDENTIFIER        Lexeme: pDmaQue
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1079  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1079  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dmaQueIsEmpty added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1080  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1080  Token: IDENTIFIER        Lexeme: fpFifoIsEmpty
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1080  Token: (  Lexeme: (
Line: 1080  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1080  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1080  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fpFifoIsEmpty added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1081  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1081  Token: IDENTIFIER        Lexeme: fpFifoIsFull
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1081  Token: (  Lexeme: (
Line: 1081  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1081  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1081  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fpFifoIsFull added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1082  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1082  Token: IDENTIFIER        Lexeme: enqueFpFifo
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1082  Token: (  Lexeme: (
Line: 1082  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1082  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1082  Token: IDENTIFIER        Lexeme: adr
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1082  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1082  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: enqueFpFifo added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1083  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1083  Token: IDENTIFIER        Lexeme: abFifoIsEmpty
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1083  Token: (  Lexeme: (
Line: 1083  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1083  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1083  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: abFifoIsEmpty added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1084  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1084  Token: IDENTIFIER        Lexeme: abFifoIsFull
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1084  Token: (  Lexeme: (
Line: 1084  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1084  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1084  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: abFifoIsFull added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1085  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1085  Token: IDENTIFIER        Lexeme: dequeAbFifo
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1085  Token: (  Lexeme: (
Line: 1085  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1085  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1085  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
Line: 1085  Token: IDENTIFIER        Lexeme: pHqpId
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1085  Token: ,  Lexeme: ,
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1085  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1085  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1085  Token: *  Lexeme: *
Line: 1085  Token: IDENTIFIER        Lexeme: pBufAdr
 pointer -> '*'
 pointer -> '*' pointer
 direct_declarator -> IDENTIFIER
Line: 1085  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1085  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dequeAbFifo added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1086  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1086  Token: IDENTIFIER        Lexeme: enqueHqpCb
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1086  Token: (  Lexeme: (
Line: 1086  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1086  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1086  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1086  Token: ,  Lexeme: ,
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1086  Token: IDENTIFIER        Lexeme: hqpQue
 type_specifier -> TYPE_NAME
Line: 1086  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1086  Token: IDENTIFIER        Lexeme: pHqpQue
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1086  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1086  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: enqueHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1087  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1087  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1087  Token: IDENTIFIER        Lexeme: dequeHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1087  Token: (  Lexeme: (
Line: 1087  Token: IDENTIFIER        Lexeme: hqpQue
 type_specifier -> TYPE_NAME
Line: 1087  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1087  Token: IDENTIFIER        Lexeme: pHqpQue
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1087  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1087  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: dequeHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1088  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1088  Token: IDENTIFIER        Lexeme: hqpQueIsEmpty
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1088  Token: (  Lexeme: (
Line: 1088  Token: IDENTIFIER        Lexeme: hqpQue
 type_specifier -> TYPE_NAME
Line: 1088  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1088  Token: IDENTIFIER        Lexeme: pHqpQue
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1088  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1088  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpQueIsEmpty added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1089  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1089  Token: IDENTIFIER        Lexeme: getIocbStateString
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1089  Token: (  Lexeme: (
Line: 1089  Token: IDENTIFIER        Lexeme: hqpState
 type_specifier -> TYPE_NAME
Line: 1089  Token: IDENTIFIER        Lexeme: state
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1089  Token: ,  Lexeme: ,
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1089  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 1089  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1089  Token: IDENTIFIER        Lexeme: buf
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1089  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1089  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: getIocbStateString added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1090  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1090  Token: IDENTIFIER        Lexeme: getIocbStateString
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1090  Token: (  Lexeme: (
Line: 1090  Token: IDENTIFIER        Lexeme: hqpState
 type_specifier -> TYPE_NAME
Line: 1090  Token: IDENTIFIER        Lexeme: state
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1090  Token: ,  Lexeme: ,
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1090  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 1090  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1090  Token: IDENTIFIER        Lexeme: buf
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1090  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1090  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: getIocbStateString added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1092  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1092  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1092  Token: IDENTIFIER        Lexeme: top
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1092  Token: (  Lexeme: (
Line: 1092  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1092  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1092  Token: IDENTIFIER        Lexeme: que
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1092  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1092  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: top added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1093  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1093  Token: IDENTIFIER        Lexeme: ProcessSlowPathRequest
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1093  Token: (  Lexeme: (
Line: 1093  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1093  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1093  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1093  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: ProcessSlowPathRequest added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1094  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1094  Token: IDENTIFIER        Lexeme: getHqpContext
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1094  Token: (  Lexeme: (
Line: 1094  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1094  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1094  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1094  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: getHqpContext added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1095  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1095  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1095  Token: IDENTIFIER        Lexeme: allocDrpCrp
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1095  Token: (  Lexeme: (
Line: 1095  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1095  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1095  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1095  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: allocDrpCrp added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1096  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1096  Token: IDENTIFIER        Lexeme: processIocb
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1096  Token: (  Lexeme: (
Line: 1096  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1096  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1096  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1096  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: processIocb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1097  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1097  Token: IDENTIFIER        Lexeme: ProcessDsdList
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1097  Token: (  Lexeme: (
Line: 1097  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1097  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1097  Token: ,  Lexeme: ,
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1097  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1097  Token: IDENTIFIER        Lexeme: dsdListPointer
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1097  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1097  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: ProcessDsdList added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1098  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1098  Token: IDENTIFIER        Lexeme: ReleaseHqpResources
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1098  Token: (  Lexeme: (
Line: 1098  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1098  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1098  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1098  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: ReleaseHqpResources added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1103  Token: IDENTIFIER        Lexeme: sqCntxtEntry
 type_specifier -> TYPE_NAME
Line: 1103  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1103  Token: IDENTIFIER        Lexeme: sqHashGet
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1103  Token: (  Lexeme: (
Line: 1103  Token: IDENTIFIER        Lexeme: hashEntry
 type_specifier -> TYPE_NAME
Line: 1103  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1103  Token: IDENTIFIER        Lexeme: table
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1103  Token: ,  Lexeme: ,
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1103  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1103  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1103  Token: IDENTIFIER        Lexeme: key
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1103  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1103  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: sqHashGet added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1104  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1104  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1104  Token: IDENTIFIER        Lexeme: sqHashAdd
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1104  Token: (  Lexeme: (
Line: 1104  Token: IDENTIFIER        Lexeme: hashEntry
 type_specifier -> TYPE_NAME
Line: 1104  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1104  Token: IDENTIFIER        Lexeme: table
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1104  Token: ,  Lexeme: ,
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1104  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1104  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1104  Token: IDENTIFIER        Lexeme: key
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1104  Token: ,  Lexeme: ,
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
Line: 1104  Token: IDENTIFIER        Lexeme: sqCntxtEntry
 type_specifier -> TYPE_NAME
Line: 1104  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1104  Token: IDENTIFIER        Lexeme: value
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1104  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1104  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: sqHashAdd added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1105  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1105  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1105  Token: IDENTIFIER        Lexeme: sqHashDelete
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1105  Token: (  Lexeme: (
Line: 1105  Token: IDENTIFIER        Lexeme: hashEntry
 type_specifier -> TYPE_NAME
Line: 1105  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1105  Token: IDENTIFIER        Lexeme: table
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1105  Token: ,  Lexeme: ,
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1105  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1105  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1105  Token: IDENTIFIER        Lexeme: key
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1105  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1105  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: sqHashDelete added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1106  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1106  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1106  Token: IDENTIFIER        Lexeme: sqHashKey
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1106  Token: (  Lexeme: (
Line: 1106  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1106  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1106  Token: IDENTIFIER        Lexeme: key
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1106  Token: ,  Lexeme: ,
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1106  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1106  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1106  Token: IDENTIFIER        Lexeme: indx
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1106  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1106  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: sqHashKey added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1108  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1108  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1108  Token: IDENTIFIER        Lexeme: dmalloc
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1108  Token: (  Lexeme: (
Line: 1108  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1108  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1108  Token: IDENTIFIER        Lexeme: length
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1108  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1108  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: dmalloc added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1109  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1109  Token: IDENTIFIER        Lexeme: dfree
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1109  Token: (  Lexeme: (
Line: 1109  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1109  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1109  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 parameter_declaration -> declaration_specifiers abstract_declarato
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1109  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dfree added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1113  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1113  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1113  Token: IDENTIFIER        Lexeme: _sp_regs
Line: 1113  Token: {  Lexeme: {
Line: 1114  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1114  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1114  Token: IDENTIFIER        Lexeme: hqmDebugReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1114  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1115  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1115  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1115  Token: IDENTIFIER        Lexeme: hqmIoRingReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1115  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1116  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1116  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1116  Token: IDENTIFIER        Lexeme: hqmLoadRamAdrReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1116  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1117  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1117  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1117  Token: IDENTIFIER        Lexeme: hqmLoadRamDataReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1117  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1118  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1118  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1118  Token: IDENTIFIER        Lexeme: hqmIpcMsgDataReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1118  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1119  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1119  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1119  Token: IDENTIFIER        Lexeme: hqmIpcMsgCmdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1119  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1120  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1120  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1120  Token: IDENTIFIER        Lexeme: hqmSemaphoreReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1120  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1122  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1122  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1122  Token: IDENTIFIER        Lexeme: hqmHqpConfigReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1122  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1129  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1129  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1129  Token: IDENTIFIER        Lexeme: hqmHqpStatusReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1129  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1131  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1131  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1131  Token: IDENTIFIER        Lexeme: FreePoolFifoReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1131  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1133  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1133  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1133  Token: IDENTIFIER        Lexeme: hqpIocbFetchReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1133  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1135  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1135  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1135  Token: IDENTIFIER        Lexeme: iocbDmaCmdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1135  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1137  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1137  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1137  Token: IDENTIFIER        Lexeme: iocbDmaSpAdrReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1137  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1140  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1140  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1140  Token: IDENTIFIER        Lexeme: iocbDmaAdrlReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1140  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1141  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1141  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1141  Token: IDENTIFIER        Lexeme: iocbDmaAdrhReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1141  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1143  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1143  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1143  Token: IDENTIFIER        Lexeme: iocbDmaHqpIdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1143  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1145  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1145  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1145  Token: IDENTIFIER        Lexeme: mimBlkRqReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1145  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1147  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1147  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1147  Token: IDENTIFIER        Lexeme: mimDma0CmdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1147  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1149  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1149  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1149  Token: IDENTIFIER        Lexeme: mimDma0AdrReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1149  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1155  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1155  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1155  Token: IDENTIFIER        Lexeme: mimDma0BlkOffsetReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1155  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1158  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1158  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1158  Token: IDENTIFIER        Lexeme: mimDma0SpAdrReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1158  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1165  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1165  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1165  Token: IDENTIFIER        Lexeme: mqsDma0CmdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1165  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1167  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1167  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1167  Token: IDENTIFIER        Lexeme: hqpCntxtCmdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1167  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1172  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1172  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1172  Token: IDENTIFIER        Lexeme: hqpCntxtSpAdrReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1172  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1179  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1179  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1179  Token: IDENTIFIER        Lexeme: hqpCmdCmpltReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1179  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1185  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1185  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1185  Token: IDENTIFIER        Lexeme: hqmNumIocbPerBlockReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1185  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1192  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1192  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1192  Token: IDENTIFIER        Lexeme: sqStatusReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1192  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1200  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1200  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1200  Token: IDENTIFIER        Lexeme: sqCntxtCmdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1200  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1205  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1205  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1205  Token: IDENTIFIER        Lexeme: sqCntxtSpAdrReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1205  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1212  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1212  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1212  Token: IDENTIFIER        Lexeme: sqCntxtUpCmdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1212  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1217  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1217  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1217  Token: IDENTIFIER        Lexeme: sqCntxtUpDataReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1217  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1225  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1225  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1225  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1225  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1227  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1227  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1227  Token: IDENTIFIER        Lexeme: hostDmaSpAdrReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1227  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1230  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1230  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1230  Token: IDENTIFIER        Lexeme: hostDmaAdrlReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1230  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1231  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1231  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1231  Token: IDENTIFIER        Lexeme: hostDmaAdrhReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1231  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1233  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1233  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1233  Token: IDENTIFIER        Lexeme: hostDmaHqpIdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1233  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1235  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1235  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1235  Token: IDENTIFIER        Lexeme: mimDma1CmdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1235  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1236  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1236  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1236  Token: IDENTIFIER        Lexeme: mimDma1AdrReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1236  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1237  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1237  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1237  Token: IDENTIFIER        Lexeme: mimDma1BlkOffsetReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1237  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1238  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1238  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1238  Token: IDENTIFIER        Lexeme: mimDma1SpAdrReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1238  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1246  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1246  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1246  Token: IDENTIFIER        Lexeme: mqsDma1CmdReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1246  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1251  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1251  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1251  Token: IDENTIFIER        Lexeme: conxIdIncCountReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1251  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1255  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1255  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1255  Token: IDENTIFIER        Lexeme: mqsTieCnxReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1255  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1256  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1256  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1256  Token: IDENTIFIER        Lexeme: mqsTiePrf0Reg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1256  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1257  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1257  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1257  Token: IDENTIFIER        Lexeme: mqsTiePrf1Reg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1257  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1258  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1258  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1258  Token: IDENTIFIER        Lexeme: mqsTieL1qReg
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1258  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1260  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1260  Token: IDENTIFIER        Lexeme: sp_regs
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1260  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: sp_regs added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: sp_regs updated
setTypeName: sp_regs updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1262  Token: EXTERN            Lexeme: extern
 storage_class_specifier -> EXTERN
Line: 1262  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1262  Token: IDENTIFIER        Lexeme: spRegs
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1262  Token: ATTRIBUTE         Lexeme: __attribute__
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: spRegs added to idList
 init_declarator_list -> init_declarator
 attribute_specifier -> ATTRIBUTE
Line: 1262  Token: (  Lexeme: (
Line: 1262  Token: (  Lexeme: (
Line: 1262  Token: IDENTIFIER        Lexeme: section
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1262  Token: (  Lexeme: (
Line: 1262  Token: STRING_LITERAL    Lexeme: ".hdwregs"
 primary_expression -> STRING_LITERAL
 postfix_expression -> primary_expression
Line: 1262  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1262  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
Line: 1262  Token: COMPLEX           Lexeme: )
 attribute_specifier '(' primary_expression ')' 
Line: 1262  Token: ;  Lexeme: ;
 declaration -> declaration_specifiers init_declarator_list attribute_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1267  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1267  Token: IDENTIFIER        Lexeme: _FCP_CDB
Line: 1267  Token: {  Lexeme: {
Line: 1268  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1268  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 1268  Token: IDENTIFIER        Lexeme: cdb
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1268  Token: [  Lexeme: [
Line: 1268  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1268  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1268  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1269  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1269  Token: ;  Lexeme: ;
 declaration_specifiers -> type_specifier
ClrIdList: idList cleared
 declaration -> declaration_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1273  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1273  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1273  Token: IDENTIFIER        Lexeme: _scsiBlk
Line: 1273  Token: {  Lexeme: {
Line: 1274  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1274  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 1274  Token: IDENTIFIER        Lexeme: buf
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1274  Token: [  Lexeme: [
Line: 1274  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1274  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1274  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1275  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1275  Token: IDENTIFIER        Lexeme: scsiBlk
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1275  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: scsiBlk added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: scsiBlk updated
setTypeName: scsiBlk updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1277  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1277  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1277  Token: IDENTIFIER        Lexeme: _timer
Line: 1277  Token: {  Lexeme: {
Line: 1278  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1278  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1278  Token: IDENTIFIER        Lexeme: tick
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1278  Token: [  Lexeme: [
Line: 1278  Token: CONSTANT          Lexeme: 100
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1278  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1278  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1279  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1279  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1279  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
Line: 1279  Token: IDENTIFIER        Lexeme: pNxtTick
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1279  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1280  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1280  Token: IDENTIFIER        Lexeme: timer
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1280  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: timer added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: timer updated
setTypeName: timer updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1282  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1282  Token: IDENTIFIER        Lexeme: fpHdwSimFifoInit
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1282  Token: (  Lexeme: (
Line: 1282  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1282  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1282  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fpHdwSimFifoInit added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1283  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1283  Token: IDENTIFIER        Lexeme: fpHdwSimFifoIsFull
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1283  Token: (  Lexeme: (
Line: 1283  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1283  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1283  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fpHdwSimFifoIsFull added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1284  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1284  Token: IDENTIFIER        Lexeme: fpHdwSimFifoIsEmpty
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1284  Token: (  Lexeme: (
Line: 1284  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1284  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1284  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fpHdwSimFifoIsEmpty added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1285  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1285  Token: IDENTIFIER        Lexeme: enqueueFpHdwSimFifo
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1285  Token: (  Lexeme: (
Line: 1285  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1285  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1285  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: enqueueFpHdwSimFifo added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1286  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1286  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1286  Token: IDENTIFIER        Lexeme: dequeueFpHdwSimFifo
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1286  Token: (  Lexeme: (
Line: 1286  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1286  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1286  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dequeueFpHdwSimFifo added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1287  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1287  Token: IDENTIFIER        Lexeme: abHdwSimFifoInit
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1287  Token: (  Lexeme: (
Line: 1287  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1287  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1287  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: abHdwSimFifoInit added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1288  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1288  Token: IDENTIFIER        Lexeme: abHdwSimFifoIsFull
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1288  Token: (  Lexeme: (
Line: 1288  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1288  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1288  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: abHdwSimFifoIsFull added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1289  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1289  Token: IDENTIFIER        Lexeme: enqueueAbHdwSimFifo
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1289  Token: (  Lexeme: (
Line: 1289  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1289  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1289  Token: IDENTIFIER        Lexeme: val
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1289  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1289  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: enqueueAbHdwSimFifo added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1290  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1290  Token: IDENTIFIER        Lexeme: dequeueAbHdwSimFifo
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1290  Token: (  Lexeme: (
Line: 1290  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1290  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1290  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dequeueAbHdwSimFifo added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1293  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1293  Token: IDENTIFIER        Lexeme: SlowPathIocb_Ct6DsdList
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1293  Token: (  Lexeme: (
Line: 1293  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1293  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1293  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: SlowPathIocb_Ct6DsdList added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1294  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1294  Token: IDENTIFIER        Lexeme: SlowPathIocb_Ct7Ct1
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1294  Token: (  Lexeme: (
Line: 1294  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1294  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1294  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: SlowPathIocb_Ct7Ct1 added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1295  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1295  Token: IDENTIFIER        Lexeme: SlowPathIocb_CtCRC_2DsdList
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1295  Token: (  Lexeme: (
Line: 1295  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1295  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1295  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: SlowPathIocb_CtCRC_2DsdList added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1297  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1297  Token: IDENTIFIER        Lexeme: mlmHdwSim
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1297  Token: (  Lexeme: (
Line: 1297  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1297  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1297  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: mlmHdwSim added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1298  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1298  Token: IDENTIFIER        Lexeme: initMim
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1298  Token: (  Lexeme: (
Line: 1298  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1298  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1298  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: initMim added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1299  Token: IDENTIFIER        Lexeme: opcodeFormatRamEntry
 type_specifier -> TYPE_NAME
Line: 1299  Token: IDENTIFIER        Lexeme: ReadOpcodeFormatRam
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1299  Token: (  Lexeme: (
Line: 1299  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1299  Token: IDENTIFIER        Lexeme: opcode
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1299  Token: ,  Lexeme: ,
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 1299  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1299  Token: IDENTIFIER        Lexeme: protocol
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1299  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1299  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: ReadOpcodeFormatRam added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1300  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1300  Token: IDENTIFIER        Lexeme: hqmFetchHdwSim
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1300  Token: (  Lexeme: (
Line: 1300  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1300  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1300  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqmFetchHdwSim added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1301  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1301  Token: IDENTIFIER        Lexeme: hqmCmdCmpltHdwSim
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1301  Token: (  Lexeme: (
Line: 1301  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1301  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1301  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqmCmdCmpltHdwSim added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1302  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1302  Token: IDENTIFIER        Lexeme: hqmMimDma0HdwSim
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1302  Token: (  Lexeme: (
Line: 1302  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1302  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1302  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqmMimDma0HdwSim added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1303  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1303  Token: IDENTIFIER        Lexeme: hqmMimClr0HdwSim
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1303  Token: (  Lexeme: (
Line: 1303  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1303  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1303  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqmMimClr0HdwSim added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1304  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1304  Token: IDENTIFIER        Lexeme: hqmMqsDma0HdwSim
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1304  Token: (  Lexeme: (
Line: 1304  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1304  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1304  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqmMqsDma0HdwSim added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1305  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1305  Token: IDENTIFIER        Lexeme: hqpContextDmaHdwSim
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1305  Token: (  Lexeme: (
Line: 1305  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1305  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1305  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpContextDmaHdwSim added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1306  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1306  Token: IDENTIFIER        Lexeme: initContext
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1306  Token: (  Lexeme: (
Line: 1306  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1306  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1306  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: initContext added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1307  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1307  Token: IDENTIFIER        Lexeme: initOpcodeFormatRam
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1307  Token: (  Lexeme: (
Line: 1307  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1307  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1307  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: initOpcodeFormatRam added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1308  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1308  Token: IDENTIFIER        Lexeme: initHdwRegs
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1308  Token: (  Lexeme: (
Line: 1308  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1308  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1308  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: initHdwRegs added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1309  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1309  Token: IDENTIFIER        Lexeme: mqsCnxIdIncHdwSim
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1309  Token: (  Lexeme: (
Line: 1309  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1309  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1309  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: mqsCnxIdIncHdwSim added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1311  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1311  Token: IDENTIFIER        Lexeme: DipslayAllocatedDrpCrpBlockList
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1311  Token: (  Lexeme: (
Line: 1311  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1311  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1311  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: DipslayAllocatedDrpCrpBlockList added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1312  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1312  Token: IDENTIFIER        Lexeme: DisplayDrpCrpChain
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1312  Token: (  Lexeme: (
Line: 1312  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1312  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1312  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1312  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1312  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: DisplayDrpCrpChain added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1313  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1313  Token: IDENTIFIER        Lexeme: DisplayMqsMessage
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1313  Token: (  Lexeme: (
Line: 1313  Token: IDENTIFIER        Lexeme: mqsMessage
 type_specifier -> TYPE_NAME
Line: 1313  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1313  Token: IDENTIFIER        Lexeme: pMsg
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1313  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1313  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: DisplayMqsMessage added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1314  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1314  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1314  Token: IDENTIFIER        Lexeme: calcTimerTime
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1314  Token: (  Lexeme: (
Line: 1314  Token: IDENTIFIER        Lexeme: timer
 type_specifier -> TYPE_NAME
Line: 1314  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1314  Token: IDENTIFIER        Lexeme: t
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1314  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1314  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: calcTimerTime added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1322  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1322  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1322  Token: IDENTIFIER        Lexeme: scsi_tag_s
Line: 1322  Token: {  Lexeme: {
Line: 1326  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1326  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 1326  Token: IDENTIFIER        Lexeme: tx_frm_sz
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1326  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1327  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1327  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 1327  Token: IDENTIFIER        Lexeme: rsvd1
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1327  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1328  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1328  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1328  Token: IDENTIFIER        Lexeme: tx_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1328  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1329  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1329  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1329  Token: IDENTIFIER        Lexeme: exp_tx_ro
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1329  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1330  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1330  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1330  Token: IDENTIFIER        Lexeme: rem_tx_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1330  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1332  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 1332  Token: {  Lexeme: {
Line: 1333  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1333  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1333  Token: IDENTIFIER        Lexeme: exp_tx_seqid_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1333  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1334  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1334  Token: {  Lexeme: {
Line: 1335  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1335  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 1335  Token: IDENTIFIER        Lexeme: tx_seq_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1335  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1336  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1336  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 1336  Token: IDENTIFIER        Lexeme: tx_dfctl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1336  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1337  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1337  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 1337  Token: IDENTIFIER        Lexeme: tx_seq_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1337  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1338  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1338  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 1339  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1339  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 1342  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1342  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1342  Token: IDENTIFIER        Lexeme: rx_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1342  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1343  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1343  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1343  Token: IDENTIFIER        Lexeme: exp_rx_ro
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1343  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1344  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1344  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1344  Token: IDENTIFIER        Lexeme: rem_rx_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1344  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1346  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 1346  Token: {  Lexeme: {
Line: 1347  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1347  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1347  Token: IDENTIFIER        Lexeme: exp_rx_seqid_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1347  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1348  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1348  Token: {  Lexeme: {
Line: 1349  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1349  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 1349  Token: IDENTIFIER        Lexeme: rx_seq_cnt
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1349  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1350  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1350  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 1350  Token: IDENTIFIER        Lexeme: rx_dfctl
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1350  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1351  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1351  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 1351  Token: IDENTIFIER        Lexeme: rx_seq_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1351  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1352  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1352  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 1353  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1353  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 1357  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1357  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1357  Token: IDENTIFIER        Lexeme: task_retry_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1357  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1358  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1358  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1358  Token: IDENTIFIER        Lexeme: fill
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1358  Token: [  Lexeme: [
Line: 1358  Token: CONSTANT          Lexeme: 13
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1358  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1358  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1360  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1360  Token: IDENTIFIER        Lexeme: x_scsi_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1360  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: x_scsi_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: x_scsi_struct updated
setTypeName: x_scsi_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1367  Token: TYPEDEF           Lexeme: typedef
Parser: Token: TYPEDEF           Lexeme typedef
 storage_class_specifier -> TYPEDEF
Line: 1367  Token: STRUCT            Lexeme: struct
 struct_or_union -> STRUCT
Line: 1367  Token: IDENTIFIER        Lexeme: xcb_s
Line: 1367  Token: {  Lexeme: {
Line: 1369  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1369  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1369  Token: IDENTIFIER        Lexeme: port
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1369  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1369  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1369  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator
Line: 1370  Token: IDENTIFIER        Lexeme: flags
 direct_declarator -> IDENTIFIER
Line: 1370  Token: :  Lexeme: :
 declarator -> direct_declarator
Line: 1370  Token: CONSTANT          Lexeme: 29
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1370  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
 struct_declarator -> declarator ':' constant_expression
 struct_declarator_list -> struct_declarator_list ',' struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1372  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1372  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1372  Token: IDENTIFIER        Lexeme: iocb_handle
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1372  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1373  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1373  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 1373  Token: IDENTIFIER        Lexeme: hpq_id
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1373  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1374  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1374  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 1374  Token: IDENTIFIER        Lexeme: ctl_flags
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1374  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1375  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1375  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 1375  Token: IDENTIFIER        Lexeme: x_state
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1375  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1376  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1376  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 1376  Token: IDENTIFIER        Lexeme: x_event
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1376  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1377  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1377  Token: CHAR              Lexeme: char
 type_specifier -> CHAR
Line: 1377  Token: IDENTIFIER        Lexeme: x_owner
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1377  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1378  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1378  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 1378  Token: IDENTIFIER        Lexeme: othr_xid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1378  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1379  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1379  Token: SHORT             Lexeme: short
 type_specifier -> SHORT
Line: 1379  Token: IDENTIFIER        Lexeme: my_xid
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1379  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1380  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 1380  Token: IDENTIFIER        Lexeme: pcb_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1380  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1381  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 1381  Token: IDENTIFIER        Lexeme: drp_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1381  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1382  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 1382  Token: IDENTIFIER        Lexeme: x_link_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1382  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1383  Token: IDENTIFIER        Lexeme: mim_adr_struct
 type_specifier -> TYPE_NAME
Line: 1383  Token: IDENTIFIER        Lexeme: x_cont_link_adr
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1383  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1385  Token: UNION             Lexeme: union
 struct_or_union -> UNION
Line: 1385  Token: {  Lexeme: {
Line: 1386  Token: IDENTIFIER        Lexeme: x_scsi_struct
 type_specifier -> TYPE_NAME
Line: 1386  Token: IDENTIFIER        Lexeme: scsi_own
 specifier_qualifier_list -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1386  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration
Line: 1387  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1387  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1387  Token: IDENTIFIER        Lexeme: misc_data
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 direct_declarator -> IDENTIFIER
Line: 1387  Token: [  Lexeme: [
Line: 1387  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1387  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1387  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 struct_declarator -> declarator
 struct_declarator_list -> struct_declarator
 struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
 struct_declaration_list -> struct_declaration_list struct_declaration
Line: 1388  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1388  Token: ;  Lexeme: ;
 specifier_qualifier_list -> type_specifier
 *** tfl -- anonymous unions:  anonymous_union -> specifier_qualifier_list ';' ***
 *** struct_declaration_list -> struct_declaration_list anonymous_union ***
Line: 1390  Token: }  Lexeme: }
 struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
 type_specifier -> struct_or_union_specifier
Line: 1390  Token: IDENTIFIER        Lexeme: xcb_struct
 declaration_specifiers -> type_specifier
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1390  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: xcb_struct added to idList
 init_declarator_list -> init_declarator
UpdateTypeNames: xcb_struct updated
setTypeName: xcb_struct updated
ClrIdList: idList cleared
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1393  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1393  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1393  Token: IDENTIFIER        Lexeme: simIocbComplete
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1393  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 1393  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1393  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: simIocbComplete added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1394  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1394  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1394  Token: IDENTIFIER        Lexeme: passCount
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1394  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 1394  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1394  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: passCount added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1397  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1397  Token: REGISTER          Lexeme: register
 storage_class_specifier -> REGISTER
Line: 1397  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1397  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1397  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 declaration_specifiers -> storage_class_specifier declaration_specifiers
 declaration_specifiers -> type_qualifier declaration_specifiers	
Line: 1397  Token: IDENTIFIER        Lexeme: rMb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1397  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: rMb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1398  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1398  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1398  Token: IDENTIFIER        Lexeme: shdMb0
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1398  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: shdMb0 added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1400  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1400  Token: IDENTIFIER        Lexeme: iocbDma
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1400  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: iocbDma added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1401  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1401  Token: IDENTIFIER        Lexeme: hostDma
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1401  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hostDma added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1402  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1402  Token: IDENTIFIER        Lexeme: mimDma
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1402  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: mimDma added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1403  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1403  Token: IDENTIFIER        Lexeme: mqsDma
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1403  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: mqsDma added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1404  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1404  Token: IDENTIFIER        Lexeme: hqpCtxDma
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1404  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpCtxDma added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1405  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1405  Token: IDENTIFIER        Lexeme: swqeDma
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1405  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: swqeDma added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1406  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1406  Token: IDENTIFIER        Lexeme: roceCtxDma
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1406  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: roceCtxDma added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1408  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1408  Token: IDENTIFIER        Lexeme: fwDsdQue
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1408  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fwDsdQue added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1409  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1409  Token: IDENTIFIER        Lexeme: fwSwqeQue
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1409  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fwSwqeQue added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1410  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1410  Token: IDENTIFIER        Lexeme: fwCntxt
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1410  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fwCntxt added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1411  Token: IDENTIFIER        Lexeme: dmaQue
 type_specifier -> TYPE_NAME
Line: 1411  Token: IDENTIFIER        Lexeme: fwMimQue
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1411  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: fwMimQue added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1416  Token: IDENTIFIER        Lexeme: bufQue
 type_specifier -> TYPE_NAME
Line: 1416  Token: IDENTIFIER        Lexeme: iocbBlkWaitQ
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1416  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: iocbBlkWaitQ added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1417  Token: IDENTIFIER        Lexeme: hqpQue
 type_specifier -> TYPE_NAME
Line: 1417  Token: IDENTIFIER        Lexeme: hqpRdyQ
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1417  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpRdyQ added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1418  Token: IDENTIFIER        Lexeme: hqpQue
 type_specifier -> TYPE_NAME
Line: 1418  Token: IDENTIFIER        Lexeme: genWaitQ
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1418  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: genWaitQ added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1420  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1420  Token: IDENTIFIER        Lexeme: iocbBuf
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1420  Token: [  Lexeme: [
Line: 1420  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1420  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1420  Token: ATTRIBUTE         Lexeme: __attribute__
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: iocbBuf added to idList
 init_declarator_list -> init_declarator
 attribute_specifier -> ATTRIBUTE
Line: 1420  Token: (  Lexeme: (
Line: 1420  Token: (  Lexeme: (
Line: 1420  Token: IDENTIFIER        Lexeme: section
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1420  Token: (  Lexeme: (
Line: 1420  Token: STRING_LITERAL    Lexeme: ".off_data"
 primary_expression -> STRING_LITERAL
 postfix_expression -> primary_expression
Line: 1420  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1420  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1420  Token: IDENTIFIER        Lexeme: aligned
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1420  Token: (  Lexeme: (
Line: 1420  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1420  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1420  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> expression ',' assignment_expression
 primary_expression -> '(' expression ')'
Line: 1420  Token: COMPLEX           Lexeme: )
 attribute_specifier '(' primary_expression ')' 
Line: 1420  Token: ;  Lexeme: ;
 declaration -> declaration_specifiers init_declarator_list attribute_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1425  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1425  Token: IDENTIFIER        Lexeme: drpCrpArray
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1425  Token: [  Lexeme: [
Line: 1425  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1425  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1425  Token: ATTRIBUTE         Lexeme: __attribute__
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: drpCrpArray added to idList
 init_declarator_list -> init_declarator
 attribute_specifier -> ATTRIBUTE
Line: 1425  Token: (  Lexeme: (
Line: 1425  Token: (  Lexeme: (
Line: 1425  Token: IDENTIFIER        Lexeme: section
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1425  Token: (  Lexeme: (
Line: 1425  Token: STRING_LITERAL    Lexeme: ".off_data"
 primary_expression -> STRING_LITERAL
 postfix_expression -> primary_expression
Line: 1425  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1425  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1425  Token: IDENTIFIER        Lexeme: aligned
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1425  Token: (  Lexeme: (
Line: 1425  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1425  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1425  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> expression ',' assignment_expression
 primary_expression -> '(' expression ')'
Line: 1425  Token: COMPLEX           Lexeme: )
 attribute_specifier '(' primary_expression ')' 
Line: 1425  Token: ;  Lexeme: ;
 declaration -> declaration_specifiers init_declarator_list attribute_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1430  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1430  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1430  Token: IDENTIFIER        Lexeme: HqpLookup
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1430  Token: [  Lexeme: [
Line: 1430  Token: (  Lexeme: (
Line: 1430  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1430  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1430  Token: CONSTANT          Lexeme: 11
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1430  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1430  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1430  Token: ATTRIBUTE         Lexeme: __attribute__
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: HqpLookup added to idList
 init_declarator_list -> init_declarator
 attribute_specifier -> ATTRIBUTE
Line: 1430  Token: (  Lexeme: (
Line: 1430  Token: (  Lexeme: (
Line: 1430  Token: IDENTIFIER        Lexeme: section
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1430  Token: (  Lexeme: (
Line: 1430  Token: STRING_LITERAL    Lexeme: ".off_data"
 primary_expression -> STRING_LITERAL
 postfix_expression -> primary_expression
Line: 1430  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1430  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1430  Token: IDENTIFIER        Lexeme: aligned
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1430  Token: (  Lexeme: (
Line: 1430  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1430  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1430  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> expression ',' assignment_expression
 primary_expression -> '(' expression ')'
Line: 1430  Token: COMPLEX           Lexeme: )
 attribute_specifier '(' primary_expression ')' 
Line: 1430  Token: ;  Lexeme: ;
 declaration -> declaration_specifiers init_declarator_list attribute_specifiers ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1435  Token: IDENTIFIER        Lexeme: sqCntxtEntry
 type_specifier -> TYPE_NAME
Line: 1435  Token: IDENTIFIER        Lexeme: sqCntxt
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1435  Token: [  Lexeme: [
Line: 1435  Token: (  Lexeme: (
Line: 1435  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1435  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1435  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1435  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: sqCntxt added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1437  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 1437  Token: IDENTIFIER        Lexeme: dmaCbArray
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1437  Token: [  Lexeme: [
Line: 1437  Token: (  Lexeme: (
Line: 1437  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1437  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1437  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1437  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dmaCbArray added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1438  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1438  Token: IDENTIFIER        Lexeme: hqpCbArray
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1438  Token: [  Lexeme: [
Line: 1438  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1438  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1438  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpCbArray added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1440  Token: IDENTIFIER        Lexeme: hqpCntxtEntry
 type_specifier -> TYPE_NAME
Line: 1440  Token: IDENTIFIER        Lexeme: hqpCntxt
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1440  Token: [  Lexeme: [
Line: 1440  Token: (  Lexeme: (
Line: 1440  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1440  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1440  Token: CONSTANT          Lexeme: 11
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1440  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1440  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1440  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpCntxt added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1441  Token: IDENTIFIER        Lexeme: sqCntxtEntry
 type_specifier -> TYPE_NAME
Line: 1441  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1441  Token: IDENTIFIER        Lexeme: sqHash
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1441  Token: [  Lexeme: [
Line: 1441  Token: (  Lexeme: (
Line: 1441  Token: CONSTANT          Lexeme: 64
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1441  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1441  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 direct_declarator -> direct_declarator '[' assignment_expression ']'
Line: 1441  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: sqHash added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1448  Token: IDENTIFIER        Lexeme: bufQue
 type_specifier -> TYPE_NAME
Line: 1448  Token: IDENTIFIER        Lexeme: drpCrpFreePool
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1448  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: drpCrpFreePool added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1450  Token: IDENTIFIER        Lexeme: hqpQue
 type_specifier -> TYPE_NAME
Line: 1450  Token: IDENTIFIER        Lexeme: drpCrpWaitQ
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1450  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: drpCrpWaitQ added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1452  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1452  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1452  Token: IDENTIFIER        Lexeme: actNumIocbBlks
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1452  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: actNumIocbBlks added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1456  Token: IDENTIFIER        Lexeme: hqpQue
 type_specifier -> TYPE_NAME
Line: 1456  Token: IDENTIFIER        Lexeme: dmaCbWaitQ
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1456  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dmaCbWaitQ added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1459  Token: IDENTIFIER        Lexeme: hqpQue
 type_specifier -> TYPE_NAME
Line: 1459  Token: IDENTIFIER        Lexeme: hqpCbFreePool
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1459  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpCbFreePool added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 external_declaration -> declaration
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1463  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1463  Token: IDENTIFIER        Lexeme: main
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1463  Token: (  Lexeme: (
Line: 1463  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1463  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1463  Token: {  Lexeme: {
 declarator -> direct_declarator
Line: 1465  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1465  Token: IDENTIFIER        Lexeme: i
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1465  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: i added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 1467  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 1467  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1467  Token: IDENTIFIER        Lexeme: pDmaCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1467  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1467  Token: IDENTIFIER        Lexeme: dmaCbArray
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1467  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDmaCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1469  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1469  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1469  Token: IDENTIFIER        Lexeme: pIocbBuf
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1469  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1469  Token: IDENTIFIER        Lexeme: iocbBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1469  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pIocbBuf added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1471  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1471  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1471  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1471  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1471  Token: IDENTIFIER        Lexeme: drpCrpArray
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1471  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDrpCrpDesc added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1472  Token: IDENTIFIER        Lexeme: bufQue
 type_specifier -> TYPE_NAME
Line: 1472  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1472  Token: IDENTIFIER        Lexeme: pDrpCrpFreePool
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1472  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1472  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1472  Token: IDENTIFIER        Lexeme: drpCrpFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1472  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDrpCrpFreePool added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1474  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1474  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1474  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1474  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1474  Token: IDENTIFIER        Lexeme: hqpCbArray
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1474  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1475  Token: IDENTIFIER        Lexeme: hqpQue
 type_specifier -> TYPE_NAME
Line: 1475  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1475  Token: IDENTIFIER        Lexeme: pHqpCbFreePool
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1475  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1475  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1475  Token: IDENTIFIER        Lexeme: hqpCbFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1475  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pHqpCbFreePool added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1481  Token: IDENTIFIER        Lexeme: rMb
Line: 1481  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1481  Token: (  Lexeme: (
Line: 1481  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1481  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1481  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
Line: 1481  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1481  Token: CONSTANT          Lexeme: 0x7020
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1481  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1487  Token: IDENTIFIER        Lexeme: shdMb0
Line: 1487  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1487  Token: CONSTANT          Lexeme: 0x0001
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1487  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1488  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1488  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1488  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1488  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1488  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1493  Token: IDENTIFIER        Lexeme: iocbDma
Line: 1493  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1493  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1493  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1493  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1493  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1494  Token: IDENTIFIER        Lexeme: iocbDma
Line: 1494  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1494  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1494  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1494  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1494  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1495  Token: IDENTIFIER        Lexeme: hostDma
Line: 1495  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1495  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1495  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1495  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1495  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1496  Token: IDENTIFIER        Lexeme: hostDma
Line: 1496  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1496  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1496  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1496  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1496  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1497  Token: IDENTIFIER        Lexeme: mimDma
Line: 1497  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1497  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1497  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1497  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1497  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1498  Token: IDENTIFIER        Lexeme: mimDma
Line: 1498  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1498  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1498  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1498  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1498  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1499  Token: IDENTIFIER        Lexeme: mqsDma
Line: 1499  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1499  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1499  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1499  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1499  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1500  Token: IDENTIFIER        Lexeme: mqsDma
Line: 1500  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1500  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1500  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1500  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1500  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1501  Token: IDENTIFIER        Lexeme: hqpCtxDma
Line: 1501  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1501  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1501  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1501  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1501  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1502  Token: IDENTIFIER        Lexeme: hqpCtxDma
Line: 1502  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1502  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1502  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1502  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1502  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1503  Token: IDENTIFIER        Lexeme: swqeDma
Line: 1503  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1503  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1503  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1503  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1503  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1504  Token: IDENTIFIER        Lexeme: swqeDma
Line: 1504  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1504  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1504  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1504  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1504  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1509  Token: IDENTIFIER        Lexeme: fwDsdQue
Line: 1509  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1509  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1509  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1509  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1509  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1510  Token: IDENTIFIER        Lexeme: fwDsdQue
Line: 1510  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1510  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1510  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1510  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1510  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1511  Token: IDENTIFIER        Lexeme: fwSwqeQue
Line: 1511  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1511  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1511  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1511  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1511  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1512  Token: IDENTIFIER        Lexeme: fwSwqeQue
Line: 1512  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1512  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1512  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1512  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1512  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1513  Token: IDENTIFIER        Lexeme: fwCntxt
Line: 1513  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1513  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1513  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1513  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1513  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1514  Token: IDENTIFIER        Lexeme: fwCntxt
Line: 1514  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1514  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1514  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1514  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1514  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1515  Token: IDENTIFIER        Lexeme: fwMimQue
Line: 1515  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1515  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1515  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1515  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1515  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1516  Token: IDENTIFIER        Lexeme: fwMimQue
Line: 1516  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1516  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1516  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1516  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1516  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1521  Token: IDENTIFIER        Lexeme: iocbBlkWaitQ
Line: 1521  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1521  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1521  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1521  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1521  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1522  Token: IDENTIFIER        Lexeme: iocbBlkWaitQ
Line: 1522  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1522  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1522  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1522  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1522  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1524  Token: IDENTIFIER        Lexeme: drpCrpWaitQ
Line: 1524  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1524  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1524  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1524  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1524  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1525  Token: IDENTIFIER        Lexeme: drpCrpWaitQ
Line: 1525  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1525  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1525  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1525  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1525  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1527  Token: IDENTIFIER        Lexeme: hqpRdyQ
Line: 1527  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1527  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1527  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1527  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1527  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1528  Token: IDENTIFIER        Lexeme: hqpRdyQ
Line: 1528  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1528  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1528  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1528  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1528  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1533  Token: IDENTIFIER        Lexeme: drpCrpFreePool
Line: 1533  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1533  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1533  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1533  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1533  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1534  Token: IDENTIFIER        Lexeme: drpCrpFreePool
Line: 1534  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1534  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1534  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1534  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1534  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1539  Token: IDENTIFIER        Lexeme: hqpCbFreePool
Line: 1539  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1539  Token: IDENTIFIER        Lexeme: head
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1539  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1539  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1539  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1540  Token: IDENTIFIER        Lexeme: hqpCbFreePool
Line: 1540  Token: .  Lexeme: .
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1540  Token: IDENTIFIER        Lexeme: tail
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1540  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1540  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1540  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1546  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1546  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1546  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1546  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1546  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1546  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1546  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1546  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1546  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1546  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1546  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1546  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1546  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: (  Lexeme: (
Line: 1546  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1546  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1546  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1546  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1546  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1546  Token: PTR_OP            Lexeme: ->
Line: 1546  Token: IDENTIFIER        Lexeme: hqmHqpStatusReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1546  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1546  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1546  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1546  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1546  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1546  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1546  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1546  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1547  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1547  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1547  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1547  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1547  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1547  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1547  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1547  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1547  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1547  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1547  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1547  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1547  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1547  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1547  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1547  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1547  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1547  Token: PTR_OP            Lexeme: ->
Line: 1547  Token: IDENTIFIER        Lexeme: FreePoolFifoReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1547  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1547  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1547  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1547  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1547  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1547  Token: (  Lexeme: (
Line: 1547  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1547  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1547  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1547  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1547  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1547  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1549  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1549  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1549  Token: IDENTIFIER        Lexeme: dummyHqpId
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1549  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: dummyHqpId added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1550  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1550  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1550  Token: IDENTIFIER        Lexeme: dummyBufAdr
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1550  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: dummyBufAdr added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1552  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1552  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1552  Token: IDENTIFIER        Lexeme: loopCount
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1552  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 1552  Token: CONSTANT          Lexeme: 256
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1552  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: loopCount added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1554  Token: WHILE             Lexeme: while
Line: 1554  Token: (  Lexeme: (
Line: 1554  Token: IDENTIFIER        Lexeme: dequeAbFifo
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1554  Token: (  Lexeme: (
Line: 1554  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1554  Token: IDENTIFIER        Lexeme: dummyHqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1554  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 1554  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1554  Token: IDENTIFIER        Lexeme: dummyBufAdr
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1554  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1554  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1554  Token: {  Lexeme: {
Line: 1558  Token: IF                Lexeme: if
Line: 1558  Token: (  Lexeme: (
Line: 1558  Token: DEC_OP            Lexeme: --
Line: 1558  Token: IDENTIFIER        Lexeme: loopCount
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1558  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 unary_expression -> DEC_OP unary_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1558  Token: {  Lexeme: {
Line: 1559  Token: IDENTIFIER        Lexeme: exit
Line: 1559  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1559  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1559  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1559  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1560  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1561  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1563  Token: FOR               Lexeme: for
Line: 1563  Token: (  Lexeme: (
Line: 1563  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1563  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1563  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1563  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
Line: 1563  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1563  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 1563  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1563  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
Line: 1563  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1563  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 1563  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1563  Token: {  Lexeme: {
Line: 1565  Token: IF                Lexeme: if
Line: 1565  Token: (  Lexeme: (
Line: 1565  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1565  Token: IDENTIFIER        Lexeme: enqueFpFifo
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1565  Token: (  Lexeme: (
Line: 1565  Token: (  Lexeme: (
Line: 1565  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1565  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1565  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1565  Token: IDENTIFIER        Lexeme: pIocbBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1565  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1565  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1565  Token: {  Lexeme: {
Line: 1566  Token: BREAK             Lexeme: break
Line: 1566  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1567  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1567  Token: ELSE              Lexeme: else
Line: 1567  Token: {  Lexeme: {
Line: 1568  Token: IDENTIFIER        Lexeme: pIocbBuf
Line: 1568  Token: INC_OP            Lexeme: ++
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 postfix_expression -> postfix_expression INC_OP
Line: 1568  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1569  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1570  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> FOR '(' expression_statement expression_statement expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1572  Token: IDENTIFIER        Lexeme: actNumIocbBlks
Line: 1572  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1572  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1572  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1579  Token: IF                Lexeme: if
Line: 1579  Token: (  Lexeme: (
Line: 1579  Token: IDENTIFIER        Lexeme: actNumIocbBlks
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1579  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 1579  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1579  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1579  Token: {  Lexeme: {
Line: 1580  Token: ;  Lexeme: ;
 expression_statement -> ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1581  Token: ;  Lexeme: ;
 expression_statement -> ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1582  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1584  Token: FOR               Lexeme: for
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1584  Token: (  Lexeme: (
Line: 1584  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1584  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1584  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1584  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
Line: 1584  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1584  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 1584  Token: CONSTANT          Lexeme: 8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1584  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
Line: 1584  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1584  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 1584  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1584  Token: {  Lexeme: {
Line: 1585  Token: IDENTIFIER        Lexeme: enque
Line: 1585  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1585  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1585  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 1585  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 1585  Token: IDENTIFIER        Lexeme: pDrpCrpFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1585  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1585  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1586  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> FOR '(' expression_statement expression_statement expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1588  Token: FOR               Lexeme: for
Line: 1588  Token: (  Lexeme: (
Line: 1588  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1588  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1588  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1588  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
Line: 1588  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1588  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 1588  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1588  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
Line: 1588  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1588  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 1588  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1588  Token: {  Lexeme: {
Line: 1589  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1589  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1589  Token: IDENTIFIER        Lexeme: pDmaCb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1589  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1589  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1589  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 1589  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1590  Token: IDENTIFIER        Lexeme: enque
Line: 1590  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1590  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1590  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 1590  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 1590  Token: IDENTIFIER        Lexeme: pHqpCbFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1590  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1590  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1591  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> FOR '(' expression_statement expression_statement expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1598  Token: FOR               Lexeme: for
Line: 1598  Token: (  Lexeme: (
Line: 1598  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1598  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1598  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1598  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
Line: 1598  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1598  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 1598  Token: (  Lexeme: (
Line: 1598  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1598  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1598  Token: CONSTANT          Lexeme: 11
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1598  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1598  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
Line: 1598  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1598  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 1598  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1598  Token: {  Lexeme: {
Line: 1599  Token: IDENTIFIER        Lexeme: HqpLookup
Line: 1599  Token: [  Lexeme: [
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1599  Token: IDENTIFIER        Lexeme: i
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1599  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1599  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1599  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1599  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1600  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> FOR '(' expression_statement expression_statement expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1608  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1608  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1608  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1608  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1608  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1608  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1608  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1608  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1608  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1608  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1608  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1608  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1608  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: (  Lexeme: (
Line: 1608  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1608  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1608  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1608  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1608  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1608  Token: PTR_OP            Lexeme: ->
Line: 1608  Token: IDENTIFIER        Lexeme: hqmNumIocbPerBlockReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1608  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1608  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1608  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1608  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1608  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1608  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1608  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1608  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1615  Token: IDENTIFIER        Lexeme: initHdwRegs
Line: 1615  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1615  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 1615  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1616  Token: IDENTIFIER        Lexeme: initMim
Line: 1616  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1616  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 1616  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1617  Token: IDENTIFIER        Lexeme: initOpcodeFormatRam
Line: 1617  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1617  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 1617  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1618  Token: IDENTIFIER        Lexeme: initContext
Line: 1618  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1618  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 1618  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1620  Token: IDENTIFIER        Lexeme: shdMb0
Line: 1620  Token: AND_ASSIGN        Lexeme: &=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> AND_ASSIGN
Line: 1620  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 1620  Token: CONSTANT          Lexeme: 0x0001
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1620  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1621  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1621  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1621  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1621  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1621  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1623  Token: IDENTIFIER        Lexeme: mainLoop
Line: 1623  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1623  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 1623  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1625  Token: RETURN            Lexeme: return
Line: 1625  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1625  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1626  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 function_definition -> declaration_specifiers declarator compound_statement
 external_declaration -> function_definition
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1628  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1628  Token: IDENTIFIER        Lexeme: mainLoop
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1628  Token: (  Lexeme: (
Line: 1628  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1628  Token: COMPLEX           Lexeme: )
 declaration_specifiers -> type_specifier
 parameter_declaration -> declaration_specifiers
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1628  Token: {  Lexeme: {
 declarator -> direct_declarator
Line: 1630  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1630  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1630  Token: IDENTIFIER        Lexeme: hqmStatusReg
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1630  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqmStatusReg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 1636  Token: IDENTIFIER        Lexeme: shdMb0
Line: 1636  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1636  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1636  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1637  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1637  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1637  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1637  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1637  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1642  Token: WHILE             Lexeme: while
Line: 1642  Token: (  Lexeme: (
Line: 1642  Token: IDENTIFIER        Lexeme: passCount
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1642  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 1642  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1642  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1642  Token: {  Lexeme: {
Line: 1644  Token: IF                Lexeme: if
Line: 1644  Token: (  Lexeme: (
Line: 1644  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1644  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1644  Token: (  Lexeme: (
Line: 1644  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1644  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1644  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1644  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1644  Token: {  Lexeme: {
Line: 1645  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1645  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1645  Token: IDENTIFIER        Lexeme: treg
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1645  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: treg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 1646  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 1646  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1646  Token: IDENTIFIER        Lexeme: pDmaCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1646  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pDmaCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1647  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 1647  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1647  Token: IDENTIFIER        Lexeme: pNextDmaCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1647  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pNextDmaCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1651  Token: IDENTIFIER        Lexeme: treg
Line: 1651  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1651  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1651  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1651  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1651  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1651  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1651  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1651  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1651  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1651  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1651  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1651  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1651  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1651  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: (  Lexeme: (
Line: 1651  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1651  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1651  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1651  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1651  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1651  Token: PTR_OP            Lexeme: ->
Line: 1651  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1651  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1651  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1651  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1651  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1651  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1651  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1652  Token: IF                Lexeme: if
Line: 1652  Token: (  Lexeme: (
Line: 1652  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1652  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1652  Token: (  Lexeme: (
Line: 1652  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1652  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1652  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1652  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1652  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1652  Token: {  Lexeme: {
Line: 1654  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 1654  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1654  Token: (  Lexeme: (
Line: 1654  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 1654  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1654  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1654  Token: IDENTIFIER        Lexeme: deque
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1654  Token: (  Lexeme: (
Line: 1654  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1654  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1654  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1654  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1655  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 1655  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1655  Token: IDENTIFIER        Lexeme: result
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1655  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1655  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1655  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1660  Token: IF                Lexeme: if
Line: 1660  Token: (  Lexeme: (
Line: 1660  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1660  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1660  Token: (  Lexeme: (
Line: 1660  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1660  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1660  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1660  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1660  Token: {  Lexeme: {
Line: 1662  Token: IDENTIFIER        Lexeme: pNextDmaCb
Line: 1662  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1662  Token: (  Lexeme: (
Line: 1662  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 1662  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1662  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1662  Token: IDENTIFIER        Lexeme: top
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1662  Token: (  Lexeme: (
Line: 1662  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1662  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1662  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1662  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1665  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1665  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1665  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1665  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1665  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1665  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1665  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1665  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1665  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1665  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1665  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1665  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1665  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1665  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1665  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1665  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1665  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1665  Token: PTR_OP            Lexeme: ->
Line: 1665  Token: IDENTIFIER        Lexeme: hostDmaSpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1665  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1665  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1665  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1665  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1665  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1665  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1665  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1665  Token: IDENTIFIER        Lexeme: pNextDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1665  Token: PTR_OP            Lexeme: ->
Line: 1665  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1665  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1665  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1665  Token: (  Lexeme: (
Line: 1665  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1665  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1665  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1665  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1665  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1666  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1666  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1666  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1666  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1666  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1666  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1666  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1666  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1666  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1666  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1666  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1666  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1666  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: (  Lexeme: (
Line: 1666  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1666  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1666  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1666  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1666  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1666  Token: PTR_OP            Lexeme: ->
Line: 1666  Token: IDENTIFIER        Lexeme: hostDmaAdrlReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1666  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1666  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1666  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1666  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1666  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1666  Token: IDENTIFIER        Lexeme: pNextDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1666  Token: PTR_OP            Lexeme: ->
Line: 1666  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1666  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1666  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1667  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1667  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1667  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1667  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1667  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1667  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1667  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1667  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1667  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1667  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1667  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1667  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1667  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: (  Lexeme: (
Line: 1667  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1667  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1667  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1667  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1667  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1667  Token: PTR_OP            Lexeme: ->
Line: 1667  Token: IDENTIFIER        Lexeme: hostDmaAdrhReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1667  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1667  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1667  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1667  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1667  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1667  Token: IDENTIFIER        Lexeme: pNextDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1667  Token: PTR_OP            Lexeme: ->
Line: 1667  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1667  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1667  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1668  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1668  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1668  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1668  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1668  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1668  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1668  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1668  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1668  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1668  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1668  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1668  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1668  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: (  Lexeme: (
Line: 1668  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1668  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1668  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1668  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1668  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1668  Token: PTR_OP            Lexeme: ->
Line: 1668  Token: IDENTIFIER        Lexeme: hostDmaHqpIdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1668  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1668  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1668  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1668  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1668  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1668  Token: IDENTIFIER        Lexeme: pNextDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1668  Token: PTR_OP            Lexeme: ->
Line: 1668  Token: IDENTIFIER        Lexeme: hqpId
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1668  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1668  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1669  Token: IDENTIFIER        Lexeme: treg
Line: 1669  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1669  Token: (  Lexeme: (
Line: 1669  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1669  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1669  Token: CONSTANT          Lexeme: 14
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1669  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1669  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1669  Token: IDENTIFIER        Lexeme: pNextDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1669  Token: PTR_OP            Lexeme: ->
Line: 1669  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1669  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1671  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1671  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1671  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1671  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1671  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1671  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1671  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1671  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1671  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1671  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1671  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1671  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1671  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: (  Lexeme: (
Line: 1671  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1671  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1671  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1671  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1671  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1671  Token: PTR_OP            Lexeme: ->
Line: 1671  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1671  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1671  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1671  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1671  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1671  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1671  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1671  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1671  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1679  Token: IDENTIFIER        Lexeme: hostDmaHdwSim
Line: 1679  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1679  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 1679  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1686  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1690  Token: IDENTIFIER        Lexeme: ProcessSlowPathRequest
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1690  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1690  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1690  Token: PTR_OP            Lexeme: ->
Line: 1690  Token: IDENTIFIER        Lexeme: hqpId
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1690  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1690  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1691  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1692  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1694  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1694  Token: (  Lexeme: (
Line: 1694  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1694  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1694  Token: (  Lexeme: (
Line: 1694  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1694  Token: IDENTIFIER        Lexeme: drpCrpWaitQ
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1694  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1694  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1694  Token: {  Lexeme: {
Line: 1695  Token: IF                Lexeme: if
Line: 1695  Token: (  Lexeme: (
Line: 1695  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1695  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1695  Token: (  Lexeme: (
Line: 1695  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1695  Token: IDENTIFIER        Lexeme: drpCrpFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1695  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1695  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1695  Token: {  Lexeme: {
Line: 1696  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1696  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1696  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1696  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1696  Token: (  Lexeme: (
Line: 1696  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1696  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1696  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1696  Token: IDENTIFIER        Lexeme: deque
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1696  Token: (  Lexeme: (
Line: 1696  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1696  Token: IDENTIFIER        Lexeme: drpCrpWaitQ
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1696  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1696  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 1697  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1697  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1697  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1697  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 1697  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1697  Token: PTR_OP            Lexeme: ->
Line: 1697  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1697  Token: PTR_OP            Lexeme: ->
Line: 1697  Token: IDENTIFIER        Lexeme: hqpId
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1697  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1697  Token: (  Lexeme: (
Line: 1697  Token: CONSTANT          Lexeme: 0x7FF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1697  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1697  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: hqpId added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1698  Token: IF                Lexeme: if
Line: 1698  Token: (  Lexeme: (
Line: 1698  Token: IDENTIFIER        Lexeme: allocDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1698  Token: (  Lexeme: (
Line: 1698  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1698  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1698  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1698  Token: {  Lexeme: {
Line: 1699  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1699  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1699  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1699  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1699  Token: IDENTIFIER        Lexeme: HQP_STATE_PROC_IOCB
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1699  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1700  Token: IDENTIFIER        Lexeme: processIocb
Line: 1700  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1700  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1700  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1700  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1701  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1701  Token: ELSE              Lexeme: else
Line: 1701  Token: {  Lexeme: {
Line: 1704  Token: }  Lexeme: }
 compound_statement -> '{' '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1705  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1706  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1711  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1711  Token: (  Lexeme: (
Line: 1711  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1711  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1711  Token: (  Lexeme: (
Line: 1711  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1711  Token: IDENTIFIER        Lexeme: iocbBlkWaitQ
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1711  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1711  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1711  Token: {  Lexeme: {
Line: 1712  Token: IF                Lexeme: if
Line: 1712  Token: (  Lexeme: (
Line: 1712  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1712  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1712  Token: (  Lexeme: (
Line: 1712  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1712  Token: IDENTIFIER        Lexeme: hqpCbFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1712  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1712  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1712  Token: {  Lexeme: {
Line: 1713  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1713  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1713  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1713  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1713  Token: (  Lexeme: (
Line: 1713  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1713  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1713  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1713  Token: IDENTIFIER        Lexeme: deque
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1713  Token: (  Lexeme: (
Line: 1713  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1713  Token: IDENTIFIER        Lexeme: hqpCbFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1713  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1713  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 1714  Token: IDENTIFIER        Lexeme: memset
Line: 1714  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1714  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1714  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 1714  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1714  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
Line: 1714  Token: SIZEOF            Lexeme: sizeof
Line: 1714  Token: (  Lexeme: (
Line: 1714  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1714  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 1714  Token: COMPLEX           Lexeme: )
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1714  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1715  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1715  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1715  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1715  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1715  Token: (  Lexeme: (
Line: 1715  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1715  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1715  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1715  Token: IDENTIFIER        Lexeme: deque
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1715  Token: (  Lexeme: (
Line: 1715  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1715  Token: IDENTIFIER        Lexeme: iocbBlkWaitQ
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1715  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1715  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1716  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1716  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1716  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1716  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 1716  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1716  Token: PTR_OP            Lexeme: ->
Line: 1716  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1716  Token: PTR_OP            Lexeme: ->
Line: 1716  Token: IDENTIFIER        Lexeme: hqpId
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1716  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1716  Token: (  Lexeme: (
Line: 1716  Token: CONSTANT          Lexeme: 0x7FF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1716  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1716  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: hqpId added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1717  Token: IF                Lexeme: if
Line: 1717  Token: (  Lexeme: (
Line: 1717  Token: IDENTIFIER        Lexeme: HqpLookup
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1717  Token: [  Lexeme: [
Line: 1717  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1717  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1717  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1717  Token: {  Lexeme: {
Line: 1718  Token: ;  Lexeme: ;
 expression_statement -> ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1719  Token: ;  Lexeme: ;
 expression_statement -> ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1722  Token: IDENTIFIER        Lexeme: enque
Line: 1722  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1722  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1722  Token: PTR_OP            Lexeme: ->
Line: 1722  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1722  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 1722  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1722  Token: IDENTIFIER        Lexeme: iocbBlkWaitQ
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1722  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1722  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1723  Token: IDENTIFIER        Lexeme: enque
Line: 1723  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1723  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1723  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 1723  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1723  Token: IDENTIFIER        Lexeme: hqpCbFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1723  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1723  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1725  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1725  Token: ELSE              Lexeme: else
Line: 1725  Token: {  Lexeme: {
Line: 1730  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1730  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1730  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1730  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1730  Token: IDENTIFIER        Lexeme: HQP_STATE_SLOW_PATH_REQ
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1730  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1731  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1731  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1731  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1731  Token: PTR_OP            Lexeme: ->
Line: 1731  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1731  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1731  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1731  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1732  Token: IDENTIFIER        Lexeme: HqpLookup
Line: 1732  Token: [  Lexeme: [
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1732  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1732  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1732  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1732  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1732  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1733  Token: IDENTIFIER        Lexeme: ProcessSlowPathRequest
Line: 1733  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1733  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1733  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1733  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1734  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1735  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1736  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1738  Token: UNSIGNED          Lexeme: unsigned
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 type_specifier -> UNSIGNED
Line: 1738  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1738  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1738  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: hqpId added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1739  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1739  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1739  Token: IDENTIFIER        Lexeme: rawAbFifoData
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1739  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: rawAbFifoData added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1740  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1740  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1740  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1740  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1741  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1741  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1741  Token: IDENTIFIER        Lexeme: buf
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1741  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: buf added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1743  Token: WHILE             Lexeme: while
Line: 1743  Token: (  Lexeme: (
Line: 1743  Token: IDENTIFIER        Lexeme: dequeAbFifo
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1743  Token: (  Lexeme: (
Line: 1743  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1743  Token: IDENTIFIER        Lexeme: rawAbFifoData
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1743  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 1743  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1743  Token: IDENTIFIER        Lexeme: buf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1743  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1743  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1743  Token: {  Lexeme: {
Line: 1745  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1745  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1745  Token: IDENTIFIER        Lexeme: curBlk
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1745  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: curBlk added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 1746  Token: IDENTIFIER        Lexeme: hqpId
Line: 1746  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1746  Token: IDENTIFIER        Lexeme: rawAbFifoData
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1746  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1746  Token: (  Lexeme: (
Line: 1746  Token: CONSTANT          Lexeme: 0x7FF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1746  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1746  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1747  Token: IDENTIFIER        Lexeme: buf
Line: 1747  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1747  Token: IDENTIFIER        Lexeme: hqpId
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1747  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1747  Token: IDENTIFIER        Lexeme: rawAbFifoData
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1747  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1751  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1751  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1751  Token: IDENTIFIER        Lexeme: HqpLookup
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1751  Token: [  Lexeme: [
Line: 1751  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1751  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1751  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1756  Token: IF                Lexeme: if
Line: 1756  Token: (  Lexeme: (
Line: 1756  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1756  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1756  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1756  Token: {  Lexeme: {
Line: 1757  Token: IF                Lexeme: if
Line: 1757  Token: (  Lexeme: (
Line: 1757  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1757  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1757  Token: (  Lexeme: (
Line: 1757  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1757  Token: IDENTIFIER        Lexeme: hqpCbFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1757  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1757  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1757  Token: {  Lexeme: {
Line: 1758  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1758  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1758  Token: (  Lexeme: (
Line: 1758  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1758  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1758  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1758  Token: IDENTIFIER        Lexeme: deque
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1758  Token: (  Lexeme: (
Line: 1758  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1758  Token: IDENTIFIER        Lexeme: hqpCbFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1758  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1758  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1759  Token: IDENTIFIER        Lexeme: HqpLookup
Line: 1759  Token: [  Lexeme: [
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1759  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1759  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1759  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1759  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1759  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1761  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1761  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1761  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1761  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1761  Token: IDENTIFIER        Lexeme: buf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1761  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1762  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1762  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1762  Token: IDENTIFIER        Lexeme: pCurIocb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1762  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1762  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1762  Token: PTR_OP            Lexeme: ->
Line: 1762  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1762  Token: PTR_OP            Lexeme: ->
Line: 1762  Token: IDENTIFIER        Lexeme: iocb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1762  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1763  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1763  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1763  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1763  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1763  Token: IDENTIFIER        Lexeme: HQP_STATE_SLOW_PATH_REQ
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1763  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1764  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1764  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1764  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1764  Token: PTR_OP            Lexeme: ->
Line: 1764  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1764  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1764  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1764  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1765  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1765  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1765  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1765  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1765  Token: IDENTIFIER        Lexeme: buf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1765  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1766  Token: IDENTIFIER        Lexeme: buf
Line: 1766  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1766  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1766  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1766  Token: IDENTIFIER        Lexeme: buf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1766  Token: PTR_OP            Lexeme: ->
Line: 1766  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1766  Token: .  Lexeme: .
Line: 1766  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1766  Token: .  Lexeme: .
Line: 1766  Token: IDENTIFIER        Lexeme: nxt_crp_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1766  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1767  Token: IDENTIFIER        Lexeme: buf
Line: 1767  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1767  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1767  Token: .  Lexeme: .
Line: 1767  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1767  Token: .  Lexeme: .
Line: 1767  Token: IDENTIFIER        Lexeme: nxt_crp_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1767  Token: .  Lexeme: .
Line: 1767  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1767  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1767  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1767  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1768  Token: IDENTIFIER        Lexeme: ProcessSlowPathRequest
Line: 1768  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1768  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1768  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1768  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1769  Token: BREAK             Lexeme: break
Line: 1769  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1770  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1770  Token: ELSE              Lexeme: else
Line: 1770  Token: {  Lexeme: {
Line: 1774  Token: IDENTIFIER        Lexeme: enque
Line: 1774  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1774  Token: IDENTIFIER        Lexeme: buf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1774  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 1774  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1774  Token: IDENTIFIER        Lexeme: iocbBlkWaitQ
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1774  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1774  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1775  Token: CONTINUE          Lexeme: continue
Line: 1775  Token: ;  Lexeme: ;
 jump_statement -> CONTINUE ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1776  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1777  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1782  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1782  Token: (  Lexeme: (
Line: 1782  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1782  Token: PTR_OP            Lexeme: ->
Line: 1782  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1782  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1782  Token: {  Lexeme: {
Line: 1783  Token: IDENTIFIER        Lexeme: curBlk
Line: 1783  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1783  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1783  Token: PTR_OP            Lexeme: ->
Line: 1783  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1783  Token: PTR_OP            Lexeme: ->
Line: 1783  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1783  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1784  Token: WHILE             Lexeme: while
Line: 1784  Token: (  Lexeme: (
Line: 1784  Token: IDENTIFIER        Lexeme: curBlk
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1784  Token: PTR_OP            Lexeme: ->
Line: 1784  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1784  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1784  Token: {  Lexeme: {
Line: 1785  Token: IDENTIFIER        Lexeme: curBlk
Line: 1785  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1785  Token: IDENTIFIER        Lexeme: curBlk
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1785  Token: PTR_OP            Lexeme: ->
Line: 1785  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1785  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1786  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1787  Token: IDENTIFIER        Lexeme: curBlk
Line: 1787  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1787  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1787  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1787  Token: IDENTIFIER        Lexeme: buf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1787  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1788  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1788  Token: ELSE              Lexeme: else
Line: 1788  Token: {  Lexeme: {
Line: 1789  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1789  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1789  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1789  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1789  Token: IDENTIFIER        Lexeme: buf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1789  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1790  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1790  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1790  Token: IDENTIFIER        Lexeme: iocbIndx
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1790  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1790  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1790  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1791  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1792  Token: IDENTIFIER        Lexeme: buf
Line: 1792  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1792  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1792  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1792  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1792  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1796  Token: IF                Lexeme: if
Line: 1796  Token: (  Lexeme: (
Line: 1796  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1796  Token: PTR_OP            Lexeme: ->
Line: 1796  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1796  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 1796  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_IOCB_BLK
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1796  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1796  Token: {  Lexeme: {
Line: 1797  Token: IDENTIFIER        Lexeme: ProcessSlowPathRequest
Line: 1797  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1797  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1797  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1797  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1798  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1799  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1801  Token: IF                Lexeme: if
Line: 1801  Token: (  Lexeme: (
Line: 1801  Token: IDENTIFIER        Lexeme: simIocbComplete
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1801  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1801  Token: {  Lexeme: {
Line: 1803  Token: IDENTIFIER        Lexeme: SlowPathIocb_Ct6DsdList
Line: 1803  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1803  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 1803  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1811  Token: IDENTIFIER        Lexeme: passCount
Line: 1811  Token: INC_OP            Lexeme: ++
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 postfix_expression -> postfix_expression INC_OP
Line: 1811  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1812  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1816  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1818  Token: IDENTIFIER        Lexeme: shdMb0
Line: 1818  Token: AND_ASSIGN        Lexeme: &=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> AND_ASSIGN
Line: 1818  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 1818  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1818  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1819  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1819  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1819  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1819  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1819  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1820  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 function_definition -> declaration_specifiers declarator compound_statement
 external_declaration -> function_definition
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 1822  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 1822  Token: IDENTIFIER        Lexeme: ProcessSlowPathRequest
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1822  Token: (  Lexeme: (
Line: 1822  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1822  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1822  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 1822  Token: {  Lexeme: {
 declarator -> direct_declarator
Line: 1824  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1824  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1824  Token: IDENTIFIER        Lexeme: treg
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 1824  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: treg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 1825  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 1825  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1825  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1825  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1825  Token: IDENTIFIER        Lexeme: HqpLookup
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1825  Token: [  Lexeme: [
Line: 1825  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1825  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1825  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1826  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1826  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1826  Token: IDENTIFIER        Lexeme: pDrpCrp
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1826  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pDrpCrp added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1828  Token: IF                Lexeme: if
Line: 1828  Token: (  Lexeme: (
Line: 1828  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1828  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1828  Token: [  Lexeme: [
Line: 1828  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1828  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1828  Token: .  Lexeme: .
Line: 1828  Token: IDENTIFIER        Lexeme: valid
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1828  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1828  Token: {  Lexeme: {
Line: 1836  Token: IDENTIFIER        Lexeme: getHqpContext
Line: 1836  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1836  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1836  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1836  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1837  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1843  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1843  Token: (  Lexeme: (
Line: 1843  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1843  Token: PTR_OP            Lexeme: ->
Line: 1843  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1843  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 1843  Token: IDENTIFIER        Lexeme: HQP_STATE_SLOW_PATH_REQ
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1843  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1843  Token: {  Lexeme: {
Line: 1847  Token: IDENTIFIER        Lexeme: simIocbComplete
Line: 1847  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1847  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1847  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1848  Token: IDENTIFIER        Lexeme: shdMb0
Line: 1848  Token: UNKNOWN     Lexeme: |=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> OR_ASSIGN
Line: 1848  Token: CONSTANT          Lexeme: 0x0004
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1848  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1849  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1849  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1849  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1849  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1849  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1853  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1853  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1853  Token: IDENTIFIER        Lexeme: iocbIndx
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1853  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1853  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1853  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1854  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1854  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1854  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1854  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1854  Token: IDENTIFIER        Lexeme: HQP_STATE_PROC_IOCB
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1854  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1855  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1855  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1855  Token: IDENTIFIER        Lexeme: iocbCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1855  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1855  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1855  Token: PTR_OP            Lexeme: ->
Line: 1855  Token: IDENTIFIER        Lexeme: pCurIocb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1855  Token: PTR_OP            Lexeme: ->
Line: 1855  Token: IDENTIFIER        Lexeme: hdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1855  Token: .  Lexeme: .
Line: 1855  Token: IDENTIFIER        Lexeme: iocb_count
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1855  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1856  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1856  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1856  Token: IDENTIFIER        Lexeme: numIocbProcessed
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1856  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1856  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1856  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1857  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1861  Token: WHILE             Lexeme: while
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1861  Token: (  Lexeme: (
Line: 1861  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1861  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1861  Token: {  Lexeme: {
Line: 1865  Token: IF                Lexeme: if
Line: 1865  Token: (  Lexeme: (
Line: 1865  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1865  Token: IDENTIFIER        Lexeme: processIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1865  Token: (  Lexeme: (
Line: 1865  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1865  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1865  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1865  Token: {  Lexeme: {
Line: 1866  Token: RETURN            Lexeme: return
Line: 1866  Token: ;  Lexeme: ;
 jump_statement -> RETURN ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1867  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1868  Token: IDENTIFIER        Lexeme: pHqpCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1868  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1868  Token: IDENTIFIER        Lexeme: numIocbProcessed
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1868  Token: ADD_ASSIGN        Lexeme: +=
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 1868  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1868  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1869  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1869  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1869  Token: IDENTIFIER        Lexeme: iocbIndx
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1869  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 1869  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1870  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1870  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1870  Token: IDENTIFIER        Lexeme: iocbCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1870  Token: DEC_OP            Lexeme: --
 postfix_expression -> postfix_expression DEC_OP
Line: 1870  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1872  Token: IF                Lexeme: if
Line: 1872  Token: (  Lexeme: (
Line: 1872  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1872  Token: PTR_OP            Lexeme: ->
Line: 1872  Token: IDENTIFIER        Lexeme: iocbCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1872  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1872  Token: {  Lexeme: {
Line: 1874  Token: IF                Lexeme: if
Line: 1874  Token: (  Lexeme: (
Line: 1874  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1874  Token: PTR_OP            Lexeme: ->
Line: 1874  Token: IDENTIFIER        Lexeme: iocbIndx
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1874  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 1874  Token: (  Lexeme: (
Line: 1874  Token: (  Lexeme: (
Line: 1874  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1874  Token: PTR_OP            Lexeme: ->
Line: 1874  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1874  Token: PTR_OP            Lexeme: ->
Line: 1874  Token: IDENTIFIER        Lexeme: hqpId
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1874  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1874  Token: (  Lexeme: (
Line: 1874  Token: CONSTANT          Lexeme: 0x07
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1874  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1874  Token: CONSTANT          Lexeme: 13
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1874  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1874  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1874  Token: RIGHT_OP          Lexeme: >>
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1874  Token: CONSTANT          Lexeme: 13
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1874  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression RIGHT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1874  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1874  Token: {  Lexeme: {
Line: 1875  Token: IF                Lexeme: if
Line: 1875  Token: (  Lexeme: (
Line: 1875  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1875  Token: PTR_OP            Lexeme: ->
Line: 1875  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1875  Token: PTR_OP            Lexeme: ->
Line: 1875  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1875  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1875  Token: {  Lexeme: {
Line: 1876  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1876  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1876  Token: IDENTIFIER        Lexeme: pCurIocbBlk
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1876  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1876  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1876  Token: PTR_OP            Lexeme: ->
Line: 1876  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1876  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pCurIocbBlk added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 1880  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1880  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1880  Token: IDENTIFIER        Lexeme: iocbIndx
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1880  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1880  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1880  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1884  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1884  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1884  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1884  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1884  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1884  Token: PTR_OP            Lexeme: ->
Line: 1884  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1884  Token: PTR_OP            Lexeme: ->
Line: 1884  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1884  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1885  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1885  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1885  Token: IDENTIFIER        Lexeme: pCurIocb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1885  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1885  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1885  Token: PTR_OP            Lexeme: ->
Line: 1885  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1885  Token: PTR_OP            Lexeme: ->
Line: 1885  Token: IDENTIFIER        Lexeme: iocb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1885  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1889  Token: IF                Lexeme: if
Line: 1889  Token: (  Lexeme: (
Line: 1889  Token: IDENTIFIER        Lexeme: pCurIocbBlk
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1889  Token: PTR_OP            Lexeme: ->
Line: 1889  Token: IDENTIFIER        Lexeme: hqpId
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1889  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1889  Token: (  Lexeme: (
Line: 1889  Token: CONSTANT          Lexeme: 0x03
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1889  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1889  Token: CONSTANT          Lexeme: 11
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1889  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1889  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1889  Token: {  Lexeme: {
Line: 1890  Token: IDENTIFIER        Lexeme: enqueFpFifo
Line: 1890  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1890  Token: (  Lexeme: (
Line: 1890  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1890  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1890  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1890  Token: IDENTIFIER        Lexeme: pCurIocbBlk
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1890  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1890  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1891  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1893  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1893  Token: ELSE              Lexeme: else
Line: 1893  Token: {  Lexeme: {
Line: 1897  Token: IF                Lexeme: if
Line: 1897  Token: (  Lexeme: (
Line: 1897  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1897  Token: PTR_OP            Lexeme: ->
Line: 1897  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1897  Token: PTR_OP            Lexeme: ->
Line: 1897  Token: IDENTIFIER        Lexeme: hqpId
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1897  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1897  Token: (  Lexeme: (
Line: 1897  Token: CONSTANT          Lexeme: 0x03
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1897  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1897  Token: CONSTANT          Lexeme: 11
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1897  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1897  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1897  Token: {  Lexeme: {
Line: 1898  Token: IDENTIFIER        Lexeme: enqueFpFifo
Line: 1898  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1898  Token: (  Lexeme: (
Line: 1898  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1898  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1898  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1898  Token: (  Lexeme: (
Line: 1898  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1898  Token: PTR_OP            Lexeme: ->
Line: 1898  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1898  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1898  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1898  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1899  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1904  Token: IDENTIFIER        Lexeme: pHqpCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1904  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1904  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1904  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1904  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_IOCB_BLK
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1904  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1905  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1905  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1905  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1905  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1905  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1905  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1910  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1910  Token: IDENTIFIER        Lexeme: count
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1910  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 1910  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1910  Token: PTR_OP            Lexeme: ->
Line: 1910  Token: IDENTIFIER        Lexeme: iocbCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1910  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: count added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1911  Token: IF                Lexeme: if
Line: 1911  Token: (  Lexeme: (
Line: 1911  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1911  Token: PTR_OP            Lexeme: ->
Line: 1911  Token: IDENTIFIER        Lexeme: iocbCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1911  Token: >  Lexeme: >
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 1911  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1911  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '>' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1911  Token: {  Lexeme: {
Line: 1912  Token: IDENTIFIER        Lexeme: count
Line: 1912  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1912  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1912  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1913  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1914  Token: IDENTIFIER        Lexeme: treg
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1914  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1914  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1914  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1914  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1914  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1914  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1914  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1914  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1914  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1914  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1914  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1914  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1914  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1914  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: (  Lexeme: (
Line: 1914  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1914  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1914  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1914  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1914  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1914  Token: PTR_OP            Lexeme: ->
Line: 1914  Token: IDENTIFIER        Lexeme: hqpIocbFetchReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1914  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1914  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1914  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1914  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1914  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1914  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1916  Token: WHILE             Lexeme: while
Line: 1916  Token: (  Lexeme: (
Line: 1916  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1916  Token: (  Lexeme: (
Line: 1916  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1916  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1916  Token: (  Lexeme: (
Line: 1916  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1916  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1916  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1916  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1916  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1916  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1916  Token: {  Lexeme: {
Line: 1917  Token: IDENTIFIER        Lexeme: treg
Line: 1917  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1917  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1917  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1917  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1917  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1917  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1917  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1917  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1917  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1917  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1917  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1917  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1917  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1917  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: (  Lexeme: (
Line: 1917  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1917  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1917  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1917  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1917  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1917  Token: PTR_OP            Lexeme: ->
Line: 1917  Token: IDENTIFIER        Lexeme: hqpIocbFetchReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1917  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1917  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1917  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1917  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1917  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1917  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1918  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1919  Token: IDENTIFIER        Lexeme: treg
Line: 1919  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1919  Token: (  Lexeme: (
Line: 1919  Token: IDENTIFIER        Lexeme: count
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1919  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1919  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1919  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1919  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1919  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1919  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1920  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1920  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1920  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1920  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1920  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1920  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1920  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1920  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1920  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1920  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1920  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1920  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1920  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: (  Lexeme: (
Line: 1920  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1920  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1920  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1920  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1920  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1920  Token: PTR_OP            Lexeme: ->
Line: 1920  Token: IDENTIFIER        Lexeme: hqpIocbFetchReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1920  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1920  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1920  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1920  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1920  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1920  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1920  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1920  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1922  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1922  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1922  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1922  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1922  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 1922  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1922  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1923  Token: IDENTIFIER        Lexeme: hqmFetchHdwSim
Line: 1923  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1923  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 1923  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1924  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1924  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1924  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1924  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1924  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1926  Token: RETURN            Lexeme: return
Line: 1926  Token: ;  Lexeme: ;
 jump_statement -> RETURN ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1928  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1929  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1929  Token: ELSE              Lexeme: else
Line: 1929  Token: {  Lexeme: {
Line: 1933  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1933  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1933  Token: IDENTIFIER        Lexeme: pCurIocb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1933  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1933  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1933  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1933  Token: PTR_OP            Lexeme: ->
Line: 1933  Token: IDENTIFIER        Lexeme: pIocbBlkChain
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1933  Token: PTR_OP            Lexeme: ->
Line: 1933  Token: IDENTIFIER        Lexeme: iocb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1933  Token: [  Lexeme: [
Line: 1933  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1933  Token: PTR_OP            Lexeme: ->
Line: 1933  Token: IDENTIFIER        Lexeme: iocbIndx
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1933  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1933  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1934  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1936  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1936  Token: ELSE              Lexeme: else
Line: 1936  Token: {  Lexeme: {
Line: 1937  Token: BREAK             Lexeme: break
Line: 1937  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1938  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1939  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1941  Token: IDENTIFIER        Lexeme: opcodeFormatRamEntry
 type_specifier -> TYPE_NAME
Line: 1941  Token: IDENTIFIER        Lexeme: opcodeFmt
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1941  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: opcodeFmt added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1942  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 1942  Token: IDENTIFIER        Lexeme: protocol
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 1942  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 1942  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1942  Token: [  Lexeme: [
Line: 1942  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1942  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1942  Token: .  Lexeme: .
Line: 1942  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1942  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1942  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1942  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: protocol added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1945  Token: IDENTIFIER        Lexeme: opcodeFmt
Line: 1945  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1945  Token: IDENTIFIER        Lexeme: ReadOpcodeFormatRam
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1945  Token: (  Lexeme: (
Line: 1945  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1945  Token: PTR_OP            Lexeme: ->
Line: 1945  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1945  Token: PTR_OP            Lexeme: ->
Line: 1945  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1945  Token: .  Lexeme: .
Line: 1945  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1945  Token: .  Lexeme: .
Line: 1945  Token: IDENTIFIER        Lexeme: gen_iocb
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1945  Token: [  Lexeme: [
Line: 1945  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1945  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1945  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1945  Token: CONSTANT          Lexeme: 0xFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1945  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 1945  Token: IDENTIFIER        Lexeme: protocol
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1945  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1945  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1953  Token: IF                Lexeme: if
Line: 1953  Token: (  Lexeme: (
Line: 1953  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1953  Token: PTR_OP            Lexeme: ->
Line: 1953  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1953  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1953  Token: {  Lexeme: {
Line: 1954  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1954  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1954  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1954  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 1954  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1954  Token: PTR_OP            Lexeme: ->
Line: 1954  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1954  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDrpCrpDesc added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 1955  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 1955  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 1955  Token: IDENTIFIER        Lexeme: pCurDrpCrpDesc
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 1955  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pCurDrpCrpDesc added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 1959  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 1959  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1959  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1959  Token: PTR_OP            Lexeme: ->
Line: 1959  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1959  Token: .  Lexeme: .
Line: 1959  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1959  Token: .  Lexeme: .
Line: 1959  Token: IDENTIFIER        Lexeme: gen_def
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1959  Token: [  Lexeme: [
Line: 1959  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1959  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1959  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1959  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1959  Token: PTR_OP            Lexeme: ->
Line: 1959  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1959  Token: PTR_OP            Lexeme: ->
Line: 1959  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1959  Token: .  Lexeme: .
Line: 1959  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1959  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 1959  Token: CONSTANT          Lexeme: 0x80000000
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1959  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1964  Token: IF                Lexeme: if
Line: 1964  Token: (  Lexeme: (
Line: 1964  Token: IDENTIFIER        Lexeme: opcodeFmt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1964  Token: .  Lexeme: .
Line: 1964  Token: IDENTIFIER        Lexeme: createAlcbs
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1964  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1964  Token: {  Lexeme: {
Line: 1969  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 1969  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1969  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1969  Token: .  Lexeme: .
Line: 1969  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1969  Token: .  Lexeme: .
Line: 1969  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1969  Token: [  Lexeme: [
Line: 1969  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1969  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1969  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1969  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1969  Token: PTR_OP            Lexeme: ->
Line: 1969  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1969  Token: .  Lexeme: .
Line: 1969  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1969  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 1969  Token: CONSTANT          Lexeme: 0x80000000
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1969  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1970  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 1970  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1970  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1970  Token: .  Lexeme: .
Line: 1970  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1970  Token: .  Lexeme: .
Line: 1970  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1970  Token: [  Lexeme: [
Line: 1970  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1970  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1970  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1970  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1970  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1971  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 1971  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1971  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1971  Token: .  Lexeme: .
Line: 1971  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1971  Token: .  Lexeme: .
Line: 1971  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1971  Token: [  Lexeme: [
Line: 1971  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1971  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1971  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1971  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1971  Token: PTR_OP            Lexeme: ->
Line: 1971  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1971  Token: .  Lexeme: .
Line: 1971  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1971  Token: .  Lexeme: .
Line: 1971  Token: IDENTIFIER        Lexeme: dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1971  Token: [  Lexeme: [
Line: 1971  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1971  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1971  Token: .  Lexeme: .
Line: 1971  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1971  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1972  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 1972  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1972  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1972  Token: .  Lexeme: .
Line: 1972  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1972  Token: .  Lexeme: .
Line: 1972  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1972  Token: [  Lexeme: [
Line: 1972  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1972  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1972  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1972  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1972  Token: PTR_OP            Lexeme: ->
Line: 1972  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1972  Token: .  Lexeme: .
Line: 1972  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1972  Token: .  Lexeme: .
Line: 1972  Token: IDENTIFIER        Lexeme: dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1972  Token: [  Lexeme: [
Line: 1972  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1972  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1972  Token: .  Lexeme: .
Line: 1972  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1972  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1973  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 1973  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1973  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1973  Token: .  Lexeme: .
Line: 1973  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1973  Token: .  Lexeme: .
Line: 1973  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1973  Token: [  Lexeme: [
Line: 1973  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1973  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1973  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1973  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1973  Token: PTR_OP            Lexeme: ->
Line: 1973  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1973  Token: .  Lexeme: .
Line: 1973  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1973  Token: .  Lexeme: .
Line: 1973  Token: IDENTIFIER        Lexeme: dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1973  Token: [  Lexeme: [
Line: 1973  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1973  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1973  Token: .  Lexeme: .
Line: 1973  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1973  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1974  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 1974  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1974  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1974  Token: .  Lexeme: .
Line: 1974  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1974  Token: .  Lexeme: .
Line: 1974  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1974  Token: [  Lexeme: [
Line: 1974  Token: CONSTANT          Lexeme: 5
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1974  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1974  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1974  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1974  Token: PTR_OP            Lexeme: ->
Line: 1974  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1974  Token: .  Lexeme: .
Line: 1974  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1974  Token: .  Lexeme: .
Line: 1974  Token: IDENTIFIER        Lexeme: gen_iocb
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1974  Token: [  Lexeme: [
Line: 1974  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1974  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 1974  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1975  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 1977  Token: WHILE             Lexeme: while
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1977  Token: (  Lexeme: (
Line: 1977  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1977  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1977  Token: {  Lexeme: {
Line: 1979  Token: IDENTIFIER        Lexeme: treg
Line: 1979  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1979  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1979  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1979  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1979  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1979  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1979  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1979  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1979  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1979  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1979  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1979  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1979  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1979  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: (  Lexeme: (
Line: 1979  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1979  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1979  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1979  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1979  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1979  Token: PTR_OP            Lexeme: ->
Line: 1979  Token: IDENTIFIER        Lexeme: mimDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1979  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1979  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1979  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1979  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1979  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1979  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1981  Token: WHILE             Lexeme: while
Line: 1981  Token: (  Lexeme: (
Line: 1981  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 1981  Token: (  Lexeme: (
Line: 1981  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1981  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1981  Token: (  Lexeme: (
Line: 1981  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1981  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1981  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1981  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1981  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1981  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 1981  Token: {  Lexeme: {
Line: 1982  Token: IDENTIFIER        Lexeme: treg
Line: 1982  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1982  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1982  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1982  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1982  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1982  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1982  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1982  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1982  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1982  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1982  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1982  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1982  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1982  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: (  Lexeme: (
Line: 1982  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1982  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1982  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1982  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1982  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1982  Token: PTR_OP            Lexeme: ->
Line: 1982  Token: IDENTIFIER        Lexeme: mimDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1982  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1982  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1982  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1982  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1982  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1982  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 1983  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1985  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1985  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1985  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1985  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1985  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1985  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1985  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1985  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1985  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1985  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1985  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1985  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1985  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: (  Lexeme: (
Line: 1985  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1985  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1985  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1985  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1985  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1985  Token: PTR_OP            Lexeme: ->
Line: 1985  Token: IDENTIFIER        Lexeme: mimDma0AdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1985  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1985  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1985  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1985  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1985  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1985  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1985  Token: PTR_OP            Lexeme: ->
Line: 1985  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1985  Token: .  Lexeme: .
Line: 1985  Token: IDENTIFIER        Lexeme: blk_id
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1985  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1985  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1986  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1986  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1986  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1986  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1986  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1986  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1986  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1986  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1986  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1986  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1986  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1986  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1986  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: (  Lexeme: (
Line: 1986  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1986  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1986  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1986  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1986  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1986  Token: PTR_OP            Lexeme: ->
Line: 1986  Token: IDENTIFIER        Lexeme: mimDma0BlkOffsetReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1986  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1986  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1986  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1986  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1986  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1986  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1986  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1986  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1987  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1987  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1987  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1987  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1987  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1987  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1987  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1987  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1987  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1987  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1987  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1987  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1987  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1987  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1987  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1987  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1987  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1987  Token: PTR_OP            Lexeme: ->
Line: 1987  Token: IDENTIFIER        Lexeme: mimDma0SpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1987  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1987  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1987  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1987  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1987  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1987  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1987  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1987  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1987  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1987  Token: PTR_OP            Lexeme: ->
Line: 1987  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1987  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1987  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 1987  Token: (  Lexeme: (
Line: 1987  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1987  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1987  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1987  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1987  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1988  Token: IDENTIFIER        Lexeme: treg
Line: 1988  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1988  Token: (  Lexeme: (
Line: 1988  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1988  Token: PTR_OP            Lexeme: ->
Line: 1988  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1988  Token: .  Lexeme: .
Line: 1988  Token: IDENTIFIER        Lexeme: mem_rgn
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 1988  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1988  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1988  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1988  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 1988  Token: (  Lexeme: (
Line: 1988  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1988  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 1988  Token: CONSTANT          Lexeme: 15
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1988  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1988  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
Line: 1988  Token: SIZEOF            Lexeme: sizeof
Line: 1988  Token: (  Lexeme: (
Line: 1988  Token: IDENTIFIER        Lexeme: drp_crp
 type_specifier -> TYPE_NAME
Line: 1988  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 1988  Token: ;  Lexeme: ;
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 1990  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1990  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1990  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 1990  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1990  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1990  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1990  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1990  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1990  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1990  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 1990  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 1990  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 1990  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: (  Lexeme: (
Line: 1990  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 1990  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 1990  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 1990  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1990  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1990  Token: PTR_OP            Lexeme: ->
Line: 1990  Token: IDENTIFIER        Lexeme: mimDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1990  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1990  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1990  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1990  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1990  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1990  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1990  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 1990  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1993  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1993  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1993  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1993  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1993  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 1993  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 1993  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1994  Token: IDENTIFIER        Lexeme: hqmMimDma0HdwSim
Line: 1994  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1994  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 1994  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1995  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 1995  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1995  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 1995  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1995  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1997  Token: IDENTIFIER        Lexeme: pCurDrpCrpDesc
Line: 1997  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1997  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1997  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1998  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 1998  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 1998  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1998  Token: PTR_OP            Lexeme: ->
Line: 1998  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 1998  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 1999  Token: IDENTIFIER        Lexeme: enque
Line: 1999  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1999  Token: IDENTIFIER        Lexeme: pCurDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1999  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 1999  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 1999  Token: IDENTIFIER        Lexeme: drpCrpFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 1999  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 1999  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2000  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2001  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2006  Token: IDENTIFIER        Lexeme: bufDesc
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 type_specifier -> TYPE_NAME
Line: 2006  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2006  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2006  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2006  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2006  Token: PTR_OP            Lexeme: ->
Line: 2006  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2006  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDrpCrpDesc added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2012  Token: IF                Lexeme: if
Line: 2012  Token: (  Lexeme: (
Line: 2012  Token: IDENTIFIER        Lexeme: opcodeFmt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2012  Token: .  Lexeme: .
Line: 2012  Token: IDENTIFIER        Lexeme: createAlcbs
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2012  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2012  Token: {  Lexeme: {
Line: 2018  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 2018  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2018  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2018  Token: .  Lexeme: .
Line: 2018  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2018  Token: .  Lexeme: .
Line: 2018  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2018  Token: [  Lexeme: [
Line: 2018  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2018  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2018  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2018  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2018  Token: PTR_OP            Lexeme: ->
Line: 2018  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2018  Token: .  Lexeme: .
Line: 2018  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2018  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2018  Token: CONSTANT          Lexeme: 0x80000000
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2018  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2019  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 2019  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2019  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2019  Token: .  Lexeme: .
Line: 2019  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2019  Token: .  Lexeme: .
Line: 2019  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2019  Token: [  Lexeme: [
Line: 2019  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2019  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2019  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2019  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2019  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2020  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 2020  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2020  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2020  Token: .  Lexeme: .
Line: 2020  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2020  Token: .  Lexeme: .
Line: 2020  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2020  Token: [  Lexeme: [
Line: 2020  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2020  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2020  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2020  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2020  Token: PTR_OP            Lexeme: ->
Line: 2020  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2020  Token: .  Lexeme: .
Line: 2020  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2020  Token: .  Lexeme: .
Line: 2020  Token: IDENTIFIER        Lexeme: dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2020  Token: [  Lexeme: [
Line: 2020  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2020  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2020  Token: .  Lexeme: .
Line: 2020  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2020  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2021  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 2021  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2021  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2021  Token: .  Lexeme: .
Line: 2021  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2021  Token: .  Lexeme: .
Line: 2021  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2021  Token: [  Lexeme: [
Line: 2021  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2021  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2021  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2021  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2021  Token: PTR_OP            Lexeme: ->
Line: 2021  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2021  Token: .  Lexeme: .
Line: 2021  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2021  Token: .  Lexeme: .
Line: 2021  Token: IDENTIFIER        Lexeme: dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2021  Token: [  Lexeme: [
Line: 2021  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2021  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2021  Token: .  Lexeme: .
Line: 2021  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2021  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2022  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 2022  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2022  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2022  Token: .  Lexeme: .
Line: 2022  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2022  Token: .  Lexeme: .
Line: 2022  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2022  Token: [  Lexeme: [
Line: 2022  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2022  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2022  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2022  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2022  Token: PTR_OP            Lexeme: ->
Line: 2022  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2022  Token: .  Lexeme: .
Line: 2022  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2022  Token: .  Lexeme: .
Line: 2022  Token: IDENTIFIER        Lexeme: dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2022  Token: [  Lexeme: [
Line: 2022  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2022  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2022  Token: .  Lexeme: .
Line: 2022  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2022  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2023  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 2023  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2023  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2023  Token: .  Lexeme: .
Line: 2023  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2023  Token: .  Lexeme: .
Line: 2023  Token: IDENTIFIER        Lexeme: misc_data
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2023  Token: [  Lexeme: [
Line: 2023  Token: CONSTANT          Lexeme: 5
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2023  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2023  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2023  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2023  Token: PTR_OP            Lexeme: ->
Line: 2023  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2023  Token: .  Lexeme: .
Line: 2023  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2023  Token: .  Lexeme: .
Line: 2023  Token: IDENTIFIER        Lexeme: gen_iocb
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2023  Token: [  Lexeme: [
Line: 2023  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2023  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2023  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2024  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2030  Token: IDENTIFIER        Lexeme: treg
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2030  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2030  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2030  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2030  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2030  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2030  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2030  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2030  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2030  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2030  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2030  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2030  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2030  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2030  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: (  Lexeme: (
Line: 2030  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2030  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2030  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2030  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2030  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2030  Token: PTR_OP            Lexeme: ->
Line: 2030  Token: IDENTIFIER        Lexeme: mimDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2030  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2030  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2030  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2030  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2030  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2030  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2032  Token: WHILE             Lexeme: while
Line: 2032  Token: (  Lexeme: (
Line: 2032  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2032  Token: (  Lexeme: (
Line: 2032  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2032  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2032  Token: (  Lexeme: (
Line: 2032  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2032  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2032  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2032  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2032  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2032  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2032  Token: {  Lexeme: {
Line: 2033  Token: IDENTIFIER        Lexeme: treg
Line: 2033  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2033  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2033  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2033  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2033  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2033  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2033  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2033  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2033  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2033  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2033  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2033  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2033  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2033  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: (  Lexeme: (
Line: 2033  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2033  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2033  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2033  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2033  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2033  Token: PTR_OP            Lexeme: ->
Line: 2033  Token: IDENTIFIER        Lexeme: mimDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2033  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2033  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2033  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2033  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2033  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2033  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2034  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2036  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2036  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2036  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2036  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2036  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2036  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2036  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2036  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2036  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2036  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2036  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2036  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2036  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: (  Lexeme: (
Line: 2036  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2036  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2036  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2036  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2036  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2036  Token: PTR_OP            Lexeme: ->
Line: 2036  Token: IDENTIFIER        Lexeme: mimDma0AdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2036  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2036  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2036  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2036  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2036  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2036  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2036  Token: PTR_OP            Lexeme: ->
Line: 2036  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2036  Token: .  Lexeme: .
Line: 2036  Token: IDENTIFIER        Lexeme: blk_id
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2036  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2036  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2037  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2037  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2037  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2037  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2037  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2037  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2037  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2037  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2037  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2037  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2037  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2037  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2037  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: (  Lexeme: (
Line: 2037  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2037  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2037  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2037  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2037  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2037  Token: PTR_OP            Lexeme: ->
Line: 2037  Token: IDENTIFIER        Lexeme: mimDma0BlkOffsetReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2037  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2037  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2037  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2037  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2037  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2037  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2037  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2037  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2038  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2038  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2038  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2038  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2038  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2038  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2038  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2038  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2038  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2038  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2038  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2038  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2038  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2038  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2038  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2038  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2038  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2038  Token: PTR_OP            Lexeme: ->
Line: 2038  Token: IDENTIFIER        Lexeme: mimDma0SpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2038  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2038  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2038  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2038  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2038  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2038  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2038  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2038  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2038  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2038  Token: PTR_OP            Lexeme: ->
Line: 2038  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2038  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2038  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2038  Token: (  Lexeme: (
Line: 2038  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2038  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2038  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2038  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2038  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2039  Token: IDENTIFIER        Lexeme: treg
Line: 2039  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2039  Token: (  Lexeme: (
Line: 2039  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2039  Token: PTR_OP            Lexeme: ->
Line: 2039  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2039  Token: .  Lexeme: .
Line: 2039  Token: IDENTIFIER        Lexeme: mem_rgn
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2039  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2039  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2039  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2039  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2039  Token: (  Lexeme: (
Line: 2039  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2039  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2039  Token: CONSTANT          Lexeme: 15
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2039  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2039  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
Line: 2039  Token: SIZEOF            Lexeme: sizeof
Line: 2039  Token: (  Lexeme: (
Line: 2039  Token: IDENTIFIER        Lexeme: drp_crp
 type_specifier -> TYPE_NAME
Line: 2039  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2039  Token: ;  Lexeme: ;
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2041  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2041  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2041  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2041  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2041  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2041  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2041  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2041  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2041  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2041  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2041  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2041  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2041  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: (  Lexeme: (
Line: 2041  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2041  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2041  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2041  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2041  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2041  Token: PTR_OP            Lexeme: ->
Line: 2041  Token: IDENTIFIER        Lexeme: mimDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2041  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2041  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2041  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2041  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2041  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2041  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2041  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2041  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2043  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2043  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2043  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2043  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2043  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2043  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2043  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2044  Token: IDENTIFIER        Lexeme: hqmMimDma0HdwSim
Line: 2044  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2044  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 2044  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2045  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2045  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2045  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2045  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2045  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2048  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 2048  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2048  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2048  Token: PTR_OP            Lexeme: ->
Line: 2048  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2048  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2049  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 2049  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2049  Token: IDENTIFIER        Lexeme: pCurDrpCrpDesc
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2049  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pCurDrpCrpDesc added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2056  Token: WHILE             Lexeme: while
Line: 2056  Token: (  Lexeme: (
Line: 2056  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2056  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2056  Token: {  Lexeme: {
Line: 2058  Token: IDENTIFIER        Lexeme: treg
Line: 2058  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2058  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2058  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2058  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2058  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2058  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2058  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2058  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2058  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2058  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2058  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2058  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2058  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2058  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: (  Lexeme: (
Line: 2058  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2058  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2058  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2058  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2058  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2058  Token: PTR_OP            Lexeme: ->
Line: 2058  Token: IDENTIFIER        Lexeme: mimDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2058  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2058  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2058  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2058  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2058  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2058  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2060  Token: WHILE             Lexeme: while
Line: 2060  Token: (  Lexeme: (
Line: 2060  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2060  Token: (  Lexeme: (
Line: 2060  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2060  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2060  Token: (  Lexeme: (
Line: 2060  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2060  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2060  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2060  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2060  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2060  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2060  Token: {  Lexeme: {
Line: 2061  Token: IDENTIFIER        Lexeme: treg
Line: 2061  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2061  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2061  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2061  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2061  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2061  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2061  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2061  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2061  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2061  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2061  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2061  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2061  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2061  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: (  Lexeme: (
Line: 2061  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2061  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2061  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2061  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2061  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2061  Token: PTR_OP            Lexeme: ->
Line: 2061  Token: IDENTIFIER        Lexeme: mimDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2061  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2061  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2061  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2061  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2061  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2061  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2062  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2064  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2064  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2064  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2064  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2064  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2064  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2064  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2064  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2064  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2064  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2064  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2064  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2064  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: (  Lexeme: (
Line: 2064  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2064  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2064  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2064  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2064  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2064  Token: PTR_OP            Lexeme: ->
Line: 2064  Token: IDENTIFIER        Lexeme: mimDma0AdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2064  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2064  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2064  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2064  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2064  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2064  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2064  Token: PTR_OP            Lexeme: ->
Line: 2064  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2064  Token: .  Lexeme: .
Line: 2064  Token: IDENTIFIER        Lexeme: blk_id
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2064  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2064  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2065  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2065  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2065  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2065  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2065  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2065  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2065  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2065  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2065  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2065  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2065  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2065  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2065  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: (  Lexeme: (
Line: 2065  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2065  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2065  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2065  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2065  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2065  Token: PTR_OP            Lexeme: ->
Line: 2065  Token: IDENTIFIER        Lexeme: mimDma0BlkOffsetReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2065  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2065  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2065  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2065  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2065  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2065  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2065  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2065  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2066  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2066  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2066  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2066  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2066  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2066  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2066  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2066  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2066  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2066  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2066  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2066  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2066  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2066  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2066  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2066  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2066  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2066  Token: PTR_OP            Lexeme: ->
Line: 2066  Token: IDENTIFIER        Lexeme: mimDma0SpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2066  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2066  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2066  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2066  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2066  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2066  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2066  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2066  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2066  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2066  Token: PTR_OP            Lexeme: ->
Line: 2066  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2066  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2066  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2066  Token: (  Lexeme: (
Line: 2066  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2066  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2066  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2066  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2066  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2067  Token: IDENTIFIER        Lexeme: treg
Line: 2067  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2067  Token: (  Lexeme: (
Line: 2067  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2067  Token: PTR_OP            Lexeme: ->
Line: 2067  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2067  Token: .  Lexeme: .
Line: 2067  Token: IDENTIFIER        Lexeme: mem_rgn
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2067  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2067  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2067  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2067  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2067  Token: (  Lexeme: (
Line: 2067  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2067  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2067  Token: CONSTANT          Lexeme: 15
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2067  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2067  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
Line: 2067  Token: SIZEOF            Lexeme: sizeof
Line: 2067  Token: (  Lexeme: (
Line: 2067  Token: IDENTIFIER        Lexeme: drp_crp
 type_specifier -> TYPE_NAME
Line: 2067  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2067  Token: ;  Lexeme: ;
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2068  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2068  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2068  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2068  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2068  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2068  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2068  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2068  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2068  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2068  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2068  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2068  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2068  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: (  Lexeme: (
Line: 2068  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2068  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2068  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2068  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2068  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2068  Token: PTR_OP            Lexeme: ->
Line: 2068  Token: IDENTIFIER        Lexeme: mimDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2068  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2068  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2068  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2068  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2068  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2068  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2068  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2068  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2070  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2070  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2070  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2070  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2070  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2070  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2070  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2071  Token: IDENTIFIER        Lexeme: hqmMimDma0HdwSim
Line: 2071  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2071  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 2071  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2072  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2072  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2072  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2072  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2072  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2074  Token: IDENTIFIER        Lexeme: pCurDrpCrpDesc
Line: 2074  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2074  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2074  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2075  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
Line: 2075  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2075  Token: IDENTIFIER        Lexeme: pDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2075  Token: PTR_OP            Lexeme: ->
Line: 2075  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2075  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2076  Token: IDENTIFIER        Lexeme: enque
Line: 2076  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2076  Token: IDENTIFIER        Lexeme: pCurDrpCrpDesc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2076  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2076  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2076  Token: IDENTIFIER        Lexeme: drpCrpFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2076  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2076  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2077  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2084  Token: IDENTIFIER        Lexeme: shdMb0
Line: 2084  Token: UNKNOWN     Lexeme: |=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> OR_ASSIGN
Line: 2084  Token: CONSTANT          Lexeme: 0x0010
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2084  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2085  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2085  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2085  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2085  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2085  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2087  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2087  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2087  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
Line: 2087  Token: IDENTIFIER        Lexeme: pMqsIocb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2087  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2087  Token: (  Lexeme: (
Line: 2087  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2087  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2087  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
Line: 2087  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2087  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2087  Token: PTR_OP            Lexeme: ->
Line: 2087  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2087  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pMqsIocb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2088  Token: IDENTIFIER        Lexeme: pMqsIocb
Line: 2088  Token: [  Lexeme: [
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2088  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2088  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2088  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2088  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2088  Token: PTR_OP            Lexeme: ->
Line: 2088  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2088  Token: PTR_OP            Lexeme: ->
Line: 2088  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2088  Token: .  Lexeme: .
Line: 2088  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2088  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2088  Token: (  Lexeme: (
Line: 2088  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2088  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2088  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2088  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2088  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2089  Token: IDENTIFIER        Lexeme: pMqsIocb
Line: 2089  Token: [  Lexeme: [
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2089  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2089  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2089  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2089  Token: (  Lexeme: (
Line: 2089  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2089  Token: [  Lexeme: [
Line: 2089  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2089  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2089  Token: .  Lexeme: .
Line: 2089  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2089  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2089  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2089  Token: (  Lexeme: (
Line: 2089  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2089  Token: [  Lexeme: [
Line: 2089  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2089  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2089  Token: .  Lexeme: .
Line: 2089  Token: IDENTIFIER        Lexeme: port
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2089  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2089  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2089  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2089  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
Line: 2089  Token: (  Lexeme: (
Line: 2089  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2089  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2089  Token: CONSTANT          Lexeme: 7
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2089  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2089  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2091  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2091  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2091  Token: IDENTIFIER        Lexeme: conxId
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 2091  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 2091  Token: IDENTIFIER        Lexeme: opcodeFmt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2091  Token: .  Lexeme: .
Line: 2091  Token: IDENTIFIER        Lexeme: conxIdPrefix
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2091  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2091  Token: CONSTANT          Lexeme: 24
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2091  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: conxId added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2093  Token: SWITCH            Lexeme: switch
Line: 2093  Token: (  Lexeme: (
Line: 2093  Token: IDENTIFIER        Lexeme: opcodeFmt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2093  Token: .  Lexeme: .
Line: 2093  Token: IDENTIFIER        Lexeme: conxIdPsn
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2093  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2093  Token: {  Lexeme: {
Line: 2095  Token: CASE              Lexeme: case
Line: 2095  Token: CONSTANT          Lexeme: 0x0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2095  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2099  Token: IDENTIFIER        Lexeme: treg
Line: 2099  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2099  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2099  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2099  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2099  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2099  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2099  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2099  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2099  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2099  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2099  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2099  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2099  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2099  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: (  Lexeme: (
Line: 2099  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2099  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2099  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2099  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2099  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2099  Token: PTR_OP            Lexeme: ->
Line: 2099  Token: IDENTIFIER        Lexeme: conxIdIncCountReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2099  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2099  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2099  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2099  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2099  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2099  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2100  Token: WHILE             Lexeme: while
Line: 2100  Token: (  Lexeme: (
Line: 2100  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2100  Token: (  Lexeme: (
Line: 2100  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2100  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2100  Token: (  Lexeme: (
Line: 2100  Token: CONSTANT          Lexeme: 0x1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2100  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2100  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2100  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2100  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2100  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2100  Token: {  Lexeme: {
Line: 2101  Token: IDENTIFIER        Lexeme: treg
Line: 2101  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2101  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2101  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2101  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2101  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2101  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2101  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2101  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2101  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2101  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2101  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2101  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2101  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2101  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: (  Lexeme: (
Line: 2101  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2101  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2101  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2101  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2101  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2101  Token: PTR_OP            Lexeme: ->
Line: 2101  Token: IDENTIFIER        Lexeme: conxIdIncCountReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2101  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2101  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2101  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2101  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2101  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2101  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2102  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2104  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2104  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2104  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2104  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2104  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2104  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2104  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2104  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2104  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2104  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2104  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2104  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2104  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: (  Lexeme: (
Line: 2104  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2104  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2104  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2104  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2104  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2104  Token: PTR_OP            Lexeme: ->
Line: 2104  Token: IDENTIFIER        Lexeme: conxIdIncCountReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2104  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2104  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2104  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2104  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2104  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2104  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2104  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2104  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2106  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2106  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2106  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2106  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2106  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2106  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2106  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2107  Token: IDENTIFIER        Lexeme: mqsCnxIdIncHdwSim
Line: 2107  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2107  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 2107  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2108  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2108  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2108  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2108  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 2108  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2108  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2110  Token: IDENTIFIER        Lexeme: treg
Line: 2110  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2110  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2110  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2110  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2110  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2110  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2110  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2110  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2110  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2110  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2110  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2110  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2110  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: (  Lexeme: (
Line: 2110  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2110  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2110  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2110  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2110  Token: PTR_OP            Lexeme: ->
Line: 2110  Token: IDENTIFIER        Lexeme: conxIdIncCountReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2110  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2110  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2111  Token: WHILE             Lexeme: while
Line: 2111  Token: (  Lexeme: (
Line: 2111  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2111  Token: (  Lexeme: (
Line: 2111  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2111  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2111  Token: (  Lexeme: (
Line: 2111  Token: CONSTANT          Lexeme: 0x1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2111  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2111  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2111  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2111  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2111  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2111  Token: {  Lexeme: {
Line: 2112  Token: IDENTIFIER        Lexeme: treg
Line: 2112  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2112  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2112  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2112  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2112  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2112  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2112  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2112  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2112  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2112  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2112  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2112  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2112  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2112  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: (  Lexeme: (
Line: 2112  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2112  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2112  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2112  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2112  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2112  Token: PTR_OP            Lexeme: ->
Line: 2112  Token: IDENTIFIER        Lexeme: conxIdIncCountReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2112  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2112  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2112  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2112  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2112  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2112  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2113  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2114  Token: IDENTIFIER        Lexeme: conxId
Line: 2114  Token: ADD_ASSIGN        Lexeme: +=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 2114  Token: (  Lexeme: (
Line: 2114  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2114  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2114  Token: CONSTANT          Lexeme: 0x00FFFFFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2114  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2114  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2116  Token: BREAK             Lexeme: break
Line: 2116  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2118  Token: CASE              Lexeme: case
Line: 2118  Token: CONSTANT          Lexeme: 0x01
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2118  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2119  Token: IDENTIFIER        Lexeme: conxId
Line: 2119  Token: ADD_ASSIGN        Lexeme: +=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 2119  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2119  Token: [  Lexeme: [
Line: 2119  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2119  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2119  Token: .  Lexeme: .
Line: 2119  Token: IDENTIFIER        Lexeme: vpid
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2119  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2120  Token: BREAK             Lexeme: break
Line: 2120  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2122  Token: CASE              Lexeme: case
Line: 2122  Token: CONSTANT          Lexeme: 0x02
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2122  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2123  Token: IDENTIFIER        Lexeme: conxId
Line: 2123  Token: ADD_ASSIGN        Lexeme: +=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 2123  Token: IDENTIFIER        Lexeme: pMqsIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2123  Token: [  Lexeme: [
Line: 2123  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2123  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2123  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2123  Token: CONSTANT          Lexeme: 0x0000FFFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2123  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2124  Token: BREAK             Lexeme: break
Line: 2124  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2126  Token: CASE              Lexeme: case
Line: 2126  Token: CONSTANT          Lexeme: 0x03
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2126  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2127  Token: IDENTIFIER        Lexeme: conxId
Line: 2127  Token: ADD_ASSIGN        Lexeme: +=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 2127  Token: IDENTIFIER        Lexeme: pMqsIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2127  Token: [  Lexeme: [
Line: 2127  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2127  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2127  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2127  Token: CONSTANT          Lexeme: 0x00FFFFFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2127  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2128  Token: BREAK             Lexeme: break
Line: 2128  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2129  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> SWITCH '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2131  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2131  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2131  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2131  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2131  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2131  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2131  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2131  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2131  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2131  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2131  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2131  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2131  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: (  Lexeme: (
Line: 2131  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2131  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2131  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2131  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2131  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2131  Token: PTR_OP            Lexeme: ->
Line: 2131  Token: IDENTIFIER        Lexeme: mqsTieCnxReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2131  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2131  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2131  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2131  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2131  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2131  Token: IDENTIFIER        Lexeme: conxId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2131  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2131  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2136  Token: SWITCH            Lexeme: switch
Line: 2136  Token: (  Lexeme: (
Line: 2136  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2136  Token: [  Lexeme: [
Line: 2136  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2136  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2136  Token: .  Lexeme: .
Line: 2136  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2136  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2136  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2136  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2136  Token: {  Lexeme: {
Line: 2138  Token: CASE              Lexeme: case
Line: 2138  Token: (  Lexeme: (
Line: 2138  Token: CONSTANT          Lexeme: 0x01
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2138  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2138  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2138  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2138  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2138  Token: {  Lexeme: {
Line: 2142  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2142  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2142  Token: IDENTIFIER        Lexeme: temp
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 2142  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 2142  Token: (  Lexeme: (
Line: 2142  Token: IDENTIFIER        Lexeme: pMqsIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2142  Token: [  Lexeme: [
Line: 2142  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2142  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2142  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2142  Token: CONSTANT          Lexeme: 0x0000FFFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2142  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2142  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2142  Token: (  Lexeme: (
Line: 2142  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2142  Token: [  Lexeme: [
Line: 2142  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2142  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2142  Token: .  Lexeme: .
Line: 2142  Token: IDENTIFIER        Lexeme: hqpCntxtW1
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2142  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2142  Token: CONSTANT          Lexeme: 0x0FFF0000
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2142  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2142  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: temp added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2146  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2146  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2146  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2146  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2146  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2146  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2146  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2146  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2146  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2146  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2146  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2146  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2146  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: (  Lexeme: (
Line: 2146  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2146  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2146  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2146  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2146  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2146  Token: PTR_OP            Lexeme: ->
Line: 2146  Token: IDENTIFIER        Lexeme: mqsTiePrf0Reg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2146  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2146  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2146  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2146  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2146  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2146  Token: IDENTIFIER        Lexeme: temp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2146  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2146  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2150  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2150  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2150  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2150  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2150  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2150  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2150  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2150  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2150  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2150  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2150  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2150  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: (  Lexeme: (
Line: 2150  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2150  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2150  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2150  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2150  Token: PTR_OP            Lexeme: ->
Line: 2150  Token: IDENTIFIER        Lexeme: mqsTiePrf0Reg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2150  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2150  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2150  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2151  Token: BREAK             Lexeme: break
Line: 2151  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2152  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2153  Token: CASE              Lexeme: case
Line: 2153  Token: (  Lexeme: (
Line: 2153  Token: CONSTANT          Lexeme: 0x02
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2153  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2153  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2153  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2153  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2155  Token: BREAK             Lexeme: break
Line: 2155  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2157  Token: CASE              Lexeme: case
Line: 2157  Token: (  Lexeme: (
Line: 2157  Token: CONSTANT          Lexeme: 0x03
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2157  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2157  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2157  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2157  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2159  Token: BREAK             Lexeme: break
Line: 2159  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2161  Token: CASE              Lexeme: case
Line: 2161  Token: (  Lexeme: (
Line: 2161  Token: CONSTANT          Lexeme: 0x04
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2161  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2161  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2161  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2161  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2163  Token: BREAK             Lexeme: break
Line: 2163  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2165  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> SWITCH '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2169  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2169  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2169  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2169  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2169  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2169  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2169  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2169  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2169  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2169  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2169  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2169  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2169  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: (  Lexeme: (
Line: 2169  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2169  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2169  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2169  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2169  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2169  Token: PTR_OP            Lexeme: ->
Line: 2169  Token: IDENTIFIER        Lexeme: mqsTieL1qReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2169  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2169  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2169  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2169  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2169  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2169  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2169  Token: [  Lexeme: [
Line: 2169  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2169  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2169  Token: .  Lexeme: .
Line: 2169  Token: IDENTIFIER        Lexeme: mqsL1q
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2169  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2169  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2172  Token: IDENTIFIER        Lexeme: shdMb0
Line: 2172  Token: AND_ASSIGN        Lexeme: &=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> AND_ASSIGN
Line: 2172  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 2172  Token: CONSTANT          Lexeme: 0x0010
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2172  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2173  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2173  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2173  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2173  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2173  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2178  Token: IDENTIFIER        Lexeme: treg
Line: 2178  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2178  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2178  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2178  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2178  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2178  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2178  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2178  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2178  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2178  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2178  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2178  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2178  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2178  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: (  Lexeme: (
Line: 2178  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2178  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2178  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2178  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2178  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2178  Token: PTR_OP            Lexeme: ->
Line: 2178  Token: IDENTIFIER        Lexeme: mqsDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2178  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2178  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2178  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2178  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2178  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2178  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2180  Token: WHILE             Lexeme: while
Line: 2180  Token: (  Lexeme: (
Line: 2180  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2180  Token: (  Lexeme: (
Line: 2180  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2180  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2180  Token: (  Lexeme: (
Line: 2180  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2180  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2180  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2180  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2180  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2180  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2180  Token: {  Lexeme: {
Line: 2181  Token: IDENTIFIER        Lexeme: treg
Line: 2181  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2181  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2181  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2181  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2181  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2181  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2181  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2181  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2181  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2181  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2181  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2181  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2181  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2181  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: (  Lexeme: (
Line: 2181  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2181  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2181  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2181  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2181  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2181  Token: PTR_OP            Lexeme: ->
Line: 2181  Token: IDENTIFIER        Lexeme: mqsDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2181  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2181  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2181  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2181  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2181  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2181  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2182  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2184  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2184  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2184  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2184  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2184  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2184  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2184  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2184  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2184  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2184  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2184  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2184  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2184  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2184  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2184  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2184  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2184  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2184  Token: PTR_OP            Lexeme: ->
Line: 2184  Token: IDENTIFIER        Lexeme: mqsDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2184  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2184  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2184  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2184  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2184  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2184  Token: (  Lexeme: (
Line: 2184  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2184  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2184  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2184  Token: IDENTIFIER        Lexeme: pMqsIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2184  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2184  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2187  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2187  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2187  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2187  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2187  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2187  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2187  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2188  Token: IDENTIFIER        Lexeme: hqmMqsDma0HdwSim
Line: 2188  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2188  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 2188  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2189  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2189  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2189  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2189  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2189  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2191  Token: IDENTIFIER        Lexeme: treg
Line: 2191  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2191  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2191  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2191  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2191  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2191  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2191  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2191  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2191  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2191  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2191  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2191  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2191  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2191  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: (  Lexeme: (
Line: 2191  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2191  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2191  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2191  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2191  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2191  Token: PTR_OP            Lexeme: ->
Line: 2191  Token: IDENTIFIER        Lexeme: mqsDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2191  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2191  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2191  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2191  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2191  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2191  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2193  Token: WHILE             Lexeme: while
Line: 2193  Token: (  Lexeme: (
Line: 2193  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2193  Token: (  Lexeme: (
Line: 2193  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2193  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2193  Token: (  Lexeme: (
Line: 2193  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2193  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2193  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2193  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2193  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2193  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2193  Token: {  Lexeme: {
Line: 2194  Token: IDENTIFIER        Lexeme: treg
Line: 2194  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2194  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2194  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2194  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2194  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2194  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2194  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2194  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2194  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2194  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2194  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2194  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2194  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2194  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: (  Lexeme: (
Line: 2194  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2194  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2194  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2194  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2194  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2194  Token: PTR_OP            Lexeme: ->
Line: 2194  Token: IDENTIFIER        Lexeme: mqsDma0CmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2194  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2194  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2194  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2194  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2194  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2194  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2195  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2201  Token: IDENTIFIER        Lexeme: treg
Line: 2201  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2201  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2201  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2201  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2201  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2201  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2201  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2201  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2201  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2201  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2201  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2201  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2201  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2201  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: (  Lexeme: (
Line: 2201  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2201  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2201  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2201  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2201  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2201  Token: PTR_OP            Lexeme: ->
Line: 2201  Token: IDENTIFIER        Lexeme: hqpCmdCmpltReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2201  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2201  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2201  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2201  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2201  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2201  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2203  Token: WHILE             Lexeme: while
Line: 2203  Token: (  Lexeme: (
Line: 2203  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2203  Token: (  Lexeme: (
Line: 2203  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2203  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2203  Token: (  Lexeme: (
Line: 2203  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2203  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2203  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2203  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2203  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2203  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2203  Token: {  Lexeme: {
Line: 2204  Token: IDENTIFIER        Lexeme: treg
Line: 2204  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2204  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2204  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2204  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2204  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2204  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2204  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2204  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2204  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2204  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2204  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2204  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2204  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2204  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: (  Lexeme: (
Line: 2204  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2204  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2204  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2204  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2204  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2204  Token: PTR_OP            Lexeme: ->
Line: 2204  Token: IDENTIFIER        Lexeme: hqpCmdCmpltReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2204  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2204  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2204  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2204  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2204  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2204  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2205  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2206  Token: IDENTIFIER        Lexeme: treg
Line: 2206  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2206  Token: (  Lexeme: (
Line: 2206  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2206  Token: PTR_OP            Lexeme: ->
Line: 2206  Token: IDENTIFIER        Lexeme: numIocbProcessed
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2206  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2206  Token: CONSTANT          Lexeme: 16
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2206  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2206  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2206  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2206  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2207  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2207  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2207  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2207  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2207  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2207  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2207  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2207  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2207  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2207  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2207  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2207  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: (  Lexeme: (
Line: 2207  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2207  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2207  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2207  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2207  Token: PTR_OP            Lexeme: ->
Line: 2207  Token: IDENTIFIER        Lexeme: hqpCmdCmpltReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2207  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2207  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2207  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2209  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2209  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2209  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2209  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2209  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2209  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2209  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2210  Token: IDENTIFIER        Lexeme: hqmCmdCmpltHdwSim
Line: 2210  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2210  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 2210  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2211  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2211  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2211  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2211  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2211  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2219  Token: IDENTIFIER        Lexeme: ReleaseHqpResources
Line: 2219  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2219  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2219  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2219  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2222  Token: IDENTIFIER        Lexeme: simIocbComplete
Line: 2222  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2222  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2222  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2227  Token: IDENTIFIER        Lexeme: shdMb0
Line: 2227  Token: AND_ASSIGN        Lexeme: &=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> AND_ASSIGN
Line: 2227  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 2227  Token: CONSTANT          Lexeme: 0x0004
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2227  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2228  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2228  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2228  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2228  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2228  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2229  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 function_definition -> declaration_specifiers declarator compound_statement
 external_declaration -> function_definition
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 2231  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 2231  Token: IDENTIFIER        Lexeme: processIocb
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 2231  Token: (  Lexeme: (
Line: 2231  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 2231  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 2231  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 2231  Token: {  Lexeme: {
 declarator -> direct_declarator
Line: 2233  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 2233  Token: IDENTIFIER        Lexeme: protocol
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 2233  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 2233  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2233  Token: [  Lexeme: [
Line: 2233  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2233  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2233  Token: .  Lexeme: .
Line: 2233  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2233  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2233  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2233  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: protocol added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 2234  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 2234  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2234  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2234  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2234  Token: IDENTIFIER        Lexeme: HqpLookup
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2234  Token: [  Lexeme: [
Line: 2234  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2234  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2234  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2235  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 2235  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2235  Token: IDENTIFIER        Lexeme: pDrpCrp
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2235  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pDrpCrp added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2236  Token: IDENTIFIER        Lexeme: opcodeFormatRamEntry
 type_specifier -> TYPE_NAME
Line: 2236  Token: IDENTIFIER        Lexeme: opcodeFmt
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 2236  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: opcodeFmt added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2244  Token: SWITCH            Lexeme: switch
Line: 2244  Token: (  Lexeme: (
Line: 2244  Token: IDENTIFIER        Lexeme: protocol
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2244  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2244  Token: {  Lexeme: {
Line: 2249  Token: CASE              Lexeme: case
Line: 2249  Token: (  Lexeme: (
Line: 2249  Token: CONSTANT          Lexeme: 0x01
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2249  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2249  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2249  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2249  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2249  Token: {  Lexeme: {
Line: 2251  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2251  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2251  Token: IDENTIFIER        Lexeme: iocbIndx
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 2251  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 2251  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2251  Token: PTR_OP            Lexeme: ->
Line: 2251  Token: IDENTIFIER        Lexeme: iocbIndx
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2251  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: iocbIndx added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 2256  Token: IDENTIFIER        Lexeme: fc_iocb_struct
 type_specifier -> TYPE_NAME
Line: 2256  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2256  Token: IDENTIFIER        Lexeme: pIocb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2256  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2256  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2256  Token: PTR_OP            Lexeme: ->
Line: 2256  Token: IDENTIFIER        Lexeme: pCurIocb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2256  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pIocb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2261  Token: IDENTIFIER        Lexeme: opcodeFmt
Line: 2261  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2261  Token: IDENTIFIER        Lexeme: ReadOpcodeFormatRam
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2261  Token: (  Lexeme: (
Line: 2261  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2261  Token: PTR_OP            Lexeme: ->
Line: 2261  Token: IDENTIFIER        Lexeme: hdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2261  Token: .  Lexeme: .
Line: 2261  Token: IDENTIFIER        Lexeme: iocb_type
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2261  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2261  Token: IDENTIFIER        Lexeme: protocol
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2261  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2261  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2269  Token: SWITCH            Lexeme: switch
Line: 2269  Token: (  Lexeme: (
Line: 2269  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2269  Token: PTR_OP            Lexeme: ->
Line: 2269  Token: IDENTIFIER        Lexeme: hdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2269  Token: .  Lexeme: .
Line: 2269  Token: IDENTIFIER        Lexeme: iocb_type
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2269  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2269  Token: {  Lexeme: {
Line: 2271  Token: CASE              Lexeme: case
Line: 2271  Token: CONSTANT          Lexeme: 0x48
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2271  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2271  Token: {  Lexeme: {
Line: 2273  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 2273  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2273  Token: IDENTIFIER        Lexeme: pDmaCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2273  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2273  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2273  Token: PTR_OP            Lexeme: ->
Line: 2273  Token: IDENTIFIER        Lexeme: pDmaCb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2273  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDmaCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 2274  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2274  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2274  Token: IDENTIFIER        Lexeme: treg
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 2274  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: treg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2282  Token: SWITCH            Lexeme: switch
Line: 2282  Token: (  Lexeme: (
Line: 2282  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2282  Token: PTR_OP            Lexeme: ->
Line: 2282  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2282  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2282  Token: {  Lexeme: {
Line: 2284  Token: CASE              Lexeme: case
Line: 2284  Token: IDENTIFIER        Lexeme: HQP_STATE_PROC_IOCB
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2284  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2289  Token: IF                Lexeme: if
Line: 2289  Token: (  Lexeme: (
Line: 2289  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2289  Token: PTR_OP            Lexeme: ->
Line: 2289  Token: IDENTIFIER        Lexeme: cmnd6
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2289  Token: .  Lexeme: .
Line: 2289  Token: IDENTIFIER        Lexeme: cmnd_cntl
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2289  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2289  Token: CONSTANT          Lexeme: 0x0004
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2289  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2289  Token: {  Lexeme: {
Line: 2290  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2290  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2290  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2290  Token: UNKNOWN     Lexeme: |=
 unary_expression -> postfix_expression
 assignment_operator -> OR_ASSIGN
Line: 2290  Token: CONSTANT          Lexeme: 0x0001
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2290  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2291  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2296  Token: IDENTIFIER        Lexeme: pDmaCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2296  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2296  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2296  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2296  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2296  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2296  Token: PTR_OP            Lexeme: ->
Line: 2296  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2296  Token: PTR_OP            Lexeme: ->
Line: 2296  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2296  Token: .  Lexeme: .
Line: 2296  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2296  Token: .  Lexeme: .
Line: 2296  Token: IDENTIFIER        Lexeme: dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2296  Token: [  Lexeme: [
Line: 2296  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2296  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2296  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2300  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2300  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2300  Token: IDENTIFIER        Lexeme: pBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2300  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2300  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2300  Token: PTR_OP            Lexeme: ->
Line: 2300  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2300  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2301  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2301  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2301  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2301  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2301  Token: IDENTIFIER        Lexeme: DMA_TYPE_DSD
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2301  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2302  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2302  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2302  Token: IDENTIFIER        Lexeme: hqpId
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2302  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2302  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2302  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2303  Token: IF                Lexeme: if
Line: 2303  Token: (  Lexeme: (
Line: 2303  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2303  Token: PTR_OP            Lexeme: ->
Line: 2303  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2303  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2303  Token: CONSTANT          Lexeme: 0x0001
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2303  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2303  Token: {  Lexeme: {
Line: 2304  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2304  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2304  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2304  Token: UNKNOWN     Lexeme: |=
 unary_expression -> postfix_expression
 assignment_operator -> OR_ASSIGN
Line: 2304  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2304  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2305  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2305  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2305  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2305  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2305  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2305  Token: PTR_OP            Lexeme: ->
Line: 2305  Token: IDENTIFIER        Lexeme: cmnd6
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2305  Token: .  Lexeme: .
Line: 2305  Token: IDENTIFIER        Lexeme: cmnd_dataseg0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2305  Token: .  Lexeme: .
Line: 2305  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2305  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2306  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2306  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2306  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2306  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2306  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2306  Token: PTR_OP            Lexeme: ->
Line: 2306  Token: IDENTIFIER        Lexeme: cmnd6
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2306  Token: .  Lexeme: .
Line: 2306  Token: IDENTIFIER        Lexeme: cmnd_dataseg0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2306  Token: .  Lexeme: .
Line: 2306  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2306  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2307  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2307  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2307  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2307  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2307  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2307  Token: PTR_OP            Lexeme: ->
Line: 2307  Token: IDENTIFIER        Lexeme: cmnd6
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2307  Token: .  Lexeme: .
Line: 2307  Token: IDENTIFIER        Lexeme: cmnd_dataseg0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2307  Token: .  Lexeme: .
Line: 2307  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2307  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2308  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2308  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2308  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2308  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2308  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2308  Token: PTR_OP            Lexeme: ->
Line: 2308  Token: IDENTIFIER        Lexeme: cmnd6
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2308  Token: .  Lexeme: .
Line: 2308  Token: IDENTIFIER        Lexeme: cmnd_dataseg0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2308  Token: .  Lexeme: .
Line: 2308  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2308  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2308  Token: (  Lexeme: (
Line: 2308  Token: SIZEOF            Lexeme: sizeof
Line: 2308  Token: (  Lexeme: (
Line: 2308  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2308  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2308  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2308  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2308  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2308  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2309  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2309  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2309  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2309  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2309  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2309  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2311  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2311  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2311  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2311  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2311  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2311  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2316  Token: IF                Lexeme: if
Line: 2316  Token: (  Lexeme: (
Line: 2316  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2316  Token: PTR_OP            Lexeme: ->
Line: 2316  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2316  Token: >  Lexeme: >
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 2316  Token: (  Lexeme: (
Line: 2316  Token: (  Lexeme: (
Line: 2316  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2316  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2316  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2316  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2316  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2316  Token: SIZEOF            Lexeme: sizeof
Line: 2316  Token: (  Lexeme: (
Line: 2316  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2316  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2316  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 2316  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2316  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2316  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '>' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2316  Token: {  Lexeme: {
Line: 2317  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2317  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2317  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2317  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2317  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2317  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2317  Token: SIZEOF            Lexeme: sizeof
Line: 2317  Token: (  Lexeme: (
Line: 2317  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2317  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2317  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 2317  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2317  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2318  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2322  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2322  Token: (  Lexeme: (
Line: 2322  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2322  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2322  Token: (  Lexeme: (
Line: 2322  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2322  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2322  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2322  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2322  Token: {  Lexeme: {
Line: 2323  Token: IDENTIFIER        Lexeme: enque
Line: 2323  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2323  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2323  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2323  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2323  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2323  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2323  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2324  Token: RETURN            Lexeme: return
Line: 2324  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2324  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2325  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2327  Token: IDENTIFIER        Lexeme: treg
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2327  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2327  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2327  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2327  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2327  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2327  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2327  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2327  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2327  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2327  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2327  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2327  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2327  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2327  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: (  Lexeme: (
Line: 2327  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2327  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2327  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2327  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2327  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2327  Token: PTR_OP            Lexeme: ->
Line: 2327  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2327  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2327  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2327  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2327  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2327  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2327  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2329  Token: WHILE             Lexeme: while
Line: 2329  Token: (  Lexeme: (
Line: 2329  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2329  Token: (  Lexeme: (
Line: 2329  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2329  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2329  Token: (  Lexeme: (
Line: 2329  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2329  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2329  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2329  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2329  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2329  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2329  Token: {  Lexeme: {
Line: 2330  Token: IDENTIFIER        Lexeme: treg
Line: 2330  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2330  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2330  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2330  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2330  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2330  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2330  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2330  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2330  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2330  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2330  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2330  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2330  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2330  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: (  Lexeme: (
Line: 2330  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2330  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2330  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2330  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2330  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2330  Token: PTR_OP            Lexeme: ->
Line: 2330  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2330  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2330  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2330  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2330  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2330  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2330  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2331  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2333  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2333  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2333  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2333  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2333  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2333  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2333  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2333  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2333  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2333  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2333  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2333  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2333  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2333  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2333  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2333  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2333  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2333  Token: PTR_OP            Lexeme: ->
Line: 2333  Token: IDENTIFIER        Lexeme: hostDmaSpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2333  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2333  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2333  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2333  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2333  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2333  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2333  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2333  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2333  Token: PTR_OP            Lexeme: ->
Line: 2333  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2333  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2333  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2333  Token: (  Lexeme: (
Line: 2333  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2333  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2333  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2333  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2333  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2334  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2334  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2334  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2334  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2334  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2334  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2334  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2334  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2334  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2334  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2334  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2334  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2334  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: (  Lexeme: (
Line: 2334  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2334  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2334  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2334  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2334  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2334  Token: PTR_OP            Lexeme: ->
Line: 2334  Token: IDENTIFIER        Lexeme: hostDmaAdrlReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2334  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2334  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2334  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2334  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2334  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2334  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2334  Token: PTR_OP            Lexeme: ->
Line: 2334  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2334  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2334  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2335  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2335  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2335  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2335  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2335  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2335  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2335  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2335  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2335  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2335  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2335  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2335  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2335  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: (  Lexeme: (
Line: 2335  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2335  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2335  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2335  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2335  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2335  Token: PTR_OP            Lexeme: ->
Line: 2335  Token: IDENTIFIER        Lexeme: hostDmaAdrhReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2335  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2335  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2335  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2335  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2335  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2335  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2335  Token: PTR_OP            Lexeme: ->
Line: 2335  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2335  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2335  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2336  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2336  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2336  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2336  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2336  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2336  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2336  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2336  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2336  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2336  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2336  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2336  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: (  Lexeme: (
Line: 2336  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2336  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2336  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2336  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2336  Token: PTR_OP            Lexeme: ->
Line: 2336  Token: IDENTIFIER        Lexeme: hostDmaHqpIdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2336  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2336  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2336  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2336  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2337  Token: IDENTIFIER        Lexeme: treg
Line: 2337  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2337  Token: (  Lexeme: (
Line: 2337  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2337  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2337  Token: CONSTANT          Lexeme: 14
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2337  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2337  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2337  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2337  Token: PTR_OP            Lexeme: ->
Line: 2337  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2337  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2339  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2339  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2339  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2339  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2339  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2339  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2339  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2339  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2339  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2339  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2339  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2339  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2339  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: (  Lexeme: (
Line: 2339  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2339  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2339  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2339  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2339  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2339  Token: PTR_OP            Lexeme: ->
Line: 2339  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2339  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2339  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2339  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2339  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2339  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2339  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2339  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2339  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2340  Token: IDENTIFIER        Lexeme: enque
Line: 2340  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2340  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2340  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2340  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2340  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2340  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2340  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2343  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2343  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2343  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2343  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2343  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2343  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2343  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2344  Token: IDENTIFIER        Lexeme: hostDmaHdwSim
Line: 2344  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2344  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 2344  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2345  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2345  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2345  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2345  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2345  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2349  Token: RETURN            Lexeme: return
Line: 2349  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2349  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2350  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2350  Token: ELSE              Lexeme: else
Line: 2350  Token: {  Lexeme: {
Line: 2355  Token: }  Lexeme: }
 compound_statement -> '{' '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2356  Token: BREAK             Lexeme: break
Line: 2356  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2361  Token: CASE              Lexeme: case
Line: 2361  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2361  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2363  Token: IF                Lexeme: if
Line: 2363  Token: (  Lexeme: (
Line: 2363  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2363  Token: IDENTIFIER        Lexeme: ProcessDsdList
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2363  Token: (  Lexeme: (
Line: 2363  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2363  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2363  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2363  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2363  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2363  Token: {  Lexeme: {
Line: 2364  Token: RETURN            Lexeme: return
Line: 2364  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2364  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2365  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2366  Token: BREAK             Lexeme: break
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2366  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2371  Token: CASE              Lexeme: case
Line: 2371  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_LPTR_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2371  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2371  Token: {  Lexeme: {
Line: 2373  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2373  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2373  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2373  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2373  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2373  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2374  Token: IF                Lexeme: if
Line: 2374  Token: (  Lexeme: (
Line: 2374  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2374  Token: IDENTIFIER        Lexeme: ProcessDsdList
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2374  Token: (  Lexeme: (
Line: 2374  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2374  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2374  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2374  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2374  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2374  Token: {  Lexeme: {
Line: 2375  Token: RETURN            Lexeme: return
Line: 2375  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2375  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2376  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2377  Token: BREAK             Lexeme: break
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2377  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2378  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2379  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> SWITCH '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2380  Token: BREAK             Lexeme: break
Line: 2380  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2381  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2387  Token: CASE              Lexeme: case
Line: 2387  Token: CONSTANT          Lexeme: 0x18
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2387  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2387  Token: {  Lexeme: {
Line: 2394  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2394  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2394  Token: IDENTIFIER        Lexeme: pDseg
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2394  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2394  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2394  Token: (  Lexeme: (
Line: 2394  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2394  Token: PTR_OP            Lexeme: ->
Line: 2394  Token: IDENTIFIER        Lexeme: cmnd7
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2394  Token: .  Lexeme: .
Line: 2394  Token: IDENTIFIER        Lexeme: cmnd_dataseg0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2394  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2394  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDseg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 2395  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2395  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2395  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2395  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2395  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2395  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2395  Token: PTR_OP            Lexeme: ->
Line: 2395  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2395  Token: PTR_OP            Lexeme: ->
Line: 2395  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2395  Token: .  Lexeme: .
Line: 2395  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2395  Token: .  Lexeme: .
Line: 2395  Token: IDENTIFIER        Lexeme: dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2395  Token: [  Lexeme: [
Line: 2395  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2395  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2395  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDsegInDrpCrp added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2401  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2401  Token: [  Lexeme: [
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2401  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2401  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2401  Token: .  Lexeme: .
Line: 2401  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2401  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2401  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2401  Token: PTR_OP            Lexeme: ->
Line: 2401  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2401  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2402  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2402  Token: [  Lexeme: [
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2402  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2402  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2402  Token: .  Lexeme: .
Line: 2402  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2402  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2402  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2402  Token: PTR_OP            Lexeme: ->
Line: 2402  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2402  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2403  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2403  Token: [  Lexeme: [
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2403  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2403  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2403  Token: .  Lexeme: .
Line: 2403  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2403  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2403  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2403  Token: PTR_OP            Lexeme: ->
Line: 2403  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2403  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2404  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2404  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2404  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2404  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2404  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2404  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2405  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2405  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2405  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2405  Token: UNKNOWN     Lexeme: |=
 unary_expression -> postfix_expression
 assignment_operator -> OR_ASSIGN
Line: 2405  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2405  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2406  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2406  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2406  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2406  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2406  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2406  Token: PTR_OP            Lexeme: ->
Line: 2406  Token: IDENTIFIER        Lexeme: cmnd7
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2406  Token: .  Lexeme: .
Line: 2406  Token: IDENTIFIER        Lexeme: cmnd_seg_cnt
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2406  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2406  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2406  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2407  Token: BREAK             Lexeme: break
Line: 2407  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2408  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2410  Token: CASE              Lexeme: case
Line: 2410  Token: CONSTANT          Lexeme: 0x0A
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2410  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2410  Token: {  Lexeme: {
Line: 2417  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2417  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2417  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2417  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pDsegInDrpCrp added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 2418  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2418  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2418  Token: IDENTIFIER        Lexeme: pDseg
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2418  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2418  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2418  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2418  Token: PTR_OP            Lexeme: ->
Line: 2418  Token: IDENTIFIER        Lexeme: cont1
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2418  Token: .  Lexeme: .
Line: 2418  Token: IDENTIFIER        Lexeme: cont_dataseg
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2418  Token: [  Lexeme: [
Line: 2418  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2418  Token: PTR_OP            Lexeme: ->
Line: 2418  Token: IDENTIFIER        Lexeme: dsdIndxInBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2418  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2418  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDseg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2420  Token: WHILE             Lexeme: while
Line: 2420  Token: (  Lexeme: (
Line: 2420  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2420  Token: PTR_OP            Lexeme: ->
Line: 2420  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2420  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2420  Token: {  Lexeme: {
Line: 2422  Token: IF                Lexeme: if
Line: 2422  Token: (  Lexeme: (
Line: 2422  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2422  Token: PTR_OP            Lexeme: ->
Line: 2422  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2422  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2422  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2422  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2422  Token: {  Lexeme: {
Line: 2423  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2423  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2423  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2423  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2423  Token: PTR_OP            Lexeme: ->
Line: 2423  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2423  Token: PTR_OP            Lexeme: ->
Line: 2423  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2423  Token: .  Lexeme: .
Line: 2423  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2423  Token: .  Lexeme: .
Line: 2423  Token: IDENTIFIER        Lexeme: dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2423  Token: [  Lexeme: [
Line: 2423  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2423  Token: PTR_OP            Lexeme: ->
Line: 2423  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2423  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2423  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2425  Token: WHILE             Lexeme: while
Line: 2425  Token: (  Lexeme: (
Line: 2425  Token: (  Lexeme: (
Line: 2425  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2425  Token: PTR_OP            Lexeme: ->
Line: 2425  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2425  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 2425  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2425  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2425  Token: AND_OP            Lexeme: &&
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
Line: 2426  Token: (  Lexeme: (
Line: 2426  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2426  Token: PTR_OP            Lexeme: ->
Line: 2426  Token: IDENTIFIER        Lexeme: dsdIndxInBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2426  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 2426  Token: CONSTANT          Lexeme: 5
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2426  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2426  Token: AND_OP            Lexeme: &&
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression
Line: 2427  Token: (  Lexeme: (
Line: 2427  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2427  Token: PTR_OP            Lexeme: ->
Line: 2427  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2427  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2427  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2427  Token: {  Lexeme: {
Line: 2429  Token: IF                Lexeme: if
Line: 2429  Token: (  Lexeme: (
Line: 2429  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2429  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2429  Token: PTR_OP            Lexeme: ->
Line: 2429  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2429  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2429  Token: {  Lexeme: {
Line: 2433  Token: }  Lexeme: }
 compound_statement -> '{' '}'
 statement -> compound_statement
Line: 2434  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2434  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2434  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2434  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2434  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2434  Token: PTR_OP            Lexeme: ->
Line: 2434  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2434  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2435  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2435  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2435  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2435  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2435  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2435  Token: PTR_OP            Lexeme: ->
Line: 2435  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2435  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2436  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2436  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2436  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2436  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2436  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2436  Token: PTR_OP            Lexeme: ->
Line: 2436  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2436  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2437  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2437  Token: INC_OP            Lexeme: ++
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 postfix_expression -> postfix_expression INC_OP
Line: 2437  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2438  Token: IDENTIFIER        Lexeme: pDseg
Line: 2438  Token: INC_OP            Lexeme: ++
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 postfix_expression -> postfix_expression INC_OP
Line: 2438  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2439  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2439  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2439  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2439  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 2439  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2440  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2440  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2440  Token: IDENTIFIER        Lexeme: dsdIndxInBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2440  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 2440  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2441  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2441  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2441  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2441  Token: DEC_OP            Lexeme: --
 postfix_expression -> postfix_expression DEC_OP
Line: 2441  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2442  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2446  Token: IF                Lexeme: if
Line: 2446  Token: (  Lexeme: (
Line: 2446  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2446  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2446  Token: PTR_OP            Lexeme: ->
Line: 2446  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2446  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2446  Token: {  Lexeme: {
Line: 2447  Token: BREAK             Lexeme: break
Line: 2447  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2448  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2450  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2450  Token: (  Lexeme: (
Line: 2450  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2450  Token: PTR_OP            Lexeme: ->
Line: 2450  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2450  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 2450  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2450  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2450  Token: {  Lexeme: {
Line: 2454  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2454  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2454  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2454  Token: AND_ASSIGN        Lexeme: &=
 unary_expression -> postfix_expression
 assignment_operator -> AND_ASSIGN
Line: 2454  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 2454  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2454  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2458  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2458  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2458  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2458  Token: PTR_OP            Lexeme: ->
Line: 2458  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2458  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2458  Token: IDENTIFIER        Lexeme: allocDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2458  Token: (  Lexeme: (
Line: 2458  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2458  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2458  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2466  Token: IF                Lexeme: if
Line: 2466  Token: (  Lexeme: (
Line: 2466  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2466  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2466  Token: PTR_OP            Lexeme: ->
Line: 2466  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2466  Token: PTR_OP            Lexeme: ->
Line: 2466  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2466  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2466  Token: {  Lexeme: {
Line: 2468  Token: RETURN            Lexeme: return
Line: 2468  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2468  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2469  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2473  Token: IDENTIFIER        Lexeme: pHqpCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2473  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2473  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2473  Token: PTR_OP            Lexeme: ->
Line: 2473  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2473  Token: .  Lexeme: .
Line: 2473  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2473  Token: .  Lexeme: .
Line: 2473  Token: IDENTIFIER        Lexeme: nxt_crp_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2473  Token: .  Lexeme: .
Line: 2473  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2473  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2473  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2473  Token: PTR_OP            Lexeme: ->
Line: 2473  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2473  Token: PTR_OP            Lexeme: ->
Line: 2473  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2473  Token: PTR_OP            Lexeme: ->
Line: 2473  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2473  Token: .  Lexeme: .
Line: 2473  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2473  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2473  Token: CONSTANT          Lexeme: 0x80000000
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2473  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2480  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2480  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2480  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2480  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2480  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2480  Token: PTR_OP            Lexeme: ->
Line: 2480  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2480  Token: PTR_OP            Lexeme: ->
Line: 2480  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2480  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2481  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2481  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2481  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2481  Token: PTR_OP            Lexeme: ->
Line: 2481  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2481  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2481  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2481  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2482  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2482  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2482  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2482  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2482  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2482  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2487  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2487  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2487  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2487  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2487  Token: PTR_OP            Lexeme: ->
Line: 2487  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2487  Token: PTR_OP            Lexeme: ->
Line: 2487  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2487  Token: .  Lexeme: .
Line: 2487  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2487  Token: .  Lexeme: .
Line: 2487  Token: IDENTIFIER        Lexeme: dsd_list_0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2487  Token: [  Lexeme: [
Line: 2487  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2487  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2487  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2489  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2492  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2492  Token: (  Lexeme: (
Line: 2492  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2492  Token: PTR_OP            Lexeme: ->
Line: 2492  Token: IDENTIFIER        Lexeme: dsdIndxInBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2492  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 2492  Token: CONSTANT          Lexeme: 5
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2492  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2492  Token: {  Lexeme: {
Line: 2493  Token: BREAK             Lexeme: break
Line: 2493  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2494  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2498  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2498  Token: ELSE              Lexeme: else
Line: 2498  Token: {  Lexeme: {
Line: 2502  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2502  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2502  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2502  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2502  Token: PTR_OP            Lexeme: ->
Line: 2502  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2502  Token: PTR_OP            Lexeme: ->
Line: 2502  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2502  Token: .  Lexeme: .
Line: 2502  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2502  Token: .  Lexeme: .
Line: 2502  Token: IDENTIFIER        Lexeme: dsd_list_0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2502  Token: [  Lexeme: [
Line: 2502  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2502  Token: PTR_OP            Lexeme: ->
Line: 2502  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2502  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2502  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2504  Token: WHILE             Lexeme: while
Line: 2504  Token: (  Lexeme: (
Line: 2504  Token: (  Lexeme: (
Line: 2504  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2504  Token: PTR_OP            Lexeme: ->
Line: 2504  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2504  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 2504  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2504  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2504  Token: AND_OP            Lexeme: &&
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
Line: 2505  Token: (  Lexeme: (
Line: 2505  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2505  Token: PTR_OP            Lexeme: ->
Line: 2505  Token: IDENTIFIER        Lexeme: dsdIndxInBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2505  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 2505  Token: CONSTANT          Lexeme: 5
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2505  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2505  Token: AND_OP            Lexeme: &&
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression
Line: 2506  Token: (  Lexeme: (
Line: 2506  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2506  Token: PTR_OP            Lexeme: ->
Line: 2506  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2506  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2506  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2506  Token: {  Lexeme: {
Line: 2508  Token: IF                Lexeme: if
Line: 2508  Token: (  Lexeme: (
Line: 2508  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2508  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2508  Token: PTR_OP            Lexeme: ->
Line: 2508  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2508  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2508  Token: {  Lexeme: {
Line: 2512  Token: }  Lexeme: }
 compound_statement -> '{' '}'
 statement -> compound_statement
Line: 2513  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2513  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2513  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2513  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2513  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2513  Token: PTR_OP            Lexeme: ->
Line: 2513  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2513  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2514  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2514  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2514  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2514  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2514  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2514  Token: PTR_OP            Lexeme: ->
Line: 2514  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2514  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2515  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2515  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2515  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2515  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2515  Token: IDENTIFIER        Lexeme: pDseg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2515  Token: PTR_OP            Lexeme: ->
Line: 2515  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2515  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2517  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2517  Token: INC_OP            Lexeme: ++
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 postfix_expression -> postfix_expression INC_OP
Line: 2517  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2518  Token: IDENTIFIER        Lexeme: pDseg
Line: 2518  Token: INC_OP            Lexeme: ++
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 postfix_expression -> postfix_expression INC_OP
Line: 2518  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2519  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2519  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2519  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2519  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 2519  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2520  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2520  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2520  Token: IDENTIFIER        Lexeme: dsdIndxInBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2520  Token: INC_OP            Lexeme: ++
 postfix_expression -> postfix_expression INC_OP
Line: 2520  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2521  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2521  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2521  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2521  Token: DEC_OP            Lexeme: --
 postfix_expression -> postfix_expression DEC_OP
Line: 2521  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2522  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2526  Token: IF                Lexeme: if
Line: 2526  Token: (  Lexeme: (
Line: 2526  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2526  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2526  Token: PTR_OP            Lexeme: ->
Line: 2526  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2526  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2526  Token: {  Lexeme: {
Line: 2527  Token: BREAK             Lexeme: break
Line: 2527  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2528  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2530  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2530  Token: (  Lexeme: (
Line: 2530  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2530  Token: PTR_OP            Lexeme: ->
Line: 2530  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2530  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 2530  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2530  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2530  Token: {  Lexeme: {
Line: 2535  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2535  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2535  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2535  Token: PTR_OP            Lexeme: ->
Line: 2535  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2535  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2535  Token: IDENTIFIER        Lexeme: allocDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2535  Token: (  Lexeme: (
Line: 2535  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2535  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2535  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2543  Token: IF                Lexeme: if
Line: 2543  Token: (  Lexeme: (
Line: 2543  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2543  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2543  Token: PTR_OP            Lexeme: ->
Line: 2543  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2543  Token: PTR_OP            Lexeme: ->
Line: 2543  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2543  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2543  Token: {  Lexeme: {
Line: 2545  Token: RETURN            Lexeme: return
Line: 2545  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2545  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2546  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2551  Token: IDENTIFIER        Lexeme: pHqpCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2551  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2551  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2551  Token: PTR_OP            Lexeme: ->
Line: 2551  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2551  Token: .  Lexeme: .
Line: 2551  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2551  Token: .  Lexeme: .
Line: 2551  Token: IDENTIFIER        Lexeme: nxt_crp_ptr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2551  Token: .  Lexeme: .
Line: 2551  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2551  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2551  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2551  Token: PTR_OP            Lexeme: ->
Line: 2551  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2551  Token: PTR_OP            Lexeme: ->
Line: 2551  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2551  Token: PTR_OP            Lexeme: ->
Line: 2551  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2551  Token: .  Lexeme: .
Line: 2551  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2551  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2551  Token: CONSTANT          Lexeme: 0x80000000
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2551  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2556  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2556  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2556  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2556  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2556  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2556  Token: PTR_OP            Lexeme: ->
Line: 2556  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2556  Token: PTR_OP            Lexeme: ->
Line: 2556  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2556  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2557  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2557  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2557  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2557  Token: PTR_OP            Lexeme: ->
Line: 2557  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2557  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2557  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2557  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2558  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2558  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2558  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2558  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2558  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2558  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2563  Token: IDENTIFIER        Lexeme: pDsegInDrpCrp
Line: 2563  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2563  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2563  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2563  Token: PTR_OP            Lexeme: ->
Line: 2563  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2563  Token: PTR_OP            Lexeme: ->
Line: 2563  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2563  Token: .  Lexeme: .
Line: 2563  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2563  Token: .  Lexeme: .
Line: 2563  Token: IDENTIFIER        Lexeme: dsd_list_0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2563  Token: [  Lexeme: [
Line: 2563  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2563  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2563  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2565  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2569  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2569  Token: (  Lexeme: (
Line: 2569  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2569  Token: PTR_OP            Lexeme: ->
Line: 2569  Token: IDENTIFIER        Lexeme: dsdIndxInBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2569  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 2569  Token: CONSTANT          Lexeme: 5
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2569  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2569  Token: {  Lexeme: {
Line: 2570  Token: BREAK             Lexeme: break
Line: 2570  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2571  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2573  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2575  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2576  Token: BREAK             Lexeme: break
Line: 2576  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2577  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2580  Token: CASE              Lexeme: case
Line: 2580  Token: CONSTANT          Lexeme: 0x6A
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2580  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2580  Token: {  Lexeme: {
Line: 2582  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 2582  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2582  Token: IDENTIFIER        Lexeme: pDmaCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2582  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2582  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2582  Token: PTR_OP            Lexeme: ->
Line: 2582  Token: IDENTIFIER        Lexeme: pDmaCb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2582  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDmaCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 2583  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2583  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2583  Token: IDENTIFIER        Lexeme: treg
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 2583  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: treg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2585  Token: SWITCH            Lexeme: switch
Line: 2585  Token: (  Lexeme: (
Line: 2585  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2585  Token: PTR_OP            Lexeme: ->
Line: 2585  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2585  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2585  Token: {  Lexeme: {
Line: 2587  Token: CASE              Lexeme: case
Line: 2587  Token: IDENTIFIER        Lexeme: HQP_STATE_PROC_IOCB
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2587  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2589  Token: IF                Lexeme: if
Line: 2589  Token: (  Lexeme: (
Line: 2589  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2589  Token: PTR_OP            Lexeme: ->
Line: 2589  Token: IDENTIFIER        Lexeme: cmnd_crc2
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2589  Token: .  Lexeme: .
Line: 2589  Token: IDENTIFIER        Lexeme: cmnd_cntl
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2589  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2589  Token: CONSTANT          Lexeme: 0x0004
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2589  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2589  Token: {  Lexeme: {
Line: 2590  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2590  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2590  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2590  Token: UNKNOWN     Lexeme: |=
 unary_expression -> postfix_expression
 assignment_operator -> OR_ASSIGN
Line: 2590  Token: CONSTANT          Lexeme: 0x0001
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2590  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2591  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2592  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2592  Token: (  Lexeme: (
Line: 2592  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2592  Token: PTR_OP            Lexeme: ->
Line: 2592  Token: IDENTIFIER        Lexeme: cmnd_crc2
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2592  Token: .  Lexeme: .
Line: 2592  Token: IDENTIFIER        Lexeme: cmnd_cntl
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2592  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2592  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2592  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2592  Token: {  Lexeme: {
Line: 2593  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2593  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2593  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2593  Token: UNKNOWN     Lexeme: |=
 unary_expression -> postfix_expression
 assignment_operator -> OR_ASSIGN
Line: 2593  Token: CONSTANT          Lexeme: 0x0004
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2593  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2594  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2598  Token: IDENTIFIER        Lexeme: pHqpCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2598  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2598  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2598  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2598  Token: IDENTIFIER        Lexeme: allocDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2598  Token: (  Lexeme: (
Line: 2598  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2598  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2598  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2606  Token: IF                Lexeme: if
Line: 2606  Token: (  Lexeme: (
Line: 2606  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2606  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2606  Token: PTR_OP            Lexeme: ->
Line: 2606  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2606  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2606  Token: {  Lexeme: {
Line: 2608  Token: RETURN            Lexeme: return
Line: 2608  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2608  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2609  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2615  Token: IDENTIFIER        Lexeme: pDmaCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2615  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2615  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2615  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2615  Token: IDENTIFIER        Lexeme: DMA_TYPE_CRC_CNTXT
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2615  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2616  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2616  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2616  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2616  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2616  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2616  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2616  Token: PTR_OP            Lexeme: ->
Line: 2616  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2616  Token: PTR_OP            Lexeme: ->
Line: 2616  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2616  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2617  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2617  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2617  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2617  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2617  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2617  Token: PTR_OP            Lexeme: ->
Line: 2617  Token: IDENTIFIER        Lexeme: cmnd_crc2
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2617  Token: .  Lexeme: .
Line: 2617  Token: IDENTIFIER        Lexeme: cmnd_crc_ctx_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2617  Token: .  Lexeme: .
Line: 2617  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2617  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2618  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2618  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2618  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2618  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2618  Token: IDENTIFIER        Lexeme: pIocb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2618  Token: PTR_OP            Lexeme: ->
Line: 2618  Token: IDENTIFIER        Lexeme: cmnd_crc2
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2618  Token: .  Lexeme: .
Line: 2618  Token: IDENTIFIER        Lexeme: cmnd_crc_ctx_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2618  Token: .  Lexeme: .
Line: 2618  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2618  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2619  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2619  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2619  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2619  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2619  Token: SIZEOF            Lexeme: sizeof
Line: 2619  Token: (  Lexeme: (
Line: 2619  Token: IDENTIFIER        Lexeme: dcrc_ctxt_struct
 type_specifier -> TYPE_NAME
Line: 2619  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2619  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2619  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2619  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2620  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2620  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2620  Token: IDENTIFIER        Lexeme: hqpId
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2620  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2620  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2620  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2621  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2621  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2621  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2621  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2621  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_CRC_CNTXT_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2621  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2625  Token: IF                Lexeme: if
Line: 2625  Token: (  Lexeme: (
Line: 2625  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2625  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2625  Token: (  Lexeme: (
Line: 2625  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2625  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2625  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2625  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2625  Token: {  Lexeme: {
Line: 2626  Token: IDENTIFIER        Lexeme: enque
Line: 2626  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2626  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2626  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2626  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2626  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2626  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2626  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2627  Token: RETURN            Lexeme: return
Line: 2627  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2627  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2628  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2630  Token: IDENTIFIER        Lexeme: treg
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2630  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2630  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2630  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2630  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2630  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2630  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2630  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2630  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2630  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2630  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2630  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2630  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2630  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2630  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: (  Lexeme: (
Line: 2630  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2630  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2630  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2630  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2630  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2630  Token: PTR_OP            Lexeme: ->
Line: 2630  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2630  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2630  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2630  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2630  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2630  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2630  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2632  Token: WHILE             Lexeme: while
Line: 2632  Token: (  Lexeme: (
Line: 2632  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2632  Token: (  Lexeme: (
Line: 2632  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2632  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2632  Token: (  Lexeme: (
Line: 2632  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2632  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2632  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2632  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2632  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2632  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2632  Token: {  Lexeme: {
Line: 2633  Token: IDENTIFIER        Lexeme: treg
Line: 2633  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2633  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2633  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2633  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2633  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2633  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2633  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2633  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2633  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2633  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2633  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2633  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2633  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2633  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: (  Lexeme: (
Line: 2633  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2633  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2633  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2633  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2633  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2633  Token: PTR_OP            Lexeme: ->
Line: 2633  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2633  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2633  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2633  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2633  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2633  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2633  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2634  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2636  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2636  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2636  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2636  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2636  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2636  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2636  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2636  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2636  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2636  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2636  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2636  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2636  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2636  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2636  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2636  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2636  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2636  Token: PTR_OP            Lexeme: ->
Line: 2636  Token: IDENTIFIER        Lexeme: hostDmaSpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2636  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2636  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2636  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2636  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2636  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2636  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2636  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2636  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2636  Token: PTR_OP            Lexeme: ->
Line: 2636  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2636  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2636  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2636  Token: (  Lexeme: (
Line: 2636  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2636  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2636  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2636  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2636  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2637  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2637  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2637  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2637  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2637  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2637  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2637  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2637  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2637  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2637  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2637  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2637  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2637  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: (  Lexeme: (
Line: 2637  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2637  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2637  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2637  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2637  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2637  Token: PTR_OP            Lexeme: ->
Line: 2637  Token: IDENTIFIER        Lexeme: hostDmaAdrlReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2637  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2637  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2637  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2637  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2637  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2637  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2637  Token: PTR_OP            Lexeme: ->
Line: 2637  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2637  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2637  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2638  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2638  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2638  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2638  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2638  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2638  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2638  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2638  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2638  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2638  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2638  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2638  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2638  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: (  Lexeme: (
Line: 2638  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2638  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2638  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2638  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2638  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2638  Token: PTR_OP            Lexeme: ->
Line: 2638  Token: IDENTIFIER        Lexeme: hostDmaAdrhReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2638  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2638  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2638  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2638  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2638  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2638  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2638  Token: PTR_OP            Lexeme: ->
Line: 2638  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2638  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2638  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2639  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2639  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2639  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2639  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2639  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2639  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2639  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2639  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2639  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2639  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2639  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2639  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2639  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: (  Lexeme: (
Line: 2639  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2639  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2639  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2639  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2639  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2639  Token: PTR_OP            Lexeme: ->
Line: 2639  Token: IDENTIFIER        Lexeme: hostDmaHqpIdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2639  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2639  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2639  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2639  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2639  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2639  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2639  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2639  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2640  Token: IDENTIFIER        Lexeme: treg
Line: 2640  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2640  Token: (  Lexeme: (
Line: 2640  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2640  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2640  Token: CONSTANT          Lexeme: 14
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2640  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2640  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2640  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2640  Token: PTR_OP            Lexeme: ->
Line: 2640  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2640  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2642  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2642  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2642  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2642  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2642  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2642  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2642  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2642  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2642  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2642  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2642  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2642  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2642  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: (  Lexeme: (
Line: 2642  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2642  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2642  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2642  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2642  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2642  Token: PTR_OP            Lexeme: ->
Line: 2642  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2642  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2642  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2642  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2642  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2642  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2642  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2642  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2642  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2643  Token: IDENTIFIER        Lexeme: enque
Line: 2643  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2643  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2643  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2643  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2643  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2643  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2643  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2646  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2646  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2646  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2646  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2646  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2646  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2646  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2647  Token: IDENTIFIER        Lexeme: hostDmaHdwSim
Line: 2647  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2647  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 2647  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2648  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2648  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2648  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2648  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2648  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2652  Token: RETURN            Lexeme: return
Line: 2652  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2652  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2653  Token: BREAK             Lexeme: break
Line: 2653  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2658  Token: CASE              Lexeme: case
Line: 2658  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2658  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2660  Token: IF                Lexeme: if
Line: 2660  Token: (  Lexeme: (
Line: 2660  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2660  Token: IDENTIFIER        Lexeme: ProcessDsdList
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2660  Token: (  Lexeme: (
Line: 2660  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2660  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2660  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2660  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2660  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2660  Token: {  Lexeme: {
Line: 2661  Token: RETURN            Lexeme: return
Line: 2661  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2661  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2662  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2668  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2668  Token: (  Lexeme: (
Line: 2668  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2668  Token: (  Lexeme: (
Line: 2668  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2668  Token: PTR_OP            Lexeme: ->
Line: 2668  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2668  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2668  Token: CONSTANT          Lexeme: 0x0004
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2668  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2668  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2668  Token: {  Lexeme: {
Line: 2669  Token: BREAK             Lexeme: break
Line: 2669  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2670  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2671  Token: IDENTIFIER        Lexeme: dcrc_ctxt_struct
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 type_specifier -> TYPE_NAME
Line: 2671  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2671  Token: IDENTIFIER        Lexeme: pCrcCntxt
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2671  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2671  Token: (  Lexeme: (
Line: 2671  Token: IDENTIFIER        Lexeme: dcrc_ctxt_struct
 type_specifier -> TYPE_NAME
Line: 2671  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2671  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2671  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2671  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2671  Token: PTR_OP            Lexeme: ->
Line: 2671  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2671  Token: PTR_OP            Lexeme: ->
Line: 2671  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2671  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pCrcCntxt added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2672  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2672  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2672  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2672  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2672  Token: IDENTIFIER        Lexeme: DMA_TYPE_DSD
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2672  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2673  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2673  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2673  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2673  Token: PTR_OP            Lexeme: ->
Line: 2673  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2673  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2673  Token: IDENTIFIER        Lexeme: allocDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2673  Token: (  Lexeme: (
Line: 2673  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2673  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2673  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2677  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2677  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2677  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2677  Token: PTR_OP            Lexeme: ->
Line: 2677  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2677  Token: .  Lexeme: .
Line: 2677  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2677  Token: .  Lexeme: .
Line: 2677  Token: IDENTIFIER        Lexeme: nxt_crp_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2677  Token: .  Lexeme: .
Line: 2677  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2677  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2677  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2677  Token: PTR_OP            Lexeme: ->
Line: 2677  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2677  Token: PTR_OP            Lexeme: ->
Line: 2677  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2677  Token: PTR_OP            Lexeme: ->
Line: 2677  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2677  Token: .  Lexeme: .
Line: 2677  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2677  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2677  Token: CONSTANT          Lexeme: 0x80000000
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2677  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2678  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2678  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2678  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2678  Token: AND_ASSIGN        Lexeme: &=
 unary_expression -> postfix_expression
 assignment_operator -> AND_ASSIGN
Line: 2678  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 2678  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2678  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2679  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2679  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2679  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2679  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2679  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2679  Token: PTR_OP            Lexeme: ->
Line: 2679  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2679  Token: PTR_OP            Lexeme: ->
Line: 2679  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2679  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2680  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2680  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2680  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2680  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2680  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2680  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2680  Token: PTR_OP            Lexeme: ->
Line: 2680  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2680  Token: PTR_OP            Lexeme: ->
Line: 2680  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2680  Token: .  Lexeme: .
Line: 2680  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2680  Token: .  Lexeme: .
Line: 2680  Token: IDENTIFIER        Lexeme: dsd_list_0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2680  Token: [  Lexeme: [
Line: 2680  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2680  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2680  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2681  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2681  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2681  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2681  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2681  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2681  Token: PTR_OP            Lexeme: ->
Line: 2681  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2681  Token: .  Lexeme: .
Line: 2681  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2681  Token: .  Lexeme: .
Line: 2681  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2681  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2682  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2682  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2682  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2682  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2682  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2682  Token: PTR_OP            Lexeme: ->
Line: 2682  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2682  Token: .  Lexeme: .
Line: 2682  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2682  Token: .  Lexeme: .
Line: 2682  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2682  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2683  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2683  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2683  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2683  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2683  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2683  Token: PTR_OP            Lexeme: ->
Line: 2683  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2683  Token: .  Lexeme: .
Line: 2683  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2683  Token: .  Lexeme: .
Line: 2683  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2683  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2684  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2684  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2684  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2684  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2684  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2684  Token: PTR_OP            Lexeme: ->
Line: 2684  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2684  Token: .  Lexeme: .
Line: 2684  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2684  Token: .  Lexeme: .
Line: 2684  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2684  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2684  Token: (  Lexeme: (
Line: 2684  Token: SIZEOF            Lexeme: sizeof
Line: 2684  Token: (  Lexeme: (
Line: 2684  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2684  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2684  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2684  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2684  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2684  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2685  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2685  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2685  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2685  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2685  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_CRC_DIF_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2685  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2690  Token: IF                Lexeme: if
Line: 2690  Token: (  Lexeme: (
Line: 2690  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2690  Token: PTR_OP            Lexeme: ->
Line: 2690  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2690  Token: >  Lexeme: >
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 2690  Token: (  Lexeme: (
Line: 2690  Token: (  Lexeme: (
Line: 2690  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2690  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2690  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2690  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2690  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2690  Token: SIZEOF            Lexeme: sizeof
Line: 2690  Token: (  Lexeme: (
Line: 2690  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2690  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2690  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 2690  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2690  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2690  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '>' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2690  Token: {  Lexeme: {
Line: 2691  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2691  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2691  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2691  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2691  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2691  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2691  Token: SIZEOF            Lexeme: sizeof
Line: 2691  Token: (  Lexeme: (
Line: 2691  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2691  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2691  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 2691  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2691  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2692  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2697  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2697  Token: (  Lexeme: (
Line: 2697  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2697  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2697  Token: (  Lexeme: (
Line: 2697  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2697  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2697  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2697  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2697  Token: {  Lexeme: {
Line: 2698  Token: IDENTIFIER        Lexeme: enque
Line: 2698  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2698  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2698  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2698  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2698  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2698  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2698  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2699  Token: RETURN            Lexeme: return
Line: 2699  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2699  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2700  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2702  Token: IDENTIFIER        Lexeme: treg
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2702  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2702  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2702  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2702  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2702  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2702  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2702  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2702  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2702  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2702  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2702  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2702  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2702  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2702  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: (  Lexeme: (
Line: 2702  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2702  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2702  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2702  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2702  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2702  Token: PTR_OP            Lexeme: ->
Line: 2702  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2702  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2702  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2702  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2702  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2702  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2702  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2704  Token: WHILE             Lexeme: while
Line: 2704  Token: (  Lexeme: (
Line: 2704  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2704  Token: (  Lexeme: (
Line: 2704  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2704  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2704  Token: (  Lexeme: (
Line: 2704  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2704  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2704  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2704  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2704  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2704  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2704  Token: {  Lexeme: {
Line: 2705  Token: IDENTIFIER        Lexeme: treg
Line: 2705  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2705  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2705  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2705  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2705  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2705  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2705  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2705  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2705  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2705  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2705  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2705  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2705  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2705  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: (  Lexeme: (
Line: 2705  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2705  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2705  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2705  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2705  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2705  Token: PTR_OP            Lexeme: ->
Line: 2705  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2705  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2705  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2705  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2705  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2705  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2705  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2706  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2708  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2708  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2708  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2708  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2708  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2708  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2708  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2708  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2708  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2708  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2708  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2708  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2708  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2708  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2708  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2708  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2708  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2708  Token: PTR_OP            Lexeme: ->
Line: 2708  Token: IDENTIFIER        Lexeme: hostDmaSpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2708  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2708  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2708  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2708  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2708  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2708  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2708  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2708  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2708  Token: PTR_OP            Lexeme: ->
Line: 2708  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2708  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2708  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2708  Token: (  Lexeme: (
Line: 2708  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2708  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2708  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2708  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2708  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2709  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2709  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2709  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2709  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2709  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2709  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2709  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2709  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2709  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2709  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2709  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2709  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2709  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: (  Lexeme: (
Line: 2709  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2709  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2709  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2709  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2709  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2709  Token: PTR_OP            Lexeme: ->
Line: 2709  Token: IDENTIFIER        Lexeme: hostDmaAdrlReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2709  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2709  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2709  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2709  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2709  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2709  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2709  Token: PTR_OP            Lexeme: ->
Line: 2709  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2709  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2709  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2710  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2710  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2710  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2710  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2710  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2710  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2710  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2710  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2710  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2710  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2710  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2710  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2710  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: (  Lexeme: (
Line: 2710  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2710  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2710  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2710  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2710  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2710  Token: PTR_OP            Lexeme: ->
Line: 2710  Token: IDENTIFIER        Lexeme: hostDmaAdrhReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2710  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2710  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2710  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2710  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2710  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2710  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2710  Token: PTR_OP            Lexeme: ->
Line: 2710  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2710  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2710  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2711  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2711  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2711  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2711  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2711  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2711  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2711  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2711  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2711  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2711  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2711  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2711  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2711  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: (  Lexeme: (
Line: 2711  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2711  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2711  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2711  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2711  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2711  Token: PTR_OP            Lexeme: ->
Line: 2711  Token: IDENTIFIER        Lexeme: hostDmaHqpIdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2711  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2711  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2711  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2711  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2711  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2711  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2711  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2711  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2712  Token: IDENTIFIER        Lexeme: treg
Line: 2712  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2712  Token: (  Lexeme: (
Line: 2712  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2712  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2712  Token: CONSTANT          Lexeme: 14
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2712  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2712  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2712  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2712  Token: PTR_OP            Lexeme: ->
Line: 2712  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2712  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2714  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2714  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2714  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2714  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2714  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2714  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2714  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2714  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2714  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2714  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2714  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2714  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2714  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: (  Lexeme: (
Line: 2714  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2714  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2714  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2714  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2714  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2714  Token: PTR_OP            Lexeme: ->
Line: 2714  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2714  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2714  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2714  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2714  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2714  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2714  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2714  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2714  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2715  Token: IDENTIFIER        Lexeme: enque
Line: 2715  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2715  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2715  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2715  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2715  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2715  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2715  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2718  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2718  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2718  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2718  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2718  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2718  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2718  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2719  Token: IDENTIFIER        Lexeme: hostDmaHdwSim
Line: 2719  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2719  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 2719  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2720  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2720  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2720  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2720  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2720  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2724  Token: RETURN            Lexeme: return
Line: 2724  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2724  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2726  Token: BREAK             Lexeme: break
Line: 2726  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2731  Token: CASE              Lexeme: case
Line: 2731  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_LPTR_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2731  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2731  Token: {  Lexeme: {
Line: 2733  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2733  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2733  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2733  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2733  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2733  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2734  Token: IF                Lexeme: if
Line: 2734  Token: (  Lexeme: (
Line: 2734  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2734  Token: IDENTIFIER        Lexeme: ProcessDsdList
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2734  Token: (  Lexeme: (
Line: 2734  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2734  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2734  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2734  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2734  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2734  Token: {  Lexeme: {
Line: 2735  Token: RETURN            Lexeme: return
Line: 2735  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2735  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2736  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2742  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2742  Token: (  Lexeme: (
Line: 2742  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2742  Token: (  Lexeme: (
Line: 2742  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2742  Token: PTR_OP            Lexeme: ->
Line: 2742  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2742  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2742  Token: CONSTANT          Lexeme: 0x0004
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2742  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2742  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2742  Token: {  Lexeme: {
Line: 2743  Token: BREAK             Lexeme: break
Line: 2743  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2744  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2745  Token: IDENTIFIER        Lexeme: dcrc_ctxt_struct
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 type_specifier -> TYPE_NAME
Line: 2745  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2745  Token: IDENTIFIER        Lexeme: pCrcCntxt
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2745  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2745  Token: (  Lexeme: (
Line: 2745  Token: IDENTIFIER        Lexeme: dcrc_ctxt_struct
 type_specifier -> TYPE_NAME
Line: 2745  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2745  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2745  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2745  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2745  Token: PTR_OP            Lexeme: ->
Line: 2745  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2745  Token: PTR_OP            Lexeme: ->
Line: 2745  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2745  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pCrcCntxt added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2746  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2746  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2746  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2746  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2746  Token: IDENTIFIER        Lexeme: DMA_TYPE_DSD
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2746  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2747  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2747  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2747  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2747  Token: PTR_OP            Lexeme: ->
Line: 2747  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2747  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2747  Token: IDENTIFIER        Lexeme: allocDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2747  Token: (  Lexeme: (
Line: 2747  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2747  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2747  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2748  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2748  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2748  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2748  Token: AND_ASSIGN        Lexeme: &=
 unary_expression -> postfix_expression
 assignment_operator -> AND_ASSIGN
Line: 2748  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 2748  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2748  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2749  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2749  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2749  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2749  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2749  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2749  Token: PTR_OP            Lexeme: ->
Line: 2749  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2749  Token: PTR_OP            Lexeme: ->
Line: 2749  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2749  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2750  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2750  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2750  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2750  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2750  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2750  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2750  Token: PTR_OP            Lexeme: ->
Line: 2750  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2750  Token: PTR_OP            Lexeme: ->
Line: 2750  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2750  Token: .  Lexeme: .
Line: 2750  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2750  Token: .  Lexeme: .
Line: 2750  Token: IDENTIFIER        Lexeme: dsd_list_0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2750  Token: [  Lexeme: [
Line: 2750  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2750  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2750  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2751  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2751  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2751  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2751  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2751  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2751  Token: PTR_OP            Lexeme: ->
Line: 2751  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2751  Token: .  Lexeme: .
Line: 2751  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2751  Token: .  Lexeme: .
Line: 2751  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2751  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2752  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2752  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2752  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2752  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2752  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2752  Token: PTR_OP            Lexeme: ->
Line: 2752  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2752  Token: .  Lexeme: .
Line: 2752  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2752  Token: .  Lexeme: .
Line: 2752  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2752  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2753  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2753  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2753  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2753  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2753  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2753  Token: PTR_OP            Lexeme: ->
Line: 2753  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2753  Token: .  Lexeme: .
Line: 2753  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2753  Token: .  Lexeme: .
Line: 2753  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2753  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2754  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2754  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2754  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2754  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2754  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2754  Token: PTR_OP            Lexeme: ->
Line: 2754  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2754  Token: .  Lexeme: .
Line: 2754  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2754  Token: .  Lexeme: .
Line: 2754  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2754  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2754  Token: (  Lexeme: (
Line: 2754  Token: SIZEOF            Lexeme: sizeof
Line: 2754  Token: (  Lexeme: (
Line: 2754  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2754  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2754  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2754  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2754  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2754  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2755  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2755  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2755  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2755  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2755  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_CRC_DIF_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2755  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2761  Token: IF                Lexeme: if
Line: 2761  Token: (  Lexeme: (
Line: 2761  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2761  Token: PTR_OP            Lexeme: ->
Line: 2761  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2761  Token: >  Lexeme: >
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 2761  Token: (  Lexeme: (
Line: 2761  Token: (  Lexeme: (
Line: 2761  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2761  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2761  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2761  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2761  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2761  Token: SIZEOF            Lexeme: sizeof
Line: 2761  Token: (  Lexeme: (
Line: 2761  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2761  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2761  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 2761  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2761  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2761  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '>' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2761  Token: {  Lexeme: {
Line: 2762  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2762  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2762  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2762  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2762  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2762  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2762  Token: SIZEOF            Lexeme: sizeof
Line: 2762  Token: (  Lexeme: (
Line: 2762  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2762  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2762  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 2762  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2762  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2763  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2768  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2768  Token: (  Lexeme: (
Line: 2768  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2768  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2768  Token: (  Lexeme: (
Line: 2768  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2768  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2768  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2768  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2768  Token: {  Lexeme: {
Line: 2769  Token: IDENTIFIER        Lexeme: enque
Line: 2769  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2769  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2769  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2769  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2769  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2769  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2769  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2770  Token: RETURN            Lexeme: return
Line: 2770  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2770  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2771  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2773  Token: IDENTIFIER        Lexeme: treg
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2773  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2773  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2773  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2773  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2773  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2773  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2773  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2773  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2773  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2773  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2773  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2773  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2773  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2773  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: (  Lexeme: (
Line: 2773  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2773  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2773  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2773  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2773  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2773  Token: PTR_OP            Lexeme: ->
Line: 2773  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2773  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2773  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2773  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2773  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2773  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2773  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2775  Token: WHILE             Lexeme: while
Line: 2775  Token: (  Lexeme: (
Line: 2775  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2775  Token: (  Lexeme: (
Line: 2775  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2775  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2775  Token: (  Lexeme: (
Line: 2775  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2775  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2775  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2775  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2775  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2775  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2775  Token: {  Lexeme: {
Line: 2776  Token: IDENTIFIER        Lexeme: treg
Line: 2776  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2776  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2776  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2776  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2776  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2776  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2776  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2776  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2776  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2776  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2776  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2776  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2776  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2776  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: (  Lexeme: (
Line: 2776  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2776  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2776  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2776  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2776  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2776  Token: PTR_OP            Lexeme: ->
Line: 2776  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2776  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2776  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2776  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2776  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2776  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2776  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2777  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2779  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2779  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2779  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2779  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2779  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2779  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2779  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2779  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2779  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2779  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2779  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2779  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2779  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2779  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2779  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2779  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2779  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2779  Token: PTR_OP            Lexeme: ->
Line: 2779  Token: IDENTIFIER        Lexeme: hostDmaSpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2779  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2779  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2779  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2779  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2779  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2779  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2779  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2779  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2779  Token: PTR_OP            Lexeme: ->
Line: 2779  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2779  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2779  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2779  Token: (  Lexeme: (
Line: 2779  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2779  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2779  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2779  Token: RIGHT_OP          Lexeme: >>
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2779  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2779  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression RIGHT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2779  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2780  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2780  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2780  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2780  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2780  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2780  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2780  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2780  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2780  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2780  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2780  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2780  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2780  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: (  Lexeme: (
Line: 2780  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2780  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2780  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2780  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2780  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2780  Token: PTR_OP            Lexeme: ->
Line: 2780  Token: IDENTIFIER        Lexeme: hostDmaAdrlReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2780  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2780  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2780  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2780  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2780  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2780  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2780  Token: PTR_OP            Lexeme: ->
Line: 2780  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2780  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2780  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2781  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2781  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2781  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2781  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2781  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2781  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2781  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2781  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2781  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2781  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2781  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2781  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2781  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: (  Lexeme: (
Line: 2781  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2781  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2781  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2781  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2781  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2781  Token: PTR_OP            Lexeme: ->
Line: 2781  Token: IDENTIFIER        Lexeme: hostDmaAdrhReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2781  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2781  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2781  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2781  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2781  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2781  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2781  Token: PTR_OP            Lexeme: ->
Line: 2781  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2781  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2781  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2782  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2782  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2782  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2782  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2782  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2782  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2782  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2782  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2782  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2782  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2782  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2782  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2782  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: (  Lexeme: (
Line: 2782  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2782  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2782  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2782  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2782  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2782  Token: PTR_OP            Lexeme: ->
Line: 2782  Token: IDENTIFIER        Lexeme: hostDmaHqpIdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2782  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2782  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2782  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2782  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2782  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2782  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2782  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2782  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2783  Token: IDENTIFIER        Lexeme: treg
Line: 2783  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2783  Token: (  Lexeme: (
Line: 2783  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2783  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2783  Token: CONSTANT          Lexeme: 14
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2783  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2783  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2783  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2783  Token: PTR_OP            Lexeme: ->
Line: 2783  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2783  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2785  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2785  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2785  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2785  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2785  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2785  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2785  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2785  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2785  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2785  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2785  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2785  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2785  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: (  Lexeme: (
Line: 2785  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2785  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2785  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2785  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2785  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2785  Token: PTR_OP            Lexeme: ->
Line: 2785  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2785  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2785  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2785  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2785  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2785  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2785  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2785  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2785  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2786  Token: IDENTIFIER        Lexeme: enque
Line: 2786  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2786  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2786  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2786  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2786  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2786  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2786  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2791  Token: IDENTIFIER        Lexeme: hostDmaHdwSim
Line: 2791  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2791  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 2791  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2796  Token: RETURN            Lexeme: return
Line: 2796  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2796  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2798  Token: BREAK             Lexeme: break
Line: 2798  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2799  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2806  Token: CASE              Lexeme: case
Line: 2806  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_CRC_DIF_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2806  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2808  Token: IF                Lexeme: if
Line: 2808  Token: (  Lexeme: (
Line: 2808  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2808  Token: IDENTIFIER        Lexeme: ProcessDsdList
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2808  Token: (  Lexeme: (
Line: 2808  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2808  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2808  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2808  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2808  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2808  Token: {  Lexeme: {
Line: 2809  Token: RETURN            Lexeme: return
Line: 2809  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2809  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2810  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2811  Token: BREAK             Lexeme: break
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2811  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2816  Token: CASE              Lexeme: case
Line: 2816  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DIF_LPTR_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2816  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2818  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2818  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2818  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2818  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2818  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_CRC_DIF_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2818  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2819  Token: IF                Lexeme: if
Line: 2819  Token: (  Lexeme: (
Line: 2819  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2819  Token: IDENTIFIER        Lexeme: ProcessDsdList
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2819  Token: (  Lexeme: (
Line: 2819  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2819  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2819  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2819  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2819  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2819  Token: {  Lexeme: {
Line: 2820  Token: RETURN            Lexeme: return
Line: 2820  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2820  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2821  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2822  Token: BREAK             Lexeme: break
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2822  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2827  Token: CASE              Lexeme: case
Line: 2827  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_CRC_CNTXT_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2827  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2827  Token: {  Lexeme: {
Line: 2829  Token: IF                Lexeme: if
Line: 2829  Token: (  Lexeme: (
Line: 2829  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2829  Token: (  Lexeme: (
Line: 2829  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2829  Token: PTR_OP            Lexeme: ->
Line: 2829  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2829  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2829  Token: (  Lexeme: (
Line: 2829  Token: CONSTANT          Lexeme: 0x0001
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2829  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2829  Token: CONSTANT          Lexeme: 0x0004
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2829  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2829  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2829  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2829  Token: {  Lexeme: {
Line: 2830  Token: BREAK             Lexeme: break
Line: 2830  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2831  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2835  Token: IDENTIFIER        Lexeme: pHqpCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2835  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2835  Token: IDENTIFIER        Lexeme: pBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2835  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2835  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2835  Token: PTR_OP            Lexeme: ->
Line: 2835  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2835  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2836  Token: IDENTIFIER        Lexeme: dcrc_ctxt_struct
 type_specifier -> TYPE_NAME
Line: 2836  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2836  Token: IDENTIFIER        Lexeme: pCrcCntxt
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2836  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2836  Token: (  Lexeme: (
Line: 2836  Token: IDENTIFIER        Lexeme: dcrc_ctxt_struct
 type_specifier -> TYPE_NAME
Line: 2836  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2836  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2836  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2836  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2836  Token: PTR_OP            Lexeme: ->
Line: 2836  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2836  Token: PTR_OP            Lexeme: ->
Line: 2836  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2836  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pCrcCntxt added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2837  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2837  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2837  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2837  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2837  Token: IDENTIFIER        Lexeme: DMA_TYPE_DSD
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2837  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2839  Token: IF                Lexeme: if
Line: 2839  Token: (  Lexeme: (
Line: 2839  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2839  Token: PTR_OP            Lexeme: ->
Line: 2839  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2839  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2839  Token: CONSTANT          Lexeme: 0x0001
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2839  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2839  Token: {  Lexeme: {
Line: 2840  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2840  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2840  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2840  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2840  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2840  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2840  Token: PTR_OP            Lexeme: ->
Line: 2840  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2840  Token: PTR_OP            Lexeme: ->
Line: 2840  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2840  Token: .  Lexeme: .
Line: 2840  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2840  Token: .  Lexeme: .
Line: 2840  Token: IDENTIFIER        Lexeme: dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2840  Token: [  Lexeme: [
Line: 2840  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2840  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2840  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2841  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2841  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2841  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2841  Token: UNKNOWN     Lexeme: |=
 unary_expression -> postfix_expression
 assignment_operator -> OR_ASSIGN
Line: 2841  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2841  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2842  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2842  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2842  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2842  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2842  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2842  Token: PTR_OP            Lexeme: ->
Line: 2842  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2842  Token: .  Lexeme: .
Line: 2842  Token: IDENTIFIER        Lexeme: data_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2842  Token: .  Lexeme: .
Line: 2842  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2842  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2843  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2843  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2843  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2843  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2843  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2843  Token: PTR_OP            Lexeme: ->
Line: 2843  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2843  Token: .  Lexeme: .
Line: 2843  Token: IDENTIFIER        Lexeme: data_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2843  Token: .  Lexeme: .
Line: 2843  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2843  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2844  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2844  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2844  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2844  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2844  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2844  Token: PTR_OP            Lexeme: ->
Line: 2844  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2844  Token: .  Lexeme: .
Line: 2844  Token: IDENTIFIER        Lexeme: data_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2844  Token: .  Lexeme: .
Line: 2844  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2844  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2845  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2845  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2845  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2845  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2845  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2845  Token: PTR_OP            Lexeme: ->
Line: 2845  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2845  Token: .  Lexeme: .
Line: 2845  Token: IDENTIFIER        Lexeme: data_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2845  Token: .  Lexeme: .
Line: 2845  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2845  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2845  Token: (  Lexeme: (
Line: 2845  Token: SIZEOF            Lexeme: sizeof
Line: 2845  Token: (  Lexeme: (
Line: 2845  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2845  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2845  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2845  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2845  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2845  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2846  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2846  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2846  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2846  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2846  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2846  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2851  Token: IF                Lexeme: if
Line: 2851  Token: (  Lexeme: (
Line: 2851  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2851  Token: PTR_OP            Lexeme: ->
Line: 2851  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2851  Token: >  Lexeme: >
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 2851  Token: (  Lexeme: (
Line: 2851  Token: (  Lexeme: (
Line: 2851  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2851  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2851  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2851  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2851  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2851  Token: SIZEOF            Lexeme: sizeof
Line: 2851  Token: (  Lexeme: (
Line: 2851  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2851  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2851  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 2851  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2851  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2851  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '>' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2851  Token: {  Lexeme: {
Line: 2852  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2852  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2852  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2852  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2852  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2852  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2852  Token: SIZEOF            Lexeme: sizeof
Line: 2852  Token: (  Lexeme: (
Line: 2852  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2852  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2852  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 2852  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2852  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2853  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2855  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2855  Token: ELSE              Lexeme: else
Line: 2855  Token: IF                Lexeme: if
Line: 2855  Token: (  Lexeme: (
Line: 2855  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2855  Token: PTR_OP            Lexeme: ->
Line: 2855  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2855  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2855  Token: CONSTANT          Lexeme: 0x0004
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2855  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2855  Token: {  Lexeme: {
Line: 2856  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2856  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2856  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2856  Token: PTR_OP            Lexeme: ->
Line: 2856  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2856  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2856  Token: IDENTIFIER        Lexeme: allocDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2856  Token: (  Lexeme: (
Line: 2856  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2856  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2856  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2860  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2860  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2860  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2860  Token: PTR_OP            Lexeme: ->
Line: 2860  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2860  Token: .  Lexeme: .
Line: 2860  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2860  Token: .  Lexeme: .
Line: 2860  Token: IDENTIFIER        Lexeme: nxt_crp_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2860  Token: .  Lexeme: .
Line: 2860  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2860  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2860  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2860  Token: PTR_OP            Lexeme: ->
Line: 2860  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2860  Token: PTR_OP            Lexeme: ->
Line: 2860  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2860  Token: PTR_OP            Lexeme: ->
Line: 2860  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2860  Token: .  Lexeme: .
Line: 2860  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2860  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2860  Token: CONSTANT          Lexeme: 0x80000000
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2860  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2861  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2861  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2861  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2861  Token: AND_ASSIGN        Lexeme: &=
 unary_expression -> postfix_expression
 assignment_operator -> AND_ASSIGN
Line: 2861  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 2861  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2861  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2862  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2862  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2862  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2862  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2862  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2862  Token: PTR_OP            Lexeme: ->
Line: 2862  Token: IDENTIFIER        Lexeme: pT10Cntxt
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2862  Token: PTR_OP            Lexeme: ->
Line: 2862  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2862  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2863  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2863  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2863  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2863  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2863  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2863  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2863  Token: PTR_OP            Lexeme: ->
Line: 2863  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2863  Token: PTR_OP            Lexeme: ->
Line: 2863  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2863  Token: .  Lexeme: .
Line: 2863  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2863  Token: .  Lexeme: .
Line: 2863  Token: IDENTIFIER        Lexeme: dsd_list_0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2863  Token: [  Lexeme: [
Line: 2863  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2863  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2863  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2864  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2864  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2864  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2864  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2864  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2864  Token: PTR_OP            Lexeme: ->
Line: 2864  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2864  Token: .  Lexeme: .
Line: 2864  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2864  Token: .  Lexeme: .
Line: 2864  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2864  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2865  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2865  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2865  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2865  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2865  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2865  Token: PTR_OP            Lexeme: ->
Line: 2865  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2865  Token: .  Lexeme: .
Line: 2865  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2865  Token: .  Lexeme: .
Line: 2865  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2865  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2866  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2866  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2866  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2866  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2866  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2866  Token: PTR_OP            Lexeme: ->
Line: 2866  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2866  Token: .  Lexeme: .
Line: 2866  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2866  Token: .  Lexeme: .
Line: 2866  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2866  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2867  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2867  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2867  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2867  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2867  Token: IDENTIFIER        Lexeme: pCrcCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2867  Token: PTR_OP            Lexeme: ->
Line: 2867  Token: IDENTIFIER        Lexeme: db
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2867  Token: .  Lexeme: .
Line: 2867  Token: IDENTIFIER        Lexeme: dif_dsd
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2867  Token: .  Lexeme: .
Line: 2867  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2867  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2867  Token: (  Lexeme: (
Line: 2867  Token: SIZEOF            Lexeme: sizeof
Line: 2867  Token: (  Lexeme: (
Line: 2867  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2867  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2867  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2867  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2867  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2867  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2868  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2868  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2868  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2868  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2868  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_CRC_DIF_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2868  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2874  Token: IF                Lexeme: if
Line: 2874  Token: (  Lexeme: (
Line: 2874  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2874  Token: PTR_OP            Lexeme: ->
Line: 2874  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2874  Token: >  Lexeme: >
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 2874  Token: (  Lexeme: (
Line: 2874  Token: (  Lexeme: (
Line: 2874  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2874  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2874  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2874  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2874  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2874  Token: SIZEOF            Lexeme: sizeof
Line: 2874  Token: (  Lexeme: (
Line: 2874  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2874  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2874  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 2874  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2874  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2874  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '>' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2874  Token: {  Lexeme: {
Line: 2875  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 2875  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2875  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2875  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2875  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2875  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2875  Token: SIZEOF            Lexeme: sizeof
Line: 2875  Token: (  Lexeme: (
Line: 2875  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2875  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2875  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 2875  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2875  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2876  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2878  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2879  Token: IDENTIFIER        Lexeme: pHqpCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2879  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2879  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2879  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2879  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2879  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2883  Token: IF                Lexeme: if
Line: 2883  Token: (  Lexeme: (
Line: 2883  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2883  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2883  Token: (  Lexeme: (
Line: 2883  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2883  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2883  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2883  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2883  Token: {  Lexeme: {
Line: 2884  Token: IDENTIFIER        Lexeme: enque
Line: 2884  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2884  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2884  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2884  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2884  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2884  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2884  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2885  Token: RETURN            Lexeme: return
Line: 2885  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2885  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2886  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2888  Token: IDENTIFIER        Lexeme: treg
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2888  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2888  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2888  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2888  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2888  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2888  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2888  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2888  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2888  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2888  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2888  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2888  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2888  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2888  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: (  Lexeme: (
Line: 2888  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2888  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2888  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2888  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2888  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2888  Token: PTR_OP            Lexeme: ->
Line: 2888  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2888  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2888  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2888  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2888  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2888  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2888  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2890  Token: WHILE             Lexeme: while
Line: 2890  Token: (  Lexeme: (
Line: 2890  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2890  Token: (  Lexeme: (
Line: 2890  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2890  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2890  Token: (  Lexeme: (
Line: 2890  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2890  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2890  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2890  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2890  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2890  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2890  Token: {  Lexeme: {
Line: 2891  Token: IDENTIFIER        Lexeme: treg
Line: 2891  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2891  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2891  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2891  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2891  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2891  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2891  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2891  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2891  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2891  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2891  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2891  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2891  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2891  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: (  Lexeme: (
Line: 2891  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2891  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2891  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2891  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2891  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2891  Token: PTR_OP            Lexeme: ->
Line: 2891  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2891  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2891  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2891  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2891  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2891  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2891  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2892  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2894  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2894  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2894  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2894  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2894  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2894  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2894  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2894  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2894  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2894  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2894  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2894  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2894  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2894  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2894  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2894  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2894  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2894  Token: PTR_OP            Lexeme: ->
Line: 2894  Token: IDENTIFIER        Lexeme: hostDmaSpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2894  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2894  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2894  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2894  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2894  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2894  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2894  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2894  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2894  Token: PTR_OP            Lexeme: ->
Line: 2894  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2894  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2894  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2894  Token: (  Lexeme: (
Line: 2894  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2894  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2894  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2894  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2894  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2895  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2895  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2895  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2895  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2895  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2895  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2895  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2895  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2895  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2895  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2895  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2895  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2895  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: (  Lexeme: (
Line: 2895  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2895  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2895  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2895  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2895  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2895  Token: PTR_OP            Lexeme: ->
Line: 2895  Token: IDENTIFIER        Lexeme: hostDmaAdrlReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2895  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2895  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2895  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2895  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2895  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2895  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2895  Token: PTR_OP            Lexeme: ->
Line: 2895  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2895  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2895  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2896  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2896  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2896  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2896  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2896  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2896  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2896  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2896  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2896  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2896  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2896  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2896  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2896  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: (  Lexeme: (
Line: 2896  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2896  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2896  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2896  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2896  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2896  Token: PTR_OP            Lexeme: ->
Line: 2896  Token: IDENTIFIER        Lexeme: hostDmaAdrhReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2896  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2896  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2896  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2896  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2896  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2896  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2896  Token: PTR_OP            Lexeme: ->
Line: 2896  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2896  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2896  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2897  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2897  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2897  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2897  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2897  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2897  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2897  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2897  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2897  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2897  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2897  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2897  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2897  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: (  Lexeme: (
Line: 2897  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2897  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2897  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2897  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2897  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2897  Token: PTR_OP            Lexeme: ->
Line: 2897  Token: IDENTIFIER        Lexeme: hostDmaHqpIdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2897  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2897  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2897  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2897  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2897  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2897  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2897  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2897  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2898  Token: IDENTIFIER        Lexeme: treg
Line: 2898  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2898  Token: (  Lexeme: (
Line: 2898  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2898  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 2898  Token: CONSTANT          Lexeme: 14
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2898  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2898  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2898  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2898  Token: PTR_OP            Lexeme: ->
Line: 2898  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2898  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 2900  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2900  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2900  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 2900  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2900  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2900  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2900  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2900  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2900  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2900  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2900  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2900  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 2900  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: (  Lexeme: (
Line: 2900  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 2900  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2900  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2900  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2900  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2900  Token: PTR_OP            Lexeme: ->
Line: 2900  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2900  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2900  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2900  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2900  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2900  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2900  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2900  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2900  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2901  Token: IDENTIFIER        Lexeme: enque
Line: 2901  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2901  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2901  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2901  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2901  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2901  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2901  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2904  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2904  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2904  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2904  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2904  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 2904  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2904  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2905  Token: IDENTIFIER        Lexeme: hostDmaHdwSim
Line: 2905  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2905  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 2905  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2906  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 2906  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2906  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 2906  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2906  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2910  Token: RETURN            Lexeme: return
Line: 2910  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2910  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2911  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2912  Token: BREAK             Lexeme: break
Line: 2912  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2913  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> SWITCH '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2915  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2917  Token: DEFAULT           Lexeme: default
Line: 2917  Token: :  Lexeme: :
Line: 2918  Token: BREAK             Lexeme: break
Line: 2918  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 labeled_statement -> DEFAULT ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2920  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> SWITCH '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2921  Token: BREAK             Lexeme: break
Line: 2921  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2922  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2924  Token: CASE              Lexeme: case
Line: 2924  Token: (  Lexeme: (
Line: 2924  Token: CONSTANT          Lexeme: 0x02
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2924  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2924  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2924  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2924  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2925  Token: BREAK             Lexeme: break
Line: 2925  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2927  Token: CASE              Lexeme: case
Line: 2927  Token: (  Lexeme: (
Line: 2927  Token: CONSTANT          Lexeme: 0x03
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2927  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2927  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2927  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2927  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2928  Token: BREAK             Lexeme: break
Line: 2928  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2930  Token: CASE              Lexeme: case
Line: 2930  Token: (  Lexeme: (
Line: 2930  Token: CONSTANT          Lexeme: 0x04
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2930  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2930  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2930  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2930  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 constant_expression -> conditional_expression
Line: 2931  Token: BREAK             Lexeme: break
Line: 2931  Token: ;  Lexeme: ;
 jump_statement -> BREAK ';'
 statement -> jump_statement
 labeled_statement -> CASE constant_expression ':' statement
 statement -> labeled_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2933  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> SWITCH '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2936  Token: RETURN            Lexeme: return
Line: 2936  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2936  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2937  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 function_definition -> declaration_specifiers declarator compound_statement
 external_declaration -> function_definition
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 2939  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 2939  Token: IDENTIFIER        Lexeme: ProcessDsdList
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 2939  Token: (  Lexeme: (
Line: 2939  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 2939  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 2939  Token: ,  Lexeme: ,
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
Line: 2939  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 2939  Token: IDENTIFIER        Lexeme: dsdListPointer
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 2939  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_list ',' parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 2939  Token: {  Lexeme: {
 declarator -> direct_declarator
Line: 2941  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 2941  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2941  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2941  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2941  Token: IDENTIFIER        Lexeme: HqpLookup
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2941  Token: [  Lexeme: [
Line: 2941  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2941  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 2941  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 2942  Token: IDENTIFIER        Lexeme: dmaCb
 type_specifier -> TYPE_NAME
Line: 2942  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2942  Token: IDENTIFIER        Lexeme: pDmaCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2942  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2942  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2942  Token: PTR_OP            Lexeme: ->
Line: 2942  Token: IDENTIFIER        Lexeme: pDmaCb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2942  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pDmaCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2944  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2944  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2944  Token: IDENTIFIER        Lexeme: workingOnDrp
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 2944  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 2944  Token: (  Lexeme: (
Line: 2944  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2944  Token: PTR_OP            Lexeme: ->
Line: 2944  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2944  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 2944  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2944  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2944  Token: ?  Lexeme: ?
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
Line: 2944  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2944  Token: :  Lexeme: :
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2944  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2944  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 conditional_expression -> logical_or_expression '?' expression ':' conditional_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: workingOnDrp added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2945  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2945  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2945  Token: IDENTIFIER        Lexeme: numDsegsInDrpCrp
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 2945  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 2945  Token: (  Lexeme: (
Line: 2945  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2945  Token: PTR_OP            Lexeme: ->
Line: 2945  Token: IDENTIFIER        Lexeme: pDmaCb
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2945  Token: PTR_OP            Lexeme: ->
Line: 2945  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2945  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2945  Token: (  Lexeme: (
Line: 2945  Token: SIZEOF            Lexeme: sizeof
Line: 2945  Token: (  Lexeme: (
Line: 2945  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2945  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 2945  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 2945  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2945  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2945  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2945  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: numDsegsInDrpCrp added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2947  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2947  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2947  Token: IDENTIFIER        Lexeme: totalNumDsds
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 2947  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 2947  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2947  Token: PTR_OP            Lexeme: ->
Line: 2947  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2947  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2947  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2947  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: totalNumDsds added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2948  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2948  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2948  Token: IDENTIFIER        Lexeme: pDsdListPtr
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2948  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pDsdListPtr added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2949  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 2949  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 2949  Token: IDENTIFIER        Lexeme: treg
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 2949  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: treg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 2955  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2955  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2955  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2955  Token: SUB_ASSIGN        Lexeme: -=
 unary_expression -> postfix_expression
 assignment_operator -> SUB_ASSIGN
Line: 2955  Token: IDENTIFIER        Lexeme: numDsegsInDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2955  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2956  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2956  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2956  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2956  Token: ADD_ASSIGN        Lexeme: +=
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 2956  Token: IDENTIFIER        Lexeme: numDsegsInDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2956  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2960  Token: IF                Lexeme: if
Line: 2960  Token: (  Lexeme: (
Line: 2960  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2960  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2960  Token: PTR_OP            Lexeme: ->
Line: 2960  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2960  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2960  Token: {  Lexeme: {
Line: 2964  Token: IDENTIFIER        Lexeme: pDsdListPtr
Line: 2964  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2964  Token: (  Lexeme: (
Line: 2964  Token: (  Lexeme: (
Line: 2964  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 2964  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 2964  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 2964  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2964  Token: PTR_OP            Lexeme: ->
Line: 2964  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2964  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2964  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2964  Token: (  Lexeme: (
Line: 2964  Token: IDENTIFIER        Lexeme: numDsegsInDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2964  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 2964  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2964  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2964  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2969  Token: IF                Lexeme: if
Line: 2969  Token: (  Lexeme: (
Line: 2969  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2969  Token: IDENTIFIER        Lexeme: dsdListPointer
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2969  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2969  Token: {  Lexeme: {
Line: 2970  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2970  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2970  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2970  Token: DEC_OP            Lexeme: --
 postfix_expression -> postfix_expression DEC_OP
Line: 2970  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2971  Token: IDENTIFIER        Lexeme: numDsegsInDrpCrp
Line: 2971  Token: DEC_OP            Lexeme: --
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 postfix_expression -> postfix_expression DEC_OP
Line: 2971  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2972  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2974  Token: IF                Lexeme: if
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2974  Token: (  Lexeme: (
Line: 2974  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 2974  Token: IDENTIFIER        Lexeme: pDsdListPtr
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2974  Token: PTR_OP            Lexeme: ->
Line: 2974  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2974  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2974  Token: {  Lexeme: {
Line: 2978  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 2978  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2978  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2978  Token: AND_ASSIGN        Lexeme: &=
 unary_expression -> postfix_expression
 assignment_operator -> AND_ASSIGN
Line: 2978  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 2978  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2978  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2980  Token: IF                Lexeme: if
Line: 2980  Token: (  Lexeme: (
Line: 2980  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2980  Token: PTR_OP            Lexeme: ->
Line: 2980  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2980  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 2980  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2980  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2980  Token: {  Lexeme: {
Line: 2985  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 2985  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 2985  Token: IDENTIFIER        Lexeme: pCurCrpDrp
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 2985  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 2985  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2985  Token: PTR_OP            Lexeme: ->
Line: 2985  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2985  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pCurCrpDrp added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 2986  Token: WHILE             Lexeme: while
Line: 2986  Token: (  Lexeme: (
Line: 2986  Token: IDENTIFIER        Lexeme: pCurCrpDrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2986  Token: AND_OP            Lexeme: &&
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
Line: 2986  Token: (  Lexeme: (
Line: 2986  Token: IDENTIFIER        Lexeme: pCurCrpDrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2986  Token: PTR_OP            Lexeme: ->
Line: 2986  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2986  Token: NE_OP             Lexeme: !=
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 2986  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2986  Token: PTR_OP            Lexeme: ->
Line: 2986  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2986  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression NE_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 2986  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 2986  Token: {  Lexeme: {
Line: 2987  Token: IDENTIFIER        Lexeme: pCurCrpDrp
Line: 2987  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2987  Token: IDENTIFIER        Lexeme: pCurCrpDrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2987  Token: PTR_OP            Lexeme: ->
Line: 2987  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2987  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 2988  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2989  Token: IDENTIFIER        Lexeme: pCurCrpDrp
Line: 2989  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2989  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2989  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2989  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2989  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2990  Token: IDENTIFIER        Lexeme: enque
Line: 2990  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2990  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2990  Token: PTR_OP            Lexeme: ->
Line: 2990  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2990  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 2990  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 2990  Token: IDENTIFIER        Lexeme: drpCrpFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2990  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 2990  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2996  Token: IDENTIFIER        Lexeme: pCurCrpDrp
Line: 2996  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 2996  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 2996  Token: .  Lexeme: .
Line: 2996  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2996  Token: .  Lexeme: .
Line: 2996  Token: IDENTIFIER        Lexeme: nxt_crp_ptr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2996  Token: .  Lexeme: .
Line: 2996  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 2996  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 2996  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2996  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2997  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 2998  Token: RETURN            Lexeme: return
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2998  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 2998  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 2999  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3003  Token: IDENTIFIER        Lexeme: pDmaCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3003  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3003  Token: IDENTIFIER        Lexeme: adrh
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3003  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3003  Token: IDENTIFIER        Lexeme: pDsdListPtr
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3003  Token: PTR_OP            Lexeme: ->
Line: 3003  Token: IDENTIFIER        Lexeme: addr_hi
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3003  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3004  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3004  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3004  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3004  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3004  Token: IDENTIFIER        Lexeme: pDsdListPtr
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3004  Token: PTR_OP            Lexeme: ->
Line: 3004  Token: IDENTIFIER        Lexeme: addr_lo
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3004  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3005  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3005  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3005  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3005  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3005  Token: IDENTIFIER        Lexeme: pDsdListPtr
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3005  Token: PTR_OP            Lexeme: ->
Line: 3005  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3005  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3006  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3006  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3006  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3006  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3006  Token: IDENTIFIER        Lexeme: pDsdListPtr
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3006  Token: PTR_OP            Lexeme: ->
Line: 3006  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3006  Token: /  Lexeme: /
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 3006  Token: (  Lexeme: (
Line: 3006  Token: SIZEOF            Lexeme: sizeof
Line: 3006  Token: (  Lexeme: (
Line: 3006  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 3006  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3006  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 3006  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3006  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3006  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '/' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3008  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3008  Token: ELSE              Lexeme: else
Line: 3008  Token: {  Lexeme: {
Line: 3012  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3012  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3012  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3012  Token: ADD_ASSIGN        Lexeme: +=
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 3012  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3012  Token: PTR_OP            Lexeme: ->
Line: 3012  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3012  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3013  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3013  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3013  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3013  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3013  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3013  Token: PTR_OP            Lexeme: ->
Line: 3013  Token: IDENTIFIER        Lexeme: dsdCount
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3013  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 3013  Token: SIZEOF            Lexeme: sizeof
Line: 3013  Token: (  Lexeme: (
Line: 3013  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 3013  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3013  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 3013  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3013  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3014  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3018  Token: IF                Lexeme: if
Line: 3018  Token: (  Lexeme: (
Line: 3018  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3018  Token: PTR_OP            Lexeme: ->
Line: 3018  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3018  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 3018  Token: (  Lexeme: (
Line: 3018  Token: SIZEOF            Lexeme: sizeof
Line: 3018  Token: (  Lexeme: (
Line: 3018  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 3018  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3018  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 3018  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3018  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3018  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3018  Token: {  Lexeme: {
Line: 3022  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3022  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3022  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3022  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3022  Token: IDENTIFIER        Lexeme: dmalloc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3022  Token: (  Lexeme: (
Line: 3022  Token: SIZEOF            Lexeme: sizeof
Line: 3022  Token: (  Lexeme: (
Line: 3022  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 3022  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3022  Token: COMPLEX           Lexeme: )
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3022  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3023  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3023  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3023  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3023  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3023  Token: IDENTIFIER        Lexeme: HQP_STATE_WAIT_FOR_DSD_LPTR_DMA
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3023  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3030  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3030  Token: ELSE              Lexeme: else
Line: 3030  Token: IF                Lexeme: if
Line: 3030  Token: (  Lexeme: (
Line: 3030  Token: IDENTIFIER        Lexeme: workingOnDrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3030  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3030  Token: {  Lexeme: {
Line: 3034  Token: IF                Lexeme: if
Line: 3034  Token: (  Lexeme: (
Line: 3034  Token: IDENTIFIER        Lexeme: numDsegsInDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3034  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 3034  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3034  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3034  Token: {  Lexeme: {
Line: 3035  Token: IDENTIFIER        Lexeme: workingOnDrp
Line: 3035  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3035  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3035  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3036  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3036  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3036  Token: IDENTIFIER        Lexeme: flags
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3036  Token: AND_ASSIGN        Lexeme: &=
 unary_expression -> postfix_expression
 assignment_operator -> AND_ASSIGN
Line: 3036  Token: ~  Lexeme: ~
 unary_operator -> '~'
Line: 3036  Token: CONSTANT          Lexeme: 0x0002
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3036  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3041  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3041  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3041  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3041  Token: PTR_OP            Lexeme: ->
Line: 3041  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3041  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3041  Token: IDENTIFIER        Lexeme: allocDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3041  Token: (  Lexeme: (
Line: 3041  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3041  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3041  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3049  Token: IF                Lexeme: if
Line: 3049  Token: (  Lexeme: (
Line: 3049  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 3049  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3049  Token: PTR_OP            Lexeme: ->
Line: 3049  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3049  Token: PTR_OP            Lexeme: ->
Line: 3049  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3049  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3049  Token: {  Lexeme: {
Line: 3051  Token: RETURN            Lexeme: return
Line: 3051  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3051  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3052  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3056  Token: IDENTIFIER        Lexeme: pHqpCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3056  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3056  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3056  Token: PTR_OP            Lexeme: ->
Line: 3056  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3056  Token: .  Lexeme: .
Line: 3056  Token: IDENTIFIER        Lexeme: drp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3056  Token: .  Lexeme: .
Line: 3056  Token: IDENTIFIER        Lexeme: nxt_crp_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3056  Token: .  Lexeme: .
Line: 3056  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3056  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3056  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3056  Token: PTR_OP            Lexeme: ->
Line: 3056  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3056  Token: PTR_OP            Lexeme: ->
Line: 3056  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3056  Token: PTR_OP            Lexeme: ->
Line: 3056  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3056  Token: .  Lexeme: .
Line: 3056  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3056  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 3056  Token: CONSTANT          Lexeme: 0x80000000
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3056  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3060  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3060  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3060  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3060  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3060  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3060  Token: PTR_OP            Lexeme: ->
Line: 3060  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3060  Token: PTR_OP            Lexeme: ->
Line: 3060  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3060  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3061  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3061  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3061  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3061  Token: PTR_OP            Lexeme: ->
Line: 3061  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3061  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3061  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3061  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3062  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3062  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3062  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3062  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3062  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3062  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3067  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3067  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3067  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3067  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3067  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3067  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3067  Token: PTR_OP            Lexeme: ->
Line: 3067  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3067  Token: PTR_OP            Lexeme: ->
Line: 3067  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3067  Token: .  Lexeme: .
Line: 3067  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3067  Token: .  Lexeme: .
Line: 3067  Token: IDENTIFIER        Lexeme: dsd_list_0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3067  Token: [  Lexeme: [
Line: 3067  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3067  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3067  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3071  Token: IF                Lexeme: if
Line: 3071  Token: (  Lexeme: (
Line: 3071  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3071  Token: PTR_OP            Lexeme: ->
Line: 3071  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3071  Token: >  Lexeme: >
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 3071  Token: (  Lexeme: (
Line: 3071  Token: (  Lexeme: (
Line: 3071  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3071  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3071  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3071  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3071  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 3071  Token: SIZEOF            Lexeme: sizeof
Line: 3071  Token: (  Lexeme: (
Line: 3071  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 3071  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3071  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 3071  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3071  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3071  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '>' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3071  Token: {  Lexeme: {
Line: 3072  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3072  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3072  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3072  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3072  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3072  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 3072  Token: SIZEOF            Lexeme: sizeof
Line: 3072  Token: (  Lexeme: (
Line: 3072  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 3072  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3072  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 3072  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3072  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3073  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3075  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3075  Token: ELSE              Lexeme: else
Line: 3075  Token: {  Lexeme: {
Line: 3079  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3079  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3079  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3079  Token: ADD_ASSIGN        Lexeme: +=
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 3079  Token: (  Lexeme: (
Line: 3079  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3079  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3079  Token: IDENTIFIER        Lexeme: numDsegsInDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3079  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3079  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3080  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3080  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3080  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3080  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3080  Token: (  Lexeme: (
Line: 3080  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3080  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3080  Token: IDENTIFIER        Lexeme: numDsegsInDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3080  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3080  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 3080  Token: SIZEOF            Lexeme: sizeof
Line: 3080  Token: (  Lexeme: (
Line: 3080  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 3080  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3080  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 3080  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3080  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3081  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3086  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3086  Token: ELSE              Lexeme: else
Line: 3086  Token: {  Lexeme: {
Line: 3091  Token: IF                Lexeme: if
Line: 3091  Token: (  Lexeme: (
Line: 3091  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3091  Token: PTR_OP            Lexeme: ->
Line: 3091  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3091  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 3091  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3091  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3091  Token: {  Lexeme: {
Line: 3095  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3095  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3095  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3095  Token: PTR_OP            Lexeme: ->
Line: 3095  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3095  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3095  Token: IDENTIFIER        Lexeme: allocDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3095  Token: (  Lexeme: (
Line: 3095  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3095  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3095  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3103  Token: IF                Lexeme: if
Line: 3103  Token: (  Lexeme: (
Line: 3103  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 3103  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3103  Token: PTR_OP            Lexeme: ->
Line: 3103  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3103  Token: PTR_OP            Lexeme: ->
Line: 3103  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3103  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3103  Token: {  Lexeme: {
Line: 3106  Token: RETURN            Lexeme: return
Line: 3106  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3106  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3107  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3112  Token: IDENTIFIER        Lexeme: pHqpCb
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3112  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3112  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3112  Token: PTR_OP            Lexeme: ->
Line: 3112  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3112  Token: .  Lexeme: .
Line: 3112  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3112  Token: .  Lexeme: .
Line: 3112  Token: IDENTIFIER        Lexeme: nxt_crp_ptr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3112  Token: .  Lexeme: .
Line: 3112  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3112  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3112  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3112  Token: PTR_OP            Lexeme: ->
Line: 3112  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3112  Token: PTR_OP            Lexeme: ->
Line: 3112  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3112  Token: PTR_OP            Lexeme: ->
Line: 3112  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3112  Token: .  Lexeme: .
Line: 3112  Token: IDENTIFIER        Lexeme: full_adr
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3112  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 3112  Token: CONSTANT          Lexeme: 0x80000000
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3112  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3117  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3117  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3117  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3117  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3117  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3117  Token: PTR_OP            Lexeme: ->
Line: 3117  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3117  Token: PTR_OP            Lexeme: ->
Line: 3117  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3117  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3118  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3118  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3118  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3118  Token: PTR_OP            Lexeme: ->
Line: 3118  Token: IDENTIFIER        Lexeme: next
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3118  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3118  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3118  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3119  Token: IDENTIFIER        Lexeme: pHqpCb
Line: 3119  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3119  Token: IDENTIFIER        Lexeme: dsdIndxInDrpCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3119  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3119  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3119  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3123  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3123  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3123  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3123  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3123  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3123  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3123  Token: PTR_OP            Lexeme: ->
Line: 3123  Token: IDENTIFIER        Lexeme: pCrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3123  Token: PTR_OP            Lexeme: ->
Line: 3123  Token: IDENTIFIER        Lexeme: lbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3123  Token: .  Lexeme: .
Line: 3123  Token: IDENTIFIER        Lexeme: crp
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3123  Token: .  Lexeme: .
Line: 3123  Token: IDENTIFIER        Lexeme: dsd_list_0
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3123  Token: [  Lexeme: [
Line: 3123  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3123  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3123  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3127  Token: IF                Lexeme: if
Line: 3127  Token: (  Lexeme: (
Line: 3127  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3127  Token: PTR_OP            Lexeme: ->
Line: 3127  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3127  Token: >  Lexeme: >
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 3127  Token: (  Lexeme: (
Line: 3127  Token: (  Lexeme: (
Line: 3127  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3127  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3127  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3127  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3127  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 3127  Token: SIZEOF            Lexeme: sizeof
Line: 3127  Token: (  Lexeme: (
Line: 3127  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 3127  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3127  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 3127  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3127  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3127  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '>' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3127  Token: {  Lexeme: {
Line: 3128  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3128  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3128  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3128  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3128  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3128  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 3128  Token: SIZEOF            Lexeme: sizeof
Line: 3128  Token: (  Lexeme: (
Line: 3128  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 3128  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3128  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 3128  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3128  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3129  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3130  Token: }  Lexeme: }
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3130  Token: ELSE              Lexeme: else
Line: 3130  Token: {  Lexeme: {
Line: 3134  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3134  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3134  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3134  Token: ADD_ASSIGN        Lexeme: +=
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 3134  Token: (  Lexeme: (
Line: 3134  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3134  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3134  Token: IDENTIFIER        Lexeme: numDsegsInDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3134  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3134  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3135  Token: IDENTIFIER        Lexeme: pDmaCb
Line: 3135  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3135  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3135  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3135  Token: (  Lexeme: (
Line: 3135  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3135  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3135  Token: IDENTIFIER        Lexeme: numDsegsInDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3135  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3135  Token: *  Lexeme: *
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
Line: 3135  Token: SIZEOF            Lexeme: sizeof
Line: 3135  Token: (  Lexeme: (
Line: 3135  Token: IDENTIFIER        Lexeme: dseg_struct
 type_specifier -> TYPE_NAME
Line: 3135  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3135  Token: *  Lexeme: *
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
Line: 3135  Token: CONSTANT          Lexeme: 4
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3135  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> multiplicative_expression '*' cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3136  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3137  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3139  Token: IF                Lexeme: if
Line: 3139  Token: (  Lexeme: (
Line: 3139  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 3139  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3139  Token: (  Lexeme: (
Line: 3139  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3139  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3139  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3139  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3139  Token: {  Lexeme: {
Line: 3140  Token: IDENTIFIER        Lexeme: enque
Line: 3140  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3140  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3140  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 3140  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3140  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3140  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3140  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3141  Token: RETURN            Lexeme: return
Line: 3141  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3141  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3142  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3144  Token: IDENTIFIER        Lexeme: treg
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3144  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3144  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3144  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3144  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3144  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3144  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3144  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3144  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3144  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3144  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3144  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3144  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3144  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3144  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: (  Lexeme: (
Line: 3144  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3144  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3144  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3144  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3144  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3144  Token: PTR_OP            Lexeme: ->
Line: 3144  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3144  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3144  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3144  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3144  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3144  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3144  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3146  Token: WHILE             Lexeme: while
Line: 3146  Token: (  Lexeme: (
Line: 3146  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 3146  Token: (  Lexeme: (
Line: 3146  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3146  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 3146  Token: (  Lexeme: (
Line: 3146  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3146  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 3146  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3146  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3146  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3146  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3146  Token: {  Lexeme: {
Line: 3147  Token: IDENTIFIER        Lexeme: treg
Line: 3147  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3147  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3147  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3147  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3147  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3147  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3147  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3147  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3147  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3147  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3147  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3147  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3147  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3147  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: (  Lexeme: (
Line: 3147  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3147  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3147  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3147  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3147  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3147  Token: PTR_OP            Lexeme: ->
Line: 3147  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3147  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3147  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3147  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3147  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3147  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3147  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3148  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3150  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3150  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3150  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3150  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3150  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3150  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3150  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3150  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3150  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3150  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3150  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3150  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3150  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3150  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3150  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3150  Token: PTR_OP            Lexeme: ->
Line: 3150  Token: IDENTIFIER        Lexeme: hostDmaSpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3150  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3150  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3150  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3150  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3150  Token: PTR_OP            Lexeme: ->
Line: 3150  Token: IDENTIFIER        Lexeme: spBufAdr
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3150  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 3150  Token: (  Lexeme: (
Line: 3150  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3150  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3150  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3151  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3151  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3151  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3151  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3151  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3151  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3151  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3151  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3151  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3151  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3151  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3151  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3151  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: (  Lexeme: (
Line: 3151  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3151  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3151  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3151  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3151  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3151  Token: PTR_OP            Lexeme: ->
Line: 3151  Token: IDENTIFIER        Lexeme: hostDmaAdrlReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3151  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3151  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3151  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3151  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3151  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3151  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3151  Token: PTR_OP            Lexeme: ->
Line: 3151  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3151  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3151  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3152  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3152  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3152  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3152  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3152  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3152  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3152  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3152  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3152  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3152  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3152  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3152  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3152  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: (  Lexeme: (
Line: 3152  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3152  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3152  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3152  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3152  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3152  Token: PTR_OP            Lexeme: ->
Line: 3152  Token: IDENTIFIER        Lexeme: hostDmaAdrhReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3152  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3152  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3152  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3152  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3152  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3152  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3152  Token: PTR_OP            Lexeme: ->
Line: 3152  Token: IDENTIFIER        Lexeme: adrl
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3152  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3152  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3153  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3153  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3153  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3153  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3153  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3153  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3153  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3153  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3153  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3153  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3153  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3153  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3153  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: (  Lexeme: (
Line: 3153  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3153  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3153  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3153  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3153  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3153  Token: PTR_OP            Lexeme: ->
Line: 3153  Token: IDENTIFIER        Lexeme: hostDmaHqpIdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3153  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3153  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3153  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3153  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3153  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3153  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3153  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3153  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3154  Token: IDENTIFIER        Lexeme: treg
Line: 3154  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3154  Token: (  Lexeme: (
Line: 3154  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3154  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 3154  Token: CONSTANT          Lexeme: 14
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3154  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3154  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3154  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3154  Token: PTR_OP            Lexeme: ->
Line: 3154  Token: IDENTIFIER        Lexeme: length
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3154  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3156  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3156  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3156  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3156  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3156  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3156  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3156  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3156  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3156  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3156  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3156  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3156  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3156  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: (  Lexeme: (
Line: 3156  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3156  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3156  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3156  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3156  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3156  Token: PTR_OP            Lexeme: ->
Line: 3156  Token: IDENTIFIER        Lexeme: hostDmaCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3156  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3156  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3156  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3156  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3156  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3156  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3156  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3156  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3157  Token: IDENTIFIER        Lexeme: enque
Line: 3157  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3157  Token: IDENTIFIER        Lexeme: pDmaCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3157  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 3157  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3157  Token: IDENTIFIER        Lexeme: hostDma
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3157  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3157  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3160  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3160  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3160  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3160  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3160  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 3160  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3160  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3161  Token: IDENTIFIER        Lexeme: hostDmaHdwSim
Line: 3161  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3161  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 3161  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3162  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3162  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3162  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3162  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3162  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3165  Token: RETURN            Lexeme: return
Line: 3165  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3165  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3166  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 function_definition -> declaration_specifiers declarator compound_statement
 external_declaration -> function_definition
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 3168  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 3168  Token: IDENTIFIER        Lexeme: ReleaseHqpResources
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 3168  Token: (  Lexeme: (
Line: 3168  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 3168  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 3168  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 3168  Token: {  Lexeme: {
 declarator -> direct_declarator
Line: 3170  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 3170  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 3170  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 3170  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 3170  Token: IDENTIFIER        Lexeme: HqpLookup
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3170  Token: [  Lexeme: [
Line: 3170  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3170  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3170  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 3171  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3171  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3171  Token: IDENTIFIER        Lexeme: treg
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 3171  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: treg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 3173  Token: IF                Lexeme: if
Line: 3173  Token: (  Lexeme: (
Line: 3173  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3173  Token: PTR_OP            Lexeme: ->
Line: 3173  Token: IDENTIFIER        Lexeme: pBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3173  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3173  Token: {  Lexeme: {
Line: 3174  Token: IDENTIFIER        Lexeme: dfree
Line: 3174  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3174  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3174  Token: PTR_OP            Lexeme: ->
Line: 3174  Token: IDENTIFIER        Lexeme: pBuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3174  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3174  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3175  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3181  Token: IDENTIFIER        Lexeme: enqueFpFifo
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3181  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3181  Token: (  Lexeme: (
Line: 3181  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3181  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3181  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3181  Token: (  Lexeme: (
Line: 3181  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3181  Token: PTR_OP            Lexeme: ->
Line: 3181  Token: IDENTIFIER        Lexeme: pDrp
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3181  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3181  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3181  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3183  Token: IDENTIFIER        Lexeme: enque
Line: 3183  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3183  Token: IDENTIFIER        Lexeme: pHqpCb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3183  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 3183  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3183  Token: IDENTIFIER        Lexeme: hqpCbFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3183  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3183  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3184  Token: IDENTIFIER        Lexeme: HqpLookup
Line: 3184  Token: [  Lexeme: [
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3184  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3184  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3184  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3184  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3184  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3185  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 function_definition -> declaration_specifiers declarator compound_statement
 external_declaration -> function_definition
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 3187  Token: VOID              Lexeme: void
 type_specifier -> VOID
Line: 3187  Token: IDENTIFIER        Lexeme: getHqpContext
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 3187  Token: (  Lexeme: (
Line: 3187  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 3187  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 3187  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 3187  Token: {  Lexeme: {
 declarator -> direct_declarator
Line: 3189  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3189  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3189  Token: IDENTIFIER        Lexeme: treg
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 3189  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: treg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 3190  Token: IDENTIFIER        Lexeme: hqmHqpCntxt
 type_specifier -> TYPE_NAME
Line: 3190  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 3190  Token: IDENTIFIER        Lexeme: pBuf
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 3190  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pBuf added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 3191  Token: IDENTIFIER        Lexeme: hqpCntxtEntry
 type_specifier -> TYPE_NAME
Line: 3191  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 3191  Token: IDENTIFIER        Lexeme: pHqpCntxtEntry
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 3191  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 3191  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3191  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3191  Token: [  Lexeme: [
Line: 3191  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3191  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3191  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pHqpCntxtEntry added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 3197  Token: IDENTIFIER        Lexeme: treg
Line: 3197  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3197  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3197  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3197  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3197  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3197  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3197  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3197  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3197  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3197  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3197  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3197  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3197  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3197  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: (  Lexeme: (
Line: 3197  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3197  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3197  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3197  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3197  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3197  Token: PTR_OP            Lexeme: ->
Line: 3197  Token: IDENTIFIER        Lexeme: hqpCntxtCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3197  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3197  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3197  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3197  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3197  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3197  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3199  Token: WHILE             Lexeme: while
Line: 3199  Token: (  Lexeme: (
Line: 3199  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 3199  Token: (  Lexeme: (
Line: 3199  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3199  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 3199  Token: (  Lexeme: (
Line: 3199  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3199  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 3199  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3199  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3199  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3199  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3199  Token: {  Lexeme: {
Line: 3200  Token: IDENTIFIER        Lexeme: treg
Line: 3200  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3200  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3200  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3200  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3200  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3200  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3200  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3200  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3200  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3200  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3200  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3200  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3200  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3200  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: (  Lexeme: (
Line: 3200  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3200  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3200  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3200  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3200  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3200  Token: PTR_OP            Lexeme: ->
Line: 3200  Token: IDENTIFIER        Lexeme: hqpCntxtCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3200  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3200  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3200  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3200  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3200  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3200  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3201  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3205  Token: IDENTIFIER        Lexeme: pBuf
Line: 3205  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3205  Token: (  Lexeme: (
Line: 3205  Token: IDENTIFIER        Lexeme: hqmHqpCntxt
 type_specifier -> TYPE_NAME
Line: 3205  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3205  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3205  Token: IDENTIFIER        Lexeme: dmalloc
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3205  Token: (  Lexeme: (
Line: 3205  Token: SIZEOF            Lexeme: sizeof
Line: 3205  Token: (  Lexeme: (
Line: 3205  Token: IDENTIFIER        Lexeme: hqmHqpCntxt
 type_specifier -> TYPE_NAME
Line: 3205  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3205  Token: COMPLEX           Lexeme: )
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3205  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3207  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3207  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3207  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3207  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3207  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3207  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3207  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3207  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3207  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3207  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3207  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3207  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3207  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3207  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: PTR_OP            Lexeme: ->
Line: 3207  Token: IDENTIFIER        Lexeme: hqpCntxtSpAdrReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3207  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3207  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3207  Token: IDENTIFIER        Lexeme: pBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 3207  Token: (  Lexeme: (
Line: 3207  Token: CONSTANT          Lexeme: 0x00007FFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3207  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3208  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3208  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3208  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3208  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3208  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3208  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3208  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3208  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3208  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3208  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3208  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3208  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3208  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: (  Lexeme: (
Line: 3208  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3208  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3208  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3208  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3208  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3208  Token: PTR_OP            Lexeme: ->
Line: 3208  Token: IDENTIFIER        Lexeme: hqpCntxtCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3208  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3208  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3208  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3208  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3208  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3208  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3208  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3208  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3211  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3211  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3211  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3211  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3211  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 3211  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3211  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3212  Token: IDENTIFIER        Lexeme: hqpContextDmaHdwSim
Line: 3212  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3212  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 3212  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3212  Token: ;  Lexeme: ;
 expression_statement -> ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3213  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3213  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3213  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3213  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3213  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3216  Token: IDENTIFIER        Lexeme: treg
Line: 3216  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3216  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3216  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3216  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3216  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3216  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3216  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3216  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3216  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3216  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3216  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3216  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3216  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3216  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: (  Lexeme: (
Line: 3216  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3216  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3216  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3216  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3216  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3216  Token: PTR_OP            Lexeme: ->
Line: 3216  Token: IDENTIFIER        Lexeme: hqpCntxtCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3216  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3216  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3216  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3216  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3216  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3216  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3218  Token: WHILE             Lexeme: while
Line: 3218  Token: (  Lexeme: (
Line: 3218  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 3218  Token: (  Lexeme: (
Line: 3218  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3218  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 3218  Token: (  Lexeme: (
Line: 3218  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3218  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 3218  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3218  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3218  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3218  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3218  Token: {  Lexeme: {
Line: 3219  Token: IDENTIFIER        Lexeme: treg
Line: 3219  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3219  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3219  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3219  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3219  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3219  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3219  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3219  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3219  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3219  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3219  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3219  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3219  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3219  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: (  Lexeme: (
Line: 3219  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3219  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3219  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3219  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3219  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3219  Token: PTR_OP            Lexeme: ->
Line: 3219  Token: IDENTIFIER        Lexeme: hqpCntxtCmdReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3219  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3219  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3219  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3219  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3219  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3219  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3220  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3225  Token: IDENTIFIER        Lexeme: pHqpCntxtEntry
Line: 3225  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3225  Token: IDENTIFIER        Lexeme: vpid
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3225  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3225  Token: IDENTIFIER        Lexeme: pBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3225  Token: PTR_OP            Lexeme: ->
Line: 3225  Token: IDENTIFIER        Lexeme: vpid
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3225  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3226  Token: IDENTIFIER        Lexeme: pHqpCntxtEntry
Line: 3226  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3226  Token: IDENTIFIER        Lexeme: port
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3226  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3226  Token: IDENTIFIER        Lexeme: pBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3226  Token: PTR_OP            Lexeme: ->
Line: 3226  Token: IDENTIFIER        Lexeme: port
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3226  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3227  Token: IDENTIFIER        Lexeme: pHqpCntxtEntry
Line: 3227  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3227  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3227  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3227  Token: IDENTIFIER        Lexeme: pBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3227  Token: PTR_OP            Lexeme: ->
Line: 3227  Token: IDENTIFIER        Lexeme: type
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3227  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3228  Token: IDENTIFIER        Lexeme: pHqpCntxtEntry
Line: 3228  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3228  Token: IDENTIFIER        Lexeme: iocbRegion
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3228  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3228  Token: IDENTIFIER        Lexeme: pBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3228  Token: PTR_OP            Lexeme: ->
Line: 3228  Token: IDENTIFIER        Lexeme: iocbRegion
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3228  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3229  Token: IDENTIFIER        Lexeme: pHqpCntxtEntry
Line: 3229  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3229  Token: IDENTIFIER        Lexeme: mqsL1q
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3229  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3229  Token: IDENTIFIER        Lexeme: pBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3229  Token: PTR_OP            Lexeme: ->
Line: 3229  Token: IDENTIFIER        Lexeme: mqsL1Que
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3229  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3230  Token: IDENTIFIER        Lexeme: pHqpCntxtEntry
Line: 3230  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3230  Token: IDENTIFIER        Lexeme: cntxtSize
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3230  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3230  Token: IDENTIFIER        Lexeme: pBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3230  Token: PTR_OP            Lexeme: ->
Line: 3230  Token: IDENTIFIER        Lexeme: cntxtSize
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3230  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3231  Token: IDENTIFIER        Lexeme: pHqpCntxtEntry
Line: 3231  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3231  Token: IDENTIFIER        Lexeme: cntxtRegion
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3231  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3231  Token: IDENTIFIER        Lexeme: pBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3231  Token: PTR_OP            Lexeme: ->
Line: 3231  Token: IDENTIFIER        Lexeme: cntxtRegion
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3231  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3232  Token: IF                Lexeme: if
Line: 3232  Token: (  Lexeme: (
Line: 3232  Token: IDENTIFIER        Lexeme: pBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3232  Token: PTR_OP            Lexeme: ->
Line: 3232  Token: IDENTIFIER        Lexeme: state
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3232  Token: EQ_OP             Lexeme: ==
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
Line: 3232  Token: CONSTANT          Lexeme: 0x8
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3232  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> equality_expression EQ_OP relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3232  Token: {  Lexeme: {
Line: 3233  Token: IDENTIFIER        Lexeme: pHqpCntxtEntry
Line: 3233  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3233  Token: IDENTIFIER        Lexeme: valid
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3233  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3233  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3233  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3234  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3234  Token: ELSE              Lexeme: else
Line: 3234  Token: {  Lexeme: {
Line: 3235  Token: IDENTIFIER        Lexeme: pHqpCntxtEntry
Line: 3235  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3235  Token: IDENTIFIER        Lexeme: valid
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3235  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3235  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3235  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3236  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3243  Token: IDENTIFIER        Lexeme: dfree
Line: 3243  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3243  Token: IDENTIFIER        Lexeme: pBuf
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3243  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3243  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3244  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 function_definition -> declaration_specifiers declarator compound_statement
 external_declaration -> function_definition
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 3246  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 3246  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 3246  Token: IDENTIFIER        Lexeme: allocDrpCrp
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 3246  Token: (  Lexeme: (
Line: 3246  Token: INT               Lexeme: int
 type_specifier -> INT
Line: 3246  Token: IDENTIFIER        Lexeme: hqpId
 declaration_specifiers -> type_specifier
 direct_declarator -> IDENTIFIER
Line: 3246  Token: COMPLEX           Lexeme: )
 declarator -> direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 3246  Token: {  Lexeme: {
 declarator -> pointer direct_declarator
Line: 3248  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3248  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3248  Token: IDENTIFIER        Lexeme: treg
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 3248  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: treg added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 3249  Token: IDENTIFIER        Lexeme: hqpCb
 type_specifier -> TYPE_NAME
Line: 3249  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 3249  Token: IDENTIFIER        Lexeme: pHqpCb
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 3249  Token: =  Lexeme: =
 declarator -> pointer direct_declarator
Line: 3249  Token: IDENTIFIER        Lexeme: HqpLookup
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3249  Token: [  Lexeme: [
Line: 3249  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3249  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3249  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: pHqpCb added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 3250  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 3250  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 3250  Token: IDENTIFIER        Lexeme: pDrpCrp
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 3250  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pDrpCrp added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 3252  Token: IF                Lexeme: if
Line: 3252  Token: (  Lexeme: (
Line: 3252  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 3252  Token: IDENTIFIER        Lexeme: queIsEmpty
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3252  Token: (  Lexeme: (
Line: 3252  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3252  Token: IDENTIFIER        Lexeme: drpCrpFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3252  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3252  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3252  Token: {  Lexeme: {
Line: 3253  Token: IDENTIFIER        Lexeme: pDrpCrp
Line: 3253  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3253  Token: (  Lexeme: (
Line: 3253  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 3253  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3253  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3253  Token: IDENTIFIER        Lexeme: deque
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3253  Token: (  Lexeme: (
Line: 3253  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3253  Token: IDENTIFIER        Lexeme: drpCrpFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3253  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3253  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3255  Token: IDENTIFIER        Lexeme: memclrMim0
Line: 3255  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3255  Token: IDENTIFIER        Lexeme: pDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3255  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 3255  Token: SIZEOF            Lexeme: sizeof
Line: 3255  Token: (  Lexeme: (
Line: 3255  Token: IDENTIFIER        Lexeme: bufDesc
 type_specifier -> TYPE_NAME
Line: 3255  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 type_name -> specifier_qualifier_list
Line: 3255  Token: COMPLEX           Lexeme: )
 unary_expression -> SIZEOF '(' type_name ')'
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3255  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3260  Token: IDENTIFIER        Lexeme: treg
Line: 3260  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3260  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3260  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3260  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3260  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3260  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3260  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3260  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3260  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3260  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3260  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3260  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3260  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3260  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: (  Lexeme: (
Line: 3260  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3260  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3260  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3260  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3260  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3260  Token: PTR_OP            Lexeme: ->
Line: 3260  Token: IDENTIFIER        Lexeme: mimBlkRqReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3260  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3260  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3260  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3260  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3260  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3260  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3262  Token: WHILE             Lexeme: while
Line: 3262  Token: (  Lexeme: (
Line: 3262  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 3262  Token: (  Lexeme: (
Line: 3262  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3262  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 3262  Token: (  Lexeme: (
Line: 3262  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3262  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 3262  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3262  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3262  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3262  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3262  Token: {  Lexeme: {
Line: 3263  Token: IDENTIFIER        Lexeme: treg
Line: 3263  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3263  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3263  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3263  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3263  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3263  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3263  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3263  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3263  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3263  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3263  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3263  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3263  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3263  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: (  Lexeme: (
Line: 3263  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3263  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3263  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3263  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3263  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3263  Token: PTR_OP            Lexeme: ->
Line: 3263  Token: IDENTIFIER        Lexeme: mimBlkRqReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3263  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3263  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3263  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3263  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3263  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3263  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3264  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3269  Token: IDENTIFIER        Lexeme: treg
Line: 3269  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3269  Token: (  Lexeme: (
Line: 3269  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3269  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 3269  Token: CONSTANT          Lexeme: 27
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3269  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3269  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3269  Token: (  Lexeme: (
Line: 3269  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3269  Token: [  Lexeme: [
Line: 3269  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3269  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3269  Token: .  Lexeme: .
Line: 3269  Token: IDENTIFIER        Lexeme: iocbRegion
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3269  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 3269  Token: CONSTANT          Lexeme: 20
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3269  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3269  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3270  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3270  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3270  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3270  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3270  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3270  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3270  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3270  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3270  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3270  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3270  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3270  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3270  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: (  Lexeme: (
Line: 3270  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3270  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3270  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3270  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3270  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3270  Token: PTR_OP            Lexeme: ->
Line: 3270  Token: IDENTIFIER        Lexeme: mimBlkRqReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3270  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3270  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3270  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3270  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3270  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3270  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3270  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3270  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3273  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3273  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3273  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3273  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3273  Token: |  Lexeme: |
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
Line: 3273  Token: CONSTANT          Lexeme: 0x0008
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3273  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> inclusive_or_expression '|' exclusive_or_expressionn
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3274  Token: IDENTIFIER        Lexeme: mlmHdwSim
Line: 3274  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3274  Token: COMPLEX           Lexeme: )
 postfix_expression -> postfix_expression '(' ')'
Line: 3274  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3275  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3275  Token: IDENTIFIER        Lexeme: rMb
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3275  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 assignment_operator -> '='
Line: 3275  Token: IDENTIFIER        Lexeme: shdMb0
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3275  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3277  Token: IDENTIFIER        Lexeme: treg
Line: 3277  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3277  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3277  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3277  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3277  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3277  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3277  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3277  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3277  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3277  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3277  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3277  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3277  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3277  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: (  Lexeme: (
Line: 3277  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3277  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3277  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3277  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3277  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3277  Token: PTR_OP            Lexeme: ->
Line: 3277  Token: IDENTIFIER        Lexeme: mimBlkRqReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3277  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3277  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3277  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3277  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3277  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3277  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3278  Token: WHILE             Lexeme: while
Line: 3278  Token: (  Lexeme: (
Line: 3278  Token: !  Lexeme: !
 unary_operator -> '!'
Line: 3278  Token: (  Lexeme: (
Line: 3278  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3278  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 3278  Token: (  Lexeme: (
Line: 3278  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3278  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 3278  Token: CONSTANT          Lexeme: 31
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3278  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3278  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3278  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3278  Token: {  Lexeme: {
Line: 3279  Token: IDENTIFIER        Lexeme: treg
Line: 3279  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: VOLATILE          Lexeme: volatile
 type_qualifier -> VOLATILE
Line: 3279  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3279  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3279  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 specifier_qualifier_list -> type_qualifier specifier_qualifier_list
Line: 3279  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3279  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3279  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3279  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3279  Token: IDENTIFIER        Lexeme: spRegs
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3279  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3279  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3279  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3279  Token: COMPLEX           Lexeme: )
 specifier_qualifier_list -> type_specifier
 specifier_qualifier_list -> type_specifier specifier_qualifier_list
 type_name -> specifier_qualifier_list
Line: 3279  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: (  Lexeme: (
Line: 3279  Token: IDENTIFIER        Lexeme: sp_regs
 type_specifier -> TYPE_NAME
Line: 3279  Token: *  Lexeme: *
 specifier_qualifier_list -> type_specifier
Line: 3279  Token: COMPLEX           Lexeme: )
 pointer -> '*'
 abstract_declarator -> pointer
 type_name -> specifier_qualifier_list abstract_declarator
Line: 3279  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3279  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3279  Token: PTR_OP            Lexeme: ->
Line: 3279  Token: IDENTIFIER        Lexeme: mimBlkRqReg
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3279  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3279  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3279  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3279  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 cast_expression -> '(' type_name ')' cast_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3279  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3279  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3280  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3281  Token: IF                Lexeme: if
Line: 3281  Token: (  Lexeme: (
Line: 3281  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3281  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 3281  Token: (  Lexeme: (
Line: 3281  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3281  Token: LEFT_OP           Lexeme: <<
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
Line: 3281  Token: CONSTANT          Lexeme: 30
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3281  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> shift_expression LEFT_OP additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3281  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3281  Token: {  Lexeme: {
Line: 3282  Token: IDENTIFIER        Lexeme: enque
Line: 3282  Token: (  Lexeme: (
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3282  Token: IDENTIFIER        Lexeme: pDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3282  Token: ,  Lexeme: ,
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> assignment_expression
Line: 3282  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3282  Token: IDENTIFIER        Lexeme: drpCrpFreePool
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3282  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 argument_expression_list -> argument_expression_list ',' assignment_expression
 postfix_expression -> postfix_expression '(' argument_expression_list ')'
Line: 3282  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3283  Token: RETURN            Lexeme: return
Line: 3283  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3283  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3284  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3288  Token: IDENTIFIER        Lexeme: pDrpCrp
 selection_statement -> IF '(' expression ')' statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3288  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3288  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3288  Token: .  Lexeme: .
Line: 3288  Token: IDENTIFIER        Lexeme: blk_id
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3288  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3288  Token: IDENTIFIER        Lexeme: treg
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3288  Token: &  Lexeme: &
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
Line: 3288  Token: (  Lexeme: (
Line: 3288  Token: CONSTANT          Lexeme: 0x7FF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3288  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3288  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> and_expression '&' equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3289  Token: IDENTIFIER        Lexeme: pDrpCrp
Line: 3289  Token: PTR_OP            Lexeme: ->
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3289  Token: IDENTIFIER        Lexeme: mbuf
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3289  Token: .  Lexeme: .
Line: 3289  Token: IDENTIFIER        Lexeme: mem_rgn
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3289  Token: =  Lexeme: =
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3289  Token: IDENTIFIER        Lexeme: hqpCntxt
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3289  Token: [  Lexeme: [
Line: 3289  Token: IDENTIFIER        Lexeme: hqpId
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3289  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3289  Token: .  Lexeme: .
Line: 3289  Token: IDENTIFIER        Lexeme: iocbRegion
 postfix_expression -> postfix_expression '.' IDENTIFIER
Line: 3289  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3290  Token: RETURN            Lexeme: return
Line: 3290  Token: IDENTIFIER        Lexeme: pDrpCrp
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3290  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3295  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3295  Token: ELSE              Lexeme: else
Line: 3295  Token: {  Lexeme: {
Line: 3296  Token: RETURN            Lexeme: return
Line: 3296  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3296  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3297  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3298  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 function_definition -> declaration_specifiers declarator compound_statement
 external_declaration -> function_definition
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration
Line: 3300  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3300  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3300  Token: IDENTIFIER        Lexeme: calcTimerTime
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 3300  Token: (  Lexeme: (
Line: 3300  Token: IDENTIFIER        Lexeme: timer
 type_specifier -> TYPE_NAME
Line: 3300  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
Line: 3300  Token: IDENTIFIER        Lexeme: t
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 3300  Token: COMPLEX           Lexeme: )
 declarator -> pointer direct_declarator
 parameter_declaration -> declaration_specifiers declarator
 parameter_list -> parameter_declaration
 parameter_type_list -> parameter_list
 direct_declarator -> direct_declarator '(' parameter_type_list ')'
Line: 3300  Token: {  Lexeme: {
 declarator -> direct_declarator
Line: 3302  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3302  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3302  Token: IDENTIFIER        Lexeme: time
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 3302  Token: ;  Lexeme: ;
 declarator -> direct_declarator
 init_declarator -> declarator
AddIdToList: time added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item
Line: 3303  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3303  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3303  Token: IDENTIFIER        Lexeme: delta
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
 direct_declarator -> IDENTIFIER
Line: 3303  Token: =  Lexeme: =
 declarator -> direct_declarator
Line: 3303  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3303  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 initializer -> assignment_expression
 init_declarator -> declarator '=' initializer
AddIdToList: delta added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 3304  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3304  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3304  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
Line: 3304  Token: IDENTIFIER        Lexeme: pStTick
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 3304  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pStTick added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 3305  Token: UNSIGNED          Lexeme: unsigned
 type_specifier -> UNSIGNED
Line: 3305  Token: LONG              Lexeme: long
 type_specifier -> LONG
Line: 3305  Token: *  Lexeme: *
 declaration_specifiers -> type_specifier
 declaration_specifiers -> type_specifier declaration_specifiers
Line: 3305  Token: IDENTIFIER        Lexeme: pEndTick
 pointer -> '*'
 direct_declarator -> IDENTIFIER
Line: 3305  Token: ;  Lexeme: ;
 declarator -> pointer direct_declarator
 init_declarator -> declarator
AddIdToList: pEndTick added to idList
 init_declarator_list -> init_declarator
 declaration -> declaration_specifiers init_declarator_list ';'
 block_item -> declaration
 block_item_list -> block_item_list block_item
Line: 3307  Token: IF                Lexeme: if
Line: 3307  Token: (  Lexeme: (
Line: 3307  Token: IDENTIFIER        Lexeme: t
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3307  Token: PTR_OP            Lexeme: ->
Line: 3307  Token: IDENTIFIER        Lexeme: tick
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3307  Token: [  Lexeme: [
Line: 3307  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3307  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3307  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 3307  Token: IDENTIFIER        Lexeme: t
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3307  Token: PTR_OP            Lexeme: ->
Line: 3307  Token: IDENTIFIER        Lexeme: tick
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3307  Token: [  Lexeme: [
Line: 3307  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3307  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3307  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3307  Token: {  Lexeme: {
Line: 3308  Token: IDENTIFIER        Lexeme: time
Line: 3308  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3308  Token: (  Lexeme: (
Line: 3308  Token: CONSTANT          Lexeme: 0xFFFFFFFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3308  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3308  Token: (  Lexeme: (
Line: 3308  Token: IDENTIFIER        Lexeme: t
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3308  Token: PTR_OP            Lexeme: ->
Line: 3308  Token: IDENTIFIER        Lexeme: tick
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3308  Token: [  Lexeme: [
Line: 3308  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3308  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3308  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3308  Token: IDENTIFIER        Lexeme: t
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3308  Token: PTR_OP            Lexeme: ->
Line: 3308  Token: IDENTIFIER        Lexeme: tick
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3308  Token: [  Lexeme: [
Line: 3308  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3308  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3308  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3308  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3308  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3308  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3308  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3309  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3309  Token: ELSE              Lexeme: else
Line: 3309  Token: {  Lexeme: {
Line: 3310  Token: IDENTIFIER        Lexeme: time
Line: 3310  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3310  Token: IDENTIFIER        Lexeme: t
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3310  Token: PTR_OP            Lexeme: ->
Line: 3310  Token: IDENTIFIER        Lexeme: tick
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3310  Token: [  Lexeme: [
Line: 3310  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3310  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3310  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3310  Token: IDENTIFIER        Lexeme: t
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3310  Token: PTR_OP            Lexeme: ->
Line: 3310  Token: IDENTIFIER        Lexeme: tick
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3310  Token: [  Lexeme: [
Line: 3310  Token: CONSTANT          Lexeme: 0
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3310  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3310  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3311  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3312  Token: IDENTIFIER        Lexeme: pStTick
Line: 3312  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3312  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3312  Token: (  Lexeme: (
Line: 3312  Token: IDENTIFIER        Lexeme: t
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3312  Token: PTR_OP            Lexeme: ->
Line: 3312  Token: IDENTIFIER        Lexeme: tick
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3312  Token: [  Lexeme: [
Line: 3312  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3312  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3312  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3312  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3313  Token: IDENTIFIER        Lexeme: pEndTick
Line: 3313  Token: =  Lexeme: =
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> '='
Line: 3313  Token: &  Lexeme: &
 unary_operator -> '&'
Line: 3313  Token: (  Lexeme: (
Line: 3313  Token: IDENTIFIER        Lexeme: t
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3313  Token: PTR_OP            Lexeme: ->
Line: 3313  Token: IDENTIFIER        Lexeme: tick
 postfix_expression -> postfix_expression PTR_OP IDENTIFIER
Line: 3313  Token: [  Lexeme: [
Line: 3313  Token: CONSTANT          Lexeme: 3
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3313  Token: ]  Lexeme: ]
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 postfix_expression -> postfix_expression '[' expression ']'
Line: 3313  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3313  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3315  Token: WHILE             Lexeme: while
Line: 3315  Token: (  Lexeme: (
Line: 3315  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3315  Token: IDENTIFIER        Lexeme: pStTick
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3315  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3315  Token: {  Lexeme: {
Line: 3316  Token: IF                Lexeme: if
Line: 3316  Token: (  Lexeme: (
Line: 3316  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3316  Token: IDENTIFIER        Lexeme: pEndTick
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3316  Token: <  Lexeme: <
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
Line: 3316  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3316  Token: IDENTIFIER        Lexeme: pStTick
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3316  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> relational_expression '<' shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
Line: 3316  Token: {  Lexeme: {
Line: 3317  Token: IDENTIFIER        Lexeme: delta
Line: 3317  Token: ADD_ASSIGN        Lexeme: +=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 3317  Token: (  Lexeme: (
Line: 3317  Token: (  Lexeme: (
Line: 3317  Token: CONSTANT          Lexeme: 0xFFFFFFFF
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3317  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3317  Token: (  Lexeme: (
Line: 3317  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3317  Token: IDENTIFIER        Lexeme: pStTick
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3317  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3317  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3317  Token: IDENTIFIER        Lexeme: pEndTick
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3317  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3317  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3317  Token: +  Lexeme: +
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3317  Token: CONSTANT          Lexeme: 1
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3317  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '+' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3317  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3318  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
Line: 3318  Token: ELSE              Lexeme: else
Line: 3318  Token: {  Lexeme: {
Line: 3319  Token: IDENTIFIER        Lexeme: delta
Line: 3319  Token: ADD_ASSIGN        Lexeme: +=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 3319  Token: (  Lexeme: (
Line: 3319  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3319  Token: IDENTIFIER        Lexeme: pEndTick
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3319  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3319  Token: *  Lexeme: *
 unary_operator -> '*'
Line: 3319  Token: IDENTIFIER        Lexeme: pStTick
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3319  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 unary_expression -> unary_operator cast_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3319  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3320  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 selection_statement -> IF '(' expression ')' statement ELSE statement
 statement -> selection_statement
 block_item -> statement
 block_item_list -> block_item
Line: 3321  Token: IDENTIFIER        Lexeme: pEndTick
Line: 3321  Token: ADD_ASSIGN        Lexeme: +=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 3321  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3321  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3322  Token: IDENTIFIER        Lexeme: pStTick
Line: 3322  Token: ADD_ASSIGN        Lexeme: +=
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
 unary_expression -> postfix_expression
 assignment_operator -> ADD_ASSIGN
Line: 3322  Token: CONSTANT          Lexeme: 2
 primary_expression -> CONSTANT
 postfix_expression -> primary_expression
Line: 3322  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 assignment_expression -> unary_expression assignment_operator assignment_expression
 expression -> assignment_expressio
 expression_statement -> expression ';'
 statement -> expression_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3324  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 statement -> compound_statement
 iteration_statement -> WHILE '(' expression ')' statement
 statementr -> iteration_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3325  Token: RETURN            Lexeme: return
Line: 3325  Token: (  Lexeme: (
Line: 3325  Token: IDENTIFIER        Lexeme: time
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3325  Token: -  Lexeme: -
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
Line: 3325  Token: IDENTIFIER        Lexeme: delta
 primary_expression -> IDENTIFIER
 postfix_expression -> primary_expression
Line: 3325  Token: COMPLEX           Lexeme: )
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> additive_expression '-' multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 primary_expression -> '(' expression ')'
 postfix_expression -> primary_expression
Line: 3325  Token: ;  Lexeme: ;
 unary_expression -> postfix_expression
 cast_expression -> unary_expression
 multiplicative_expression -> cast_expression
 additive_expression -> multiplicative_expression
 shift_expression -> additive_expression
 relational_expression -> shift_expression
 equality_expression -> relational_expression
 and_expression -> equality_expression
 exclusive_or_expression -> and_expression
 inclusive_or_expression -> exclusive_or_expression
 logical_and_expression -> inclusive_or_expression
 logical_or_expression -> logical_and_expression
 conditional_expression -> logical_or_expression
 assignment_expression -> conditional_expression
 expression -> assignment_expressio
 jump_statement -> RETURN expression ';'
 statement -> jump_statement
 block_item -> statement
 block_item_list -> block_item_list block_item
Line: 3326  Token: }  Lexeme: }
 compound_statement -> '{' block_item_list '}'
 function_definition -> declaration_specifiers declarator compound_statement
 external_declaration -> function_definition
ClrIdList: idList cleared
 translation_unit -> translation_unit external_declaration

***************** Symbol Table ***********************


 Symbol Table:  

Token     Lexeme                            Scope
! !
NE_OP            !=
STRING_LITERAL   ".hdwregs"
STRING_LITERAL   ".off_data"
& &
AND_OP           &&
AND_ASSIGN       &=
( (
COMPLEX          )
* *
+ +
INC_OP           ++
ADD_ASSIGN       +=
, ,
- -
DEC_OP           --
SUB_ASSIGN       -=
PTR_OP           ->
. .
/ /
CONSTANT         0
CONSTANT         0x0
CONSTANT         0x00007FFF
CONSTANT         0x0000FFFF
CONSTANT         0x0001
CONSTANT         0x0002
CONSTANT         0x0004
CONSTANT         0x0008
CONSTANT         0x0010
CONSTANT         0x00FFFFFF
CONSTANT         0x01
CONSTANT         0x02
CONSTANT         0x03
CONSTANT         0x04
CONSTANT         0x07
CONSTANT         0x0A
CONSTANT         0x0FFF0000
CONSTANT         0x1
CONSTANT         0x18
CONSTANT         0x48
CONSTANT         0x6A
CONSTANT         0x7020
CONSTANT         0x7FF
CONSTANT         0x8
CONSTANT         0x80000000
CONSTANT         0xFF
CONSTANT         0xFFFFFFFF
CONSTANT         1
CONSTANT         10
CONSTANT         100
CONSTANT         11
CONSTANT         12
CONSTANT         128
CONSTANT         13
CONSTANT         14
CONSTANT         15
CONSTANT         16
CONSTANT         18
CONSTANT         2
CONSTANT         20
CONSTANT         23
CONSTANT         24
CONSTANT         256
CONSTANT         27
CONSTANT         29
CONSTANT         3
CONSTANT         30
CONSTANT         31
CONSTANT         32
CONSTANT         4
CONSTANT         5
CONSTANT         6
CONSTANT         64
CONSTANT         7
CONSTANT         8
CONSTANT         9
: :
; ;
< <
LEFT_OP          <<
= =
EQ_OP            ==
> >
RIGHT_OP         >>
? ?
IDENTIFIER       DMA_TYPE_CRC_CNTXT
IDENTIFIER       DMA_TYPE_DSD
IDENTIFIER       DMA_TYPE_MIM
IDENTIFIER       DMA_TYPE_MQS
IDENTIFIER       DMA_TYPE_ROCE_CONTEXT
IDENTIFIER       DMA_TYPE_SWQE
IDENTIFIER       DipslayAllocatedDrpCrpBlockList
IDENTIFIER       DisplayDrpCrpChain
IDENTIFIER       DisplayMqsMessage
IDENTIFIER       FreePoolFifoReg
IDENTIFIER       HASH_ASSIGNED
IDENTIFIER       HASH_DELETED
IDENTIFIER       HASH_FREE
IDENTIFIER       HASH_RO
IDENTIFIER       HQP_STATE_INACTIVE
IDENTIFIER       HQP_STATE_PROC_IOCB
IDENTIFIER       HQP_STATE_SLOW_PATH_REQ
IDENTIFIER       HQP_STATE_WAIT_DMACB
IDENTIFIER       HQP_STATE_WAIT_DRPCRP_DESC
IDENTIFIER       HQP_STATE_WAIT_FOR_CRC_CNTXT_DMA
IDENTIFIER       HQP_STATE_WAIT_FOR_CRC_DIF_DMA
IDENTIFIER       HQP_STATE_WAIT_FOR_DIF_LPTR_DMA
IDENTIFIER       HQP_STATE_WAIT_FOR_DSD_DMA
IDENTIFIER       HQP_STATE_WAIT_FOR_DSD_LPTR_DMA
IDENTIFIER       HQP_STATE_WAIT_FOR_MIM_BLK_ALLOC
IDENTIFIER       HQP_STATE_WAIT_FOR_MIM_DMA
IDENTIFIER       HQP_STATE_WAIT_FOR_MQS_DMA
IDENTIFIER       HQP_STATE_WAIT_HQP_CNTXT_DMA
IDENTIFIER       HQP_STATE_WAIT_IOCB_BLK
IDENTIFIER       HQP_STATE_WAIT_SQ_CNTXT_DMA
IDENTIFIER       HqpLookup
IDENTIFIER       OpcodeFormat
IDENTIFIER       PROT_HQP
IDENTIFIER       PROT_ROCE
IDENTIFIER       ProcessDsdList
IDENTIFIER       ProcessSlowPathRequest
TYPE_NAME        Qobj
TYPE_NAME        Que
IDENTIFIER       ReadOpcodeFormatRam
IDENTIFIER       ReleaseHqpResources
IDENTIFIER       SlowPathIocb_Ct6DsdList
IDENTIFIER       SlowPathIocb_Ct7Ct1
IDENTIFIER       SlowPathIocb_CtCRC_2DsdList
TYPE_NAME        T_HASH_SLOT_STATE
TYPE_NAME        U16
TYPE_NAME        U32
TYPE_NAME        U64
TYPE_NAME        U8
[ [
] ]
IDENTIFIER       _FCP_CDB
IDENTIFIER       _Qobj
IDENTIFIER       _Que
WHILE            __attribute__
IDENTIFIER       _bufDesc
IDENTIFIER       _bufQue
IDENTIFIER       _dmaCB
IDENTIFIER       _dmaQue
TYPE_NAME        _dmaType
IDENTIFIER       _drpCrpQue
IDENTIFIER       _drp_crp
IDENTIFIER       _hashEntry
IDENTIFIER       _hqmHqpCntxt
IDENTIFIER       _hqpCb
IDENTIFIER       _hqpCntxtEntry
IDENTIFIER       _hqpQue
TYPE_NAME        _hqpState
IDENTIFIER       _mqsLink
IDENTIFIER       _mqsMessage
IDENTIFIER       _opcodeFormatRamEntry
TYPE_NAME        _protType
IDENTIFIER       _scsiBlk
IDENTIFIER       _sp_regs
IDENTIFIER       _sqCntxtEntry
IDENTIFIER       _timer
IDENTIFIER       abFifoIsEmpty
IDENTIFIER       abFifoIsFull
IDENTIFIER       abHdwSimFifoInit
IDENTIFIER       abHdwSimFifoIsFull
IDENTIFIER       actNumIocbBlks
IDENTIFIER       addr_hi
IDENTIFIER       addr_lo
IDENTIFIER       adr
IDENTIFIER       adrh
IDENTIFIER       adrl
TYPE_NAME        alcb_struct
IDENTIFIER       aligned
IDENTIFIER       allocDrpCrp
IDENTIFIER       anonBuf
IDENTIFIER       app_mask
IDENTIFIER       app_tag
IDENTIFIER       atio_attr
IDENTIFIER       atio_cmnd_len
IDENTIFIER       atio_frame_hdr
IDENTIFIER       atio_payload
IDENTIFIER       atio_s
TYPE_NAME        atio_struct
IDENTIFIER       blk_dsd_cnt
IDENTIFIER       blk_id
IDENTIFIER       block_sz
BREAK            break
IDENTIFIER       buf
TYPE_NAME        bufDesc
TYPE_NAME        bufQue
IDENTIFIER       calcTimerTime
CASE             case
IDENTIFIER       cdb
CHAR             char
IDENTIFIER       cmnd6
IDENTIFIER       cmnd6_s
TYPE_NAME        cmnd6_struct
IDENTIFIER       cmnd7
IDENTIFIER       cmnd7_s
TYPE_NAME        cmnd7_struct
IDENTIFIER       cmnd_app_mask
IDENTIFIER       cmnd_app_mask0
IDENTIFIER       cmnd_app_tag
IDENTIFIER       cmnd_app_tag0
IDENTIFIER       cmnd_byte_cnt
IDENTIFIER       cmnd_cdb0
IDENTIFIER       cmnd_cdb1
IDENTIFIER       cmnd_cdb2
IDENTIFIER       cmnd_cdb3
IDENTIFIER       cmnd_cntl
IDENTIFIER       cmnd_crc1
IDENTIFIER       cmnd_crc1_rsvd_0
IDENTIFIER       cmnd_crc1_s
TYPE_NAME        cmnd_crc1_struct
IDENTIFIER       cmnd_crc2
IDENTIFIER       cmnd_crc2_s
TYPE_NAME        cmnd_crc2_struct
IDENTIFIER       cmnd_crc3
IDENTIFIER       cmnd_crc3_opts
IDENTIFIER       cmnd_crc3_s
TYPE_NAME        cmnd_crc3_struct
IDENTIFIER       cmnd_crc_ctx_dsd
IDENTIFIER       cmnd_crn
IDENTIFIER       cmnd_dataseg0
IDENTIFIER       cmnd_fcpcmd_adr_h
IDENTIFIER       cmnd_fcpcmd_adr_hi
IDENTIFIER       cmnd_fcpcmd_adr_l
IDENTIFIER       cmnd_fcpcmd_adr_lo
IDENTIFIER       cmnd_fcpcmd_len
IDENTIFIER       cmnd_fcprsp_adr_h
IDENTIFIER       cmnd_fcprsp_adr_hi
IDENTIFIER       cmnd_fcprsp_adr_l
IDENTIFIER       cmnd_fcprsp_adr_lo
IDENTIFIER       cmnd_fcprsp_len
IDENTIFIER       cmnd_handle
IDENTIFIER       cmnd_lun_h
IDENTIFIER       cmnd_lun_l
IDENTIFIER       cmnd_ref_mask0_h
IDENTIFIER       cmnd_ref_mask0_l
IDENTIFIER       cmnd_ref_mask_h
IDENTIFIER       cmnd_ref_mask_l
IDENTIFIER       cmnd_ref_tag
IDENTIFIER       cmnd_ref_tag0
IDENTIFIER       cmnd_rep_app_tag0
IDENTIFIER       cmnd_rep_ref_tag0_h
IDENTIFIER       cmnd_rep_ref_tag0_l
IDENTIFIER       cmnd_rsvd_0
IDENTIFIER       cmnd_seg_cnt
IDENTIFIER       cmnd_target
IDENTIFIER       cmnd_target_id
IDENTIFIER       cmnd_timeout
IDENTIFIER       cmnd_tm
IDENTIFIER       cmnd_vp_index
IDENTIFIER       cntxtAdr
IDENTIFIER       cntxtRegion
IDENTIFIER       cntxtSize
IDENTIFIER       consIdx
IDENTIFIER       cont1
IDENTIFIER       cont1_s
TYPE_NAME        cont1_struct
IDENTIFIER       cont_crc1
IDENTIFIER       cont_crc1_s
TYPE_NAME        cont_crc1_struct
IDENTIFIER       cont_dataseg
CONTINUE         continue
IDENTIFIER       conxId
IDENTIFIER       conxIdIncCountReg
IDENTIFIER       conxIdPrefix
IDENTIFIER       conxIdPsn
IDENTIFIER       count
IDENTIFIER       createAlcbs
IDENTIFIER       crp
TYPE_NAME        crp_struct
IDENTIFIER       ctio7
IDENTIFIER       ctio7_s
TYPE_NAME        ctio7_struct
IDENTIFIER       ctio_add_flags
IDENTIFIER       ctio_app_mask0
IDENTIFIER       ctio_app_tag0
IDENTIFIER       ctio_byte_cnt
IDENTIFIER       ctio_crc1
IDENTIFIER       ctio_crc1_s
TYPE_NAME        ctio_crc1_struct
IDENTIFIER       ctio_crc2
IDENTIFIER       ctio_crc2_s
TYPE_NAME        ctio_crc2_struct
IDENTIFIER       ctio_crc3
IDENTIFIER       ctio_crc3_s
TYPE_NAME        ctio_crc3_struct
IDENTIFIER       ctio_crc4
IDENTIFIER       ctio_crc4_s
TYPE_NAME        ctio_crc4_struct
IDENTIFIER       ctio_crc_ctx_dsd
IDENTIFIER       ctio_dataseg0
IDENTIFIER       ctio_flags
IDENTIFIER       ctio_guard_seed
IDENTIFIER       ctio_handle
IDENTIFIER       ctio_init_id
IDENTIFIER       ctio_oxid
IDENTIFIER       ctio_prot_opts
IDENTIFIER       ctio_ref_mask0_h
IDENTIFIER       ctio_ref_mask0_l
IDENTIFIER       ctio_ref_tag0
IDENTIFIER       ctio_rep_app_tag0
IDENTIFIER       ctio_rep_ref_tag0_h
IDENTIFIER       ctio_rep_ref_tag0_l
IDENTIFIER       ctio_resid_len
IDENTIFIER       ctio_ro
IDENTIFIER       ctio_rsp_len
IDENTIFIER       ctio_rsp_sns_info
IDENTIFIER       ctio_rsvd_0
IDENTIFIER       ctio_rsvd_1
IDENTIFIER       ctio_rsvd_2
IDENTIFIER       ctio_rsvd_3
IDENTIFIER       ctio_rsvd_4
IDENTIFIER       ctio_rsvd_5
IDENTIFIER       ctio_scsi_sts
IDENTIFIER       ctio_seg_cnt
IDENTIFIER       ctio_sns_len
IDENTIFIER       ctio_status
IDENTIFIER       ctio_target
IDENTIFIER       ctio_timeout
IDENTIFIER       ctio_tot_ptc
IDENTIFIER       ctio_vp_index
IDENTIFIER       ctl_flags
IDENTIFIER       ctrlFlagsMsk
IDENTIFIER       ctrlFlagsPsn
IDENTIFIER       curBlk
IDENTIFIER       cur_dsd
IDENTIFIER       cur_dsd_rist
IDENTIFIER       data_digest
IDENTIFIER       data_dsd
IDENTIFIER       dataseg
IDENTIFIER       db
IDENTIFIER       db_data_pxc
IDENTIFIER       db_dif_pxc
TYPE_NAME        dcrc_ctxt_struct
DEFAULT          default
IDENTIFIER       delta
IDENTIFIER       deque
IDENTIFIER       dequeAbFifo
IDENTIFIER       dequeAndUpdateDmaCbStatus
IDENTIFIER       dequeDmaCb
IDENTIFIER       dequeHqpCb
IDENTIFIER       dequeueAbHdwSimFifo
IDENTIFIER       dequeueFpHdwSimFifo
IDENTIFIER       dfree
IDENTIFIER       dici
IDENTIFIER       dif_dsd
IDENTIFIER       disk_crc_ctxt_s
TYPE_NAME        dmaCb
IDENTIFIER       dmaCbArray
IDENTIFIER       dmaCbWaitQ
TYPE_NAME        dmaQue
IDENTIFIER       dmaQueIsEmpty
TYPE_NAME        dmaType
IDENTIFIER       dmalloc
IDENTIFIER       drp
IDENTIFIER       drpCrpArray
IDENTIFIER       drpCrpFreePool
TYPE_NAME        drpCrpQue
IDENTIFIER       drpCrpWaitQ
IDENTIFIER       drp_adr
TYPE_NAME        drp_crp
TYPE_NAME        drp_struct
IDENTIFIER       dsd
IDENTIFIER       dsdCount
IDENTIFIER       dsdIndxInBuf
IDENTIFIER       dsdIndxInDrpCrp
IDENTIFIER       dsdListPointer
IDENTIFIER       dsd_list_0
IDENTIFIER       dsd_list_1
TYPE_NAME        dseg_struct
IDENTIFIER       duci
IDENTIFIER       dummyBufAdr
IDENTIFIER       dummyHqpId
IDENTIFIER       ecc
ELSE             else
IDENTIFIER       en
IDENTIFIER       enque
IDENTIFIER       enqueDmaCb
IDENTIFIER       enqueFpFifo
IDENTIFIER       enqueHqpCb
IDENTIFIER       enqueueAbHdwSimFifo
IDENTIFIER       enqueueFpHdwSimFifo
ENUM             enum
IDENTIFIER       exit
IDENTIFIER       exp_rx_ro
IDENTIFIER       exp_rx_seqid_cnt
IDENTIFIER       exp_tx_ro
IDENTIFIER       exp_tx_seqid_cnt
EXTERN           extern
IDENTIFIER       fc_fw_def
IDENTIFIER       fc_fw_def_s
TYPE_NAME        fc_fw_def_struct
IDENTIFIER       fc_iocb
IDENTIFIER       fc_iocb_hdr_s
TYPE_NAME        fc_iocb_hdr_struct
IDENTIFIER       fc_iocb_s
TYPE_NAME        fc_iocb_struct
IDENTIFIER       fciocb_assert_line_103
IDENTIFIER       fciocb_assert_line_167
IDENTIFIER       fciocb_assert_line_176
IDENTIFIER       fciocb_assert_line_200
IDENTIFIER       fciocb_assert_line_229
IDENTIFIER       fciocb_assert_line_252
IDENTIFIER       fciocb_assert_line_286
IDENTIFIER       fciocb_assert_line_308
IDENTIFIER       fciocb_assert_line_349
IDENTIFIER       fciocb_assert_line_382
IDENTIFIER       fciocb_assert_line_402
IDENTIFIER       fciocb_assert_line_417
IDENTIFIER       fciocb_assert_line_469
IDENTIFIER       fciocb_assert_line_503
IDENTIFIER       fciocb_assert_line_533
IDENTIFIER       fciocb_assert_line_577
IDENTIFIER       fciocb_assert_line_608
IDENTIFIER       fciocb_assert_line_649
IDENTIFIER       fciocb_assert_line_666
IDENTIFIER       fciocb_assert_line_87
IDENTIFIER       fill
IDENTIFIER       flags
FOR              for
IDENTIFIER       fpFifoIsEmpty
IDENTIFIER       fpFifoIsFull
IDENTIFIER       fpHdwSimFifoInit
IDENTIFIER       fpHdwSimFifoIsEmpty
IDENTIFIER       fpHdwSimFifoIsFull
IDENTIFIER       full_adr
IDENTIFIER       fwCntxt
IDENTIFIER       fwDsdQue
IDENTIFIER       fwMimQue
IDENTIFIER       fwSwqeQue
IDENTIFIER       genWaitQ
IDENTIFIER       gen_def
IDENTIFIER       gen_iocb
IDENTIFIER       getHqpContext
IDENTIFIER       getIocbStateString
IDENTIFIER       guard_seed
TYPE_NAME        hashEntry
IDENTIFIER       hdr
IDENTIFIER       hdr_digest
IDENTIFIER       hdwReg
IDENTIFIER       head
IDENTIFIER       hi_alcb
IDENTIFIER       hostDma
IDENTIFIER       hostDmaAdrhReg
IDENTIFIER       hostDmaAdrlReg
IDENTIFIER       hostDmaCmdReg
IDENTIFIER       hostDmaHdwSim
IDENTIFIER       hostDmaHqpIdReg
IDENTIFIER       hostDmaSpAdrReg
IDENTIFIER       hostPageSize
IDENTIFIER       hpq_id
IDENTIFIER       hqmCmdCmpltHdwSim
IDENTIFIER       hqmDebugReg
IDENTIFIER       hqmFetchHdwSim
TYPE_NAME        hqmHqpCntxt
IDENTIFIER       hqmHqpConfigReg
IDENTIFIER       hqmHqpStatusReg
IDENTIFIER       hqmIoRingReg
IDENTIFIER       hqmIpcMsgCmdReg
IDENTIFIER       hqmIpcMsgDataReg
IDENTIFIER       hqmLoadRamAdrReg
IDENTIFIER       hqmLoadRamDataReg
IDENTIFIER       hqmMimClr0HdwSim
IDENTIFIER       hqmMimDma0HdwSim
IDENTIFIER       hqmMqsDma0HdwSim
IDENTIFIER       hqmNumIocbPerBlockReg
IDENTIFIER       hqmSemaphoreReg
IDENTIFIER       hqmStatusReg
TYPE_NAME        hqpCb
IDENTIFIER       hqpCbArray
IDENTIFIER       hqpCbFreePool
IDENTIFIER       hqpCmdCmpltReg
IDENTIFIER       hqpCntxt
IDENTIFIER       hqpCntxtCmdReg
TYPE_NAME        hqpCntxtEntry
IDENTIFIER       hqpCntxtRp00
IDENTIFIER       hqpCntxtRp01
IDENTIFIER       hqpCntxtRp07
IDENTIFIER       hqpCntxtRp0BaseAddrBits
IDENTIFIER       hqpCntxtRp0BaseAdrh
IDENTIFIER       hqpCntxtRp0BaseAdrl
IDENTIFIER       hqpCntxtRp0ConsIndxAdrh
IDENTIFIER       hqpCntxtRp0ConsIndxAdrl
IDENTIFIER       hqpCntxtRp0ConsIndxBits
IDENTIFIER       hqpCntxtRp10
IDENTIFIER       hqpCntxtRp11
IDENTIFIER       hqpCntxtRp17
IDENTIFIER       hqpCntxtRp1BaseAddrBits
IDENTIFIER       hqpCntxtRp1BaseAdrh
IDENTIFIER       hqpCntxtRp1BaseAdrl
IDENTIFIER       hqpCntxtRp1ConsIndxAdrh
IDENTIFIER       hqpCntxtRp1ConsIndxAdrl
IDENTIFIER       hqpCntxtRp1ConsIndxBits
IDENTIFIER       hqpCntxtRq0
IDENTIFIER       hqpCntxtRq1
IDENTIFIER       hqpCntxtRq7
IDENTIFIER       hqpCntxtRqBaseAddrBits
IDENTIFIER       hqpCntxtRqBaseAdrh
IDENTIFIER       hqpCntxtRqBaseAdrl
IDENTIFIER       hqpCntxtRqConsIndxAdrh
IDENTIFIER       hqpCntxtRqConsIndxAdrl
IDENTIFIER       hqpCntxtRqConsIndxBits
IDENTIFIER       hqpCntxtSpAdrReg
IDENTIFIER       hqpCntxtW1
IDENTIFIER       hqpContextDmaHdwSim
IDENTIFIER       hqpCtxDma
IDENTIFIER       hqpId
IDENTIFIER       hqpIocbFetchReg
TYPE_NAME        hqpQue
IDENTIFIER       hqpQueIsEmpty
IDENTIFIER       hqpRdyQ
TYPE_NAME        hqpState
IDENTIFIER       hqpid
IDENTIFIER       i
IF               if
IDENTIFIER       indx
IDENTIFIER       initContext
IDENTIFIER       initHdwRegs
IDENTIFIER       initMim
IDENTIFIER       initOpcodeFormatRam
INT              int
IDENTIFIER       io_handle
IDENTIFIER       iocb
IDENTIFIER       iocbBlkWaitQ
IDENTIFIER       iocbBuf
IDENTIFIER       iocbCount
IDENTIFIER       iocbCountFmt
IDENTIFIER       iocbDma
IDENTIFIER       iocbDmaAdrhReg
IDENTIFIER       iocbDmaAdrlReg
IDENTIFIER       iocbDmaCmdReg
IDENTIFIER       iocbDmaHqpIdReg
IDENTIFIER       iocbDmaSpAdrReg
IDENTIFIER       iocbIndx
IDENTIFIER       iocbRegion
IDENTIFIER       iocb_cnt_typ
IDENTIFIER       iocb_count
IDENTIFIER       iocb_handle
IDENTIFIER       iocb_status
IDENTIFIER       iocb_sysdef_1
IDENTIFIER       iocb_type
IDENTIFIER       key
IDENTIFIER       lbuf
IDENTIFIER       length
IDENTIFIER       lengthInIocb
IDENTIFIER       link
IDENTIFIER       lo_alcb
LONG             long
IDENTIFIER       loopCount
IDENTIFIER       main
IDENTIFIER       mainLoop
IDENTIFIER       marker
IDENTIFIER       marker_s
TYPE_NAME        marker_struct
IDENTIFIER       mbuf
IDENTIFIER       mem_rgn
IDENTIFIER       memclrMim0
IDENTIFIER       memset
IDENTIFIER       mimBlkRqReg
IDENTIFIER       mimDma
IDENTIFIER       mimDma0AdrReg
IDENTIFIER       mimDma0BlkOffsetReg
IDENTIFIER       mimDma0CmdReg
IDENTIFIER       mimDma0SpAdrReg
IDENTIFIER       mimDma1AdrReg
IDENTIFIER       mimDma1BlkOffsetReg
IDENTIFIER       mimDma1CmdReg
IDENTIFIER       mimDma1SpAdrReg
TYPE_NAME        mim_adr_struct
IDENTIFIER       misc_data
IDENTIFIER       mlmHdwSim
IDENTIFIER       mode0
IDENTIFIER       mode1
IDENTIFIER       mode2
IDENTIFIER       mqsCnxIdIncHdwSim
IDENTIFIER       mqsDma
IDENTIFIER       mqsDma0CmdReg
IDENTIFIER       mqsDma1CmdReg
IDENTIFIER       mqsL1Que
IDENTIFIER       mqsL1q
TYPE_NAME        mqsLink
TYPE_NAME        mqsMessage
IDENTIFIER       mqsTieCnxReg
IDENTIFIER       mqsTieL1qReg
IDENTIFIER       mqsTiePrf0Reg
IDENTIFIER       mqsTiePrf1Reg
IDENTIFIER       mrkr_handle
IDENTIFIER       mrkr_lun_h
IDENTIFIER       mrkr_lun_l
IDENTIFIER       mrkr_modfr
IDENTIFIER       mrkr_rsvd_0
IDENTIFIER       mrkr_rsvd_1
IDENTIFIER       mrkr_rsvd_2
IDENTIFIER       mrkr_target
IDENTIFIER       mrkr_vp_index
IDENTIFIER       my_xid
IDENTIFIER       ndb_tot_pxc
IDENTIFIER       next
IDENTIFIER       non_db
IDENTIFIER       numDsds
IDENTIFIER       numDsegsInDrpCrp
IDENTIFIER       numIocbProcessed
IDENTIFIER       nvr
IDENTIFIER       nxtSeqNum
IDENTIFIER       nxt_crp_adr
IDENTIFIER       nxt_crp_ofst
IDENTIFIER       nxt_crp_ptr
IDENTIFIER       nxt_dsd_rel_idx
IDENTIFIER       opcode
IDENTIFIER       opcodeFmt
TYPE_NAME        opcodeFormatRamEntry
IDENTIFIER       othr_xid
IDENTIFIER       pBuf
IDENTIFIER       pBufAdr
IDENTIFIER       pCrcCntxt
IDENTIFIER       pCrp
IDENTIFIER       pCurCrpDrp
IDENTIFIER       pCurDrpCrpDesc
IDENTIFIER       pCurIocb
IDENTIFIER       pCurIocbBlk
IDENTIFIER       pDmaCb
IDENTIFIER       pDmaQue
IDENTIFIER       pDrp
IDENTIFIER       pDrpCrp
IDENTIFIER       pDrpCrpDesc
IDENTIFIER       pDrpCrpFreePool
IDENTIFIER       pDsdListPtr
IDENTIFIER       pDseg
IDENTIFIER       pDsegInDrpCrp
IDENTIFIER       pEndTick
IDENTIFIER       pHqpCb
IDENTIFIER       pHqpCbFreePool
IDENTIFIER       pHqpCntxtEntry
IDENTIFIER       pHqpId
IDENTIFIER       pHqpQue
IDENTIFIER       pIocb
IDENTIFIER       pIocbBlkChain
IDENTIFIER       pIocbBuf
IDENTIFIER       pMqsIocb
IDENTIFIER       pMsg
IDENTIFIER       pNextDmaCb
IDENTIFIER       pNxtTick
IDENTIFIER       pStTick
IDENTIFIER       pT10Cntxt
IDENTIFIER       packed
IDENTIFIER       pad_for_dma
IDENTIFIER       pad_for_mqs
IDENTIFIER       passCount
IDENTIFIER       pcb_adr
IDENTIFIER       pcieBits
IDENTIFIER       port
IDENTIFIER       prefetchContext
IDENTIFIER       prefetchIocb
IDENTIFIER       processIocb
TYPE_NAME        protType
IDENTIFIER       prot_opts
IDENTIFIER       protocol
IDENTIFIER       qes
IDENTIFIER       ql_struct_assert_line_102
IDENTIFIER       ql_struct_assert_line_124
IDENTIFIER       que
IDENTIFIER       queAdrh
IDENTIFIER       queAdrl
IDENTIFIER       queIsEmpty
IDENTIFIER       queLength
IDENTIFIER       rMb
IDENTIFIER       rawAbFifoData
IDENTIFIER       rcv_xchg_adr
IDENTIFIER       ref_mask
IDENTIFIER       ref_mask_h
IDENTIFIER       ref_mask_l
IDENTIFIER       ref_tag
IDENTIFIER       region
REGISTER         register
IDENTIFIER       rem_dsd_cnt
IDENTIFIER       rem_rx_cnt
IDENTIFIER       rem_tx_cnt
IDENTIFIER       rep_app_tag
IDENTIFIER       rep_ref_tag
IDENTIFIER       result
RETURN           return
IDENTIFIER       rmc
IDENTIFIER       roceCtxDma
IDENTIFIER       routeToSP
IDENTIFIER       rp0QueLength
IDENTIFIER       rp0hostPageSize
IDENTIFIER       rp0rmc
IDENTIFIER       rp0rsvd1
IDENTIFIER       rp1QueLength
IDENTIFIER       rp1hostPageSize
IDENTIFIER       rp1rmc
IDENTIFIER       rp1rsvd1
IDENTIFIER       rpe0
IDENTIFIER       rpe1
IDENTIFIER       rq0rsvd
IDENTIFIER       rq0rsvd0
IDENTIFIER       rq0rsvd2
IDENTIFIER       rq1rsvd0
IDENTIFIER       rq7rsvd0
IDENTIFIER       rqQueLength
IDENTIFIER       rqes
IDENTIFIER       rsvd
IDENTIFIER       rsvd0
IDENTIFIER       rsvd1
IDENTIFIER       rsvd2
IDENTIFIER       rsvd3
IDENTIFIER       rsvd4
IDENTIFIER       rsvd5
IDENTIFIER       rsvd_0
IDENTIFIER       rsvd_1
IDENTIFIER       rsvd_2
IDENTIFIER       rsvd_3
IDENTIFIER       runt_guard
IDENTIFIER       rx_dfctl
IDENTIFIER       rx_flags
IDENTIFIER       rx_seq_cnt
IDENTIFIER       rx_seq_id
IDENTIFIER       scratch
TYPE_NAME        scsiBlk
IDENTIFIER       scsi_own
IDENTIFIER       scsi_tag_s
IDENTIFIER       scsi_tm_delay
IDENTIFIER       scsi_tm_flags
IDENTIFIER       scsi_tm_handle
IDENTIFIER       scsi_tm_lun_h
IDENTIFIER       scsi_tm_lun_l
IDENTIFIER       scsi_tm_rsvd_0
IDENTIFIER       scsi_tm_rsvd_1
IDENTIFIER       scsi_tm_rsvd_2
IDENTIFIER       scsi_tm_rsvd_3
IDENTIFIER       scsi_tm_target
IDENTIFIER       scsi_tm_target_id
IDENTIFIER       scsi_tm_timeout
IDENTIFIER       scsi_tm_xvp_index
IDENTIFIER       section
IDENTIFIER       shdMb0
SHORT            short
IDENTIFIER       simIocbComplete
SIZEOF           sizeof
TYPE_NAME        skp_msk_dsd_struct
TYPE_NAME        skp_msk_tag_struct
IDENTIFIER       sm_dsd
IDENTIFIER       spBufAdr
IDENTIFIER       spRegs
TYPE_NAME        sp_regs
IDENTIFIER       sqCntxt
IDENTIFIER       sqCntxt3
IDENTIFIER       sqCntxtCmdReg
TYPE_NAME        sqCntxtEntry
IDENTIFIER       sqCntxtSpAdrReg
IDENTIFIER       sqCntxtUpCmdReg
IDENTIFIER       sqCntxtUpDataReg
IDENTIFIER       sqHash
IDENTIFIER       sqHashAdd
IDENTIFIER       sqHashDelete
IDENTIFIER       sqHashGet
IDENTIFIER       sqHashKey
IDENTIFIER       sqStatusReg
IDENTIFIER       state
IDENTIFIER       status0
STRUCT           struct
IDENTIFIER       sts0_iocb_s
TYPE_NAME        sts0_iocb_struct
IDENTIFIER       sts_act_dif
IDENTIFIER       sts_exp_dif
IDENTIFIER       sts_fcp_rsp_pyld_len
IDENTIFIER       sts_fw_resid
IDENTIFIER       sts_handle
IDENTIFIER       sts_oxid
IDENTIFIER       sts_retry_delay_timer
IDENTIFIER       sts_rsp_len
IDENTIFIER       sts_rsp_sns_info
IDENTIFIER       sts_rsvd_0
IDENTIFIER       sts_scsi_resid
IDENTIFIER       sts_scsi_status
IDENTIFIER       sts_sens_len
IDENTIFIER       sts_state_flags
IDENTIFIER       sts_status
IDENTIFIER       sts_status_flags
IDENTIFIER       sw
SWITCH           switch
IDENTIFIER       swqeDma
IDENTIFIER       swqeRegion
IDENTIFIER       t
IDENTIFIER       t10_crc_cntxt
IDENTIFIER       t10_ctx
IDENTIFIER       table
IDENTIFIER       tag
IDENTIFIER       tail
IDENTIFIER       task_retry_id
IDENTIFIER       tbd_scratch
IDENTIFIER       temp
IDENTIFIER       tick
IDENTIFIER       time
TYPE_NAME        timer
IDENTIFIER       tm_iocb_s
TYPE_NAME        tm_iocb_struct
IDENTIFIER       top
IDENTIFIER       tot_ofst
IDENTIFIER       totalNumDsds
IDENTIFIER       treg
IDENTIFIER       tskmgt
IDENTIFIER       tx_dfctl
IDENTIFIER       tx_flags
IDENTIFIER       tx_frm_sz
IDENTIFIER       tx_seq_cnt
IDENTIFIER       tx_seq_id
IDENTIFIER       type
TYPEDEF          typedef
TYPE_NAME        uint32
UNION            union
UNSIGNED         unsigned
IDENTIFIER       val
IDENTIFIER       valid
IDENTIFIER       value
IDENTIFIER       vld_flags_19to10
IDENTIFIER       vld_flags_9To0
VOID             void
VOLATILE         volatile
IDENTIFIER       vpid
IDENTIFIER       vr
WHILE            while
IDENTIFIER       workingOnDrp
IDENTIFIER       x_cont_link_adr
IDENTIFIER       x_event
IDENTIFIER       x_link_adr
IDENTIFIER       x_owner
TYPE_NAME        x_scsi_struct
IDENTIFIER       x_state
IDENTIFIER       xcb_s
TYPE_NAME        xcb_struct
{ {
| |
UNKNOWN    |=
} }
~ ~
